<!DOCTYPE html>
<html lang="ko">
<head>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({"gtm.start":new Date().getTime(),event:"gtm.js"});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!="dataLayer"?"&l="+l:"";j.async=true;j.src="https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f)})(window,document,"script","dataLayer","GTM-MV8KQGJF");</script>
<!-- End Google Tag Manager -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="description" content="ìˆœì„œì •í•˜ê¸°ì™€ ë‹¹ì²¨ì ë½‘ê¸°ë¥¼ í•œ ë²ˆì— í•  ìˆ˜ ìˆëŠ” ì‚¬ë‹¤ë¦¬ê²Œì„ì…ë‹ˆë‹¤. AI ì´ë¦„ ì¸ì‹ìœ¼ë¡œ í…ìŠ¤íŠ¸/ì´ë¯¸ì§€ì—ì„œ ì°¸ê°€ì ì´ë¦„ì„ ë¹ ë¥´ê²Œ ì„¤ì •í•˜ê³  ëœë¤ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”.">
<meta name="keywords" content="ì‚¬ë‹¤ë¦¬ê²Œì„, ì‚¬ë‹¤ë¦¬íƒ€ê¸°, ìˆœì„œì •í•˜ê¸°, ë‹¹ì²¨, ëœë¤, ladder game, AI">
<meta property="og:title" content="ì‚¬ë‹¤ë¦¬ ê²Œì„ - ìˆœì„œ ì •í•˜ê¸°">
<meta property="og:description" content="ìˆœì„œì •í•˜ê¸°, ë‹¹ì²¨ì ë½‘ê¸°, AI ì´ë¦„ ì¸ì‹ì„ ì§€ì›í•˜ëŠ” ì‚¬ë‹¤ë¦¬ê²Œì„">
<meta property="og:type" content="website">
<meta property="og:url" content="https://game.cocy.io/ladder/">
<meta property="og:image" content="https://game.cocy.io/ladder/icon.svg">
<meta property="og:locale" content="ko_KR">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ì‚¬ë‹¤ë¦¬ ê²Œì„ - ìˆœì„œ ì •í•˜ê¸°">
<meta name="twitter:description" content="ìˆœì„œì •í•˜ê¸°, ë‹¹ì²¨ì ë½‘ê¸°, AI ì´ë¦„ ì¸ì‹ì„ ì§€ì›í•˜ëŠ” ì‚¬ë‹¤ë¦¬ê²Œì„">
<link rel="canonical" href="https://game.cocy.io/ladder/">
<link rel="icon" href="icon.svg">
<script type="application/ld+json">{"@context":"https://schema.org","@type":"WebApplication","name":"ì‚¬ë‹¤ë¦¬ ê²Œì„ - ìˆœì„œ ì •í•˜ê¸°","url":"https://game.cocy.io/ladder/","description":"ìˆœì„œì •í•˜ê¸°ì™€ ë‹¹ì²¨ì ë½‘ê¸°ë¥¼ ì§€ì›í•˜ê³  AI ì´ë¦„ ì¸ì‹ìœ¼ë¡œ ì°¸ê°€ì ì„¤ì •ì„ ë¹ ë¥´ê²Œ í•  ìˆ˜ ìˆëŠ” ì›¹ ì‚¬ë‹¤ë¦¬ê²Œì„","applicationCategory":"GameApplication","operatingSystem":"Web","offers":{"@type":"Offer","price":"0","priceCurrency":"KRW"}}</script>
<!-- AdSense: managed via GTM auto-ads (ca-pub-6634731722045607) -->
<title>ì‚¬ë‹¤ë¦¬ ê²Œì„ - ìˆœì„œ ì •í•˜ê¸°</title>
<script src="/lib/shared-wallet.js?v=20260214"></script>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background: #0a0b1e;
  color: #e8e8ff;
  font-family: 'Trebuchet MS', sans-serif;
  min-height: 100dvh;
  padding-top: calc(48px + env(safe-area-inset-top));
}
.wrap { max-width: 100%; margin: 0 auto; padding: 10px 4px 20px; }
h1 { text-align: center; font-size: 20px; color: #ffd700; margin-bottom: 2px; }
.sub { text-align: center; font-size: 11px; color: #8888bb; margin-bottom: 8px; }
.toolbar {
  display: flex; gap: 5px; justify-content: center; margin-bottom: 8px; flex-wrap: wrap;
}
.mode-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
  justify-content: center;
  margin: -2px 0 8px;
  flex-wrap: wrap;
}
.mode-toggle {
  display: inline-flex;
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 999px;
  overflow: hidden;
  background: rgba(255,255,255,0.04);
}
.mode-btn {
  border: none;
  background: transparent;
  color: #bdbde8;
  font-size: 11px;
  font-weight: 800;
  padding: 6px 12px;
  cursor: pointer;
}
.mode-btn.active {
  background: rgba(111,47,209,0.45);
  color: #fff;
}
.winner-count {
  display: none;
  align-items: center;
  gap: 5px;
  color: #ccc;
  font-size: 11px;
}
.winner-count.show { display: inline-flex; }
.wc-btn {
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.08);
  color: #fff;
  width: 22px;
  height: 22px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 800;
  cursor: pointer;
}
.wc-value {
  min-width: 18px;
  text-align: center;
  color: #ffd700;
  font-weight: 800;
}
.ai-bar {
  display: flex;
  gap: 4px;
  align-items: center;
  width: min(520px, 100%);
  margin: -2px auto 10px;
}
.ai-input {
  flex: 1;
  min-width: 120px;
  height: 32px;
  padding: 0 10px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: #fff;
  font-size: 12px;
}
.ai-input:focus {
  outline: none;
  border-color: #6f2fd1;
  box-shadow: 0 0 0 2px rgba(111,47,209,0.2);
}
.btn {
  padding: 6px 12px; border: none; border-radius: 8px;
  font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.2s;
}
.btn-icon { min-width: 36px; padding: 6px 8px; }
.btn:active { transform: scale(0.95); }
.btn-primary { background: #6f2fd1; color: #fff; }
.btn-warn { background: #ffd700; color: #222; }
.btn-secondary { background: rgba(255,255,255,0.12); color: #ccc; }
.btn-danger { background: #c0392b; color: #fff; }
.btn.loading { opacity: 0.75; pointer-events: none; }
.spinner {
  width: 13px;
  height: 13px;
  border: 2px solid rgba(255,255,255,0.4);
  border-top-color: #fff;
  border-radius: 50%;
  display: inline-block;
  animation: spin 0.8s linear infinite;
  vertical-align: middle;
  margin-right: 5px;
}
@keyframes spin { to { transform: rotate(360deg); } }

.toast {
  position: fixed;
  left: 50%;
  bottom: calc(20px + env(safe-area-inset-bottom));
  transform: translateX(-50%) translateY(20px);
  background: rgba(15,16,38,0.95);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 10px;
  padding: 9px 12px;
  font-size: 12px;
  opacity: 0;
  pointer-events: none;
  transition: all 0.25s ease;
  z-index: 1001;
}
.toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.scroll-container {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  width: 100%;
}
.ladder-area {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

.names-row, .bottom-row {
  display: flex; gap: 0; white-space: nowrap;
}
.name-cell {
  flex: 0 0 auto;
  text-align: center; cursor: pointer;
  padding: 5px 1px; border-radius: 5px;
  background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
  font-size: 11px; font-weight: 700; color: #fff; transition: all 0.2s;
  user-select: none; margin: 0 1px;
}
.name-cell:hover { background: rgba(255,255,255,0.18); }
.name-cell.done { opacity: 0.5; cursor: default; }

canvas {
  display: block; touch-action: pan-x; background: rgba(0,0,0,0.25);
}

.order-cell {
  flex: 0 0 auto;
  text-align: center; padding: 5px 1px;
  border-radius: 5px; font-size: 12px; font-weight: 800;
  background: rgba(255,215,0,0.08); border: 1px solid rgba(255,215,0,0.2);
  color: #ffd700; transition: all 0.3s; margin: 0 1px;
}
.order-cell.hidden { color: transparent; background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); }
.order-cell.hidden::after { content: '?'; color: #444; }
.order-cell.winner {
  background: rgba(255,215,0,0.18);
  border-color: rgba(255,215,0,0.7);
  color: #ffd700;
}
.order-cell.loser {
  background: rgba(180,180,180,0.1);
  border-color: rgba(170,170,170,0.35);
  color: #b6b6c8;
}

.scoreboard {
  margin-top: 12px; background: rgba(255,255,255,0.04);
  border-radius: 10px; padding: 10px 12px; display: none;
  max-width: 400px; margin-left: auto; margin-right: auto;
}
.scoreboard.show { display: block; }
.scoreboard h3 { font-size: 13px; color: #ffd700; margin-bottom: 6px; text-align: center; }
.sb-row { display: flex; justify-content: space-between; padding: 2px 4px; font-size: 13px; border-bottom: 1px solid rgba(255,255,255,0.05); }
.sb-row .sbn { color: #ccc; }
.sb-row .sbo { color: #ffd700; font-weight: 700; min-width: 36px; }
.sb-row .sbo.muted { color: #a9a9ba; }

.edit-section {
  margin-top: 10px; text-align: center;
}
.edit-row {
  display: flex; gap: 3px; overflow-x: auto; padding: 6px 0;
  -webkit-overflow-scrolling: touch;
}
.edit-input {
  width: 50px; min-width: 50px; padding: 5px 2px; text-align: center;
  background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
  border-radius: 6px; color: #ccc; font-size: 11px;
}
.edit-input:focus { border-color: #ffd700; outline: none; color: #fff; }

.result-banner {
  position: fixed; top: 50%; left: 50%;
  transform: translate(-50%, -50%) scale(0);
  background: rgba(10,11,30,0.96); border: 2px solid #ffd700;
  border-radius: 16px; padding: 20px 28px; text-align: center;
  z-index: 999; transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1);
  pointer-events: none; min-width: 160px;
}
.result-banner.show { transform: translate(-50%, -50%) scale(1); pointer-events: auto; }
.result-banner .rname { font-size: 22px; font-weight: 800; color: #fff; }
.result-banner .rarrow { font-size: 18px; color: #ffd700; margin: 4px 0; }
.result-banner .rorder { font-size: 44px; font-weight: 900; color: #ffd700; }
.result-banner .rlabel { font-size: 12px; color: #aaa; }
.result-banner.win {
  border-color: #ffd700;
  box-shadow: 0 0 24px rgba(255,215,0,0.28);
}
.result-banner.lose {
  border-color: #7f8495;
  box-shadow: 0 0 20px rgba(127,132,149,0.2);
}
.result-banner.lose .rorder { color: #b7bbca; }
.result-banner.lose .rarrow { color: #9ca1b0; }
</style>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MV8KQGJF" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div class="wrap">
  <h1>ğŸªœ ì‚¬ë‹¤ë¦¬ ê²Œì„</h1>
  <div class="sub" id="subText">ì´ë¦„ì„ í„°ì¹˜í•˜ë©´ ìˆœì„œê°€ ì •í•´ì§‘ë‹ˆë‹¤</div>
  <div class="toolbar">
    <button class="btn btn-primary" onclick="shuffle()">ğŸ”€ ì„ê¸°</button>
    <button class="btn btn-warn" onclick="revealAll()">ğŸ‘€ ì „ì²´ê³µê°œ</button>
    <button class="btn btn-secondary" onclick="addPerson()">â• ì¶”ê°€</button>
    <button class="btn btn-danger" onclick="removeLast()">â– ì‚­ì œ</button>
    <button class="btn btn-secondary" onclick="toggleEdit()">âœï¸ ìˆ˜ì •</button>
  </div>
  <div class="mode-wrap">
    <div class="mode-toggle">
      <button id="modeOrderBtn" class="mode-btn active" onclick="setGameMode('order')">ìˆœì„œ</button>
      <button id="modeWinnerBtn" class="mode-btn" onclick="setGameMode('winner')">ë‹¹ì²¨</button>
    </div>
    <div id="winnerCountWrap" class="winner-count">
      <span>ë‹¹ì²¨ìˆ˜:</span>
      <button class="wc-btn" onclick="changeWinnerCount(-1)">-</button>
      <span id="winnerCountValue" class="wc-value">1</span>
      <button class="wc-btn" onclick="changeWinnerCount(1)">+</button>
    </div>
  </div>
  <div class="ai-bar">
    <input id="aiInput" class="ai-input" type="text" placeholder="âœ¨ ì˜ˆ: 5ëª… / ì² ìˆ˜ ì˜í¬ ë¯¼ìˆ˜" />
    <button id="aiSetupBtn" class="btn btn-primary" onclick="applyAiText()">âœ¨ AI ì„¤ì •</button>
    <button id="aiImageBtn" class="btn btn-secondary btn-icon" onclick="pickAiImage()" title="ì´ë¯¸ì§€ì—ì„œ ì´ë¦„ ì¶”ì¶œ">ğŸ“·</button>
    <input id="aiImageInput" type="file" accept="image/*" style="display:none" onchange="applyAiImage(event)" />
  </div>
  <div class="scroll-container" id="scrollWrap">
    <div class="ladder-area" id="ladderArea">
      <div class="names-row" id="namesRow"></div>
      <canvas id="cv"></canvas>
      <div class="bottom-row" id="bottomRow"></div>
    </div>
  </div>
  <div class="scoreboard" id="scoreboard"><h3 id="scoreTitle">ğŸ“‹ ìˆœì„œ ê²°ê³¼</h3><div id="sbBody"></div></div>
  <div class="edit-section">
    <div class="edit-row" id="editRow" style="display:none"></div>
  </div>
</div>
<div class="result-banner" id="banner">
  <div class="rname" id="bName"></div>
  <div class="rarrow">â–¼</div>
  <div class="rorder" id="bOrder"></div>
  <div class="rlabel" id="bLabel">ë²ˆì§¸ ìˆœì„œ</div>
</div>
<div class="toast" id="toast"></div>

<script>
const LLM_ENDPOINT = 'https://llm.cocy.io/v2/chat/completions';
const LLM_AUTH = 'Bearer choon150622';
const NAMES_STORAGE_KEY = 'ladder_names';
const COLORS = [
  '#ff4444','#44aaff','#44ff88','#ffaa00','#ff44cc','#44ffff','#aa88ff',
  '#ff8844','#88ff44','#ff4488','#44ccaa','#ffff44','#cc88ff','#ff6688',
  '#88ddff','#ffcc44','#66ffaa','#dd66ff','#ff8866','#66aaff'
];

let names = loadNames();
let gameMode = 'order';
let winnerCount = 1;
let orders = [];
let winnerSlots = [];
let rungs = [];
let revealed = new Set();
let revealedResults = {};
let animating = false;
let editMode = false;
let toastTimer = null;

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const banner = document.getElementById('banner');

const COL_W = 48;
const PAD = 20;
const CANVAS_H = 420;

function clampWinnerCount(value) {
  const max = Math.max(1, names.length - 1);
  return Math.max(1, Math.min(max, Number(value) || 1));
}

function renderModeUI() {
  const isWinner = gameMode === 'winner';
  document.getElementById('modeOrderBtn').classList.toggle('active', !isWinner);
  document.getElementById('modeWinnerBtn').classList.toggle('active', isWinner);
  document.getElementById('winnerCountWrap').classList.toggle('show', isWinner);
  document.getElementById('winnerCountValue').textContent = String(winnerCount);
  document.getElementById('subText').textContent = isWinner
    ? 'ì´ë¦„ì„ í„°ì¹˜í•˜ë©´ ë‹¹ì²¨ ì—¬ë¶€ê°€ ì •í•´ì§‘ë‹ˆë‹¤'
    : 'ì´ë¦„ì„ í„°ì¹˜í•˜ë©´ ìˆœì„œê°€ ì •í•´ì§‘ë‹ˆë‹¤';
  document.getElementById('scoreTitle').textContent = isWinner ? 'ğŸ“‹ ë‹¹ì²¨ ê²°ê³¼' : 'ğŸ“‹ ìˆœì„œ ê²°ê³¼';
}

function setGameMode(mode) {
  if (mode !== 'order' && mode !== 'winner') return;
  if (gameMode === mode) return;
  gameMode = mode;
  shuffle();
}

function changeWinnerCount(delta) {
  const next = clampWinnerCount(winnerCount + delta);
  if (next === winnerCount) return;
  winnerCount = next;
  if (gameMode === 'winner') shuffle();
  else renderModeUI();
}

function genericNames(count = 4) {
  const n = Math.max(2, Math.min(20, Number(count) || 4));
  return Array.from({ length: n }, (_, i) => `ì°¸ê°€ì${i + 1}`);
}

function sanitizeNames(list) {
  if (!Array.isArray(list)) return [];
  const clean = list
    .map((v) => String(v ?? '').trim())
    .filter(Boolean)
    .slice(0, 20);
  return clean.length >= 2 ? clean : [];
}

function loadNames() {
  try {
    const raw = localStorage.getItem(NAMES_STORAGE_KEY);
    if (!raw) return genericNames(4);
    const parsed = JSON.parse(raw);
    const cleaned = sanitizeNames(parsed);
    return cleaned.length ? cleaned : genericNames(4);
  } catch {
    return genericNames(4);
  }
}

function saveNames() {
  localStorage.setItem(NAMES_STORAGE_KEY, JSON.stringify(names));
}

function setNames(nextNames) {
  const cleaned = sanitizeNames(nextNames);
  if (!cleaned.length) {
    showToast('ì´ë¦„ì€ ìµœì†Œ 2ëª… ì´ìƒ í•„ìš”í•´ìš”');
    return;
  }
  names = cleaned;
  winnerCount = clampWinnerCount(winnerCount);
  saveNames();
  shuffle();
  if (editMode) buildEditRow();
}

function calcWidth() {
  return Math.max(PAD * 2 + (names.length - 1) * COL_W + 20, window.innerWidth - 8);
}

function setupCanvas() {
  const w = calcWidth();
  cv.width = w * 2;
  cv.height = CANVAS_H * 2;
  cv.style.width = w + 'px';
  cv.style.height = CANVAS_H + 'px';
  ctx.setTransform(2, 0, 0, 2, 0, 0);
}

function getX(col) { return PAD + col * COL_W; }
function getY(frac) { return 8 + frac * (CANVAS_H - 16); }

function buildUI() {
  const cellW = COL_W + 'px';
  const nr = document.getElementById('namesRow');
  nr.innerHTML = names.map((n, i) => {
    const done = revealed.has(i);
    const color = done ? COLORS[i % COLORS.length] : '';
    const style = `width:${cellW};` + (color ? `border-color:${color};color:${color}` : '');
    return `<div class="name-cell${done ? ' done' : ''}" style="${style}" onclick="pickName(${i})">${n}</div>`;
  }).join('');

  const br = document.getElementById('bottomRow');
  const bottomValues = gameMode === 'winner'
    ? winnerSlots.map((v) => v ? 'ğŸ‰ ë‹¹ì²¨' : 'ê½')
    : orders;
  br.innerHTML = bottomValues.map((value, i) => {
    const revCol = Object.entries(revealedResults).find(([_, v]) => v.endCol === i);
    if (revCol) {
      const topCol = parseInt(revCol[0], 10);
      if (gameMode === 'winner') {
        const isWinner = winnerSlots[i] === true;
        return `<div class="order-cell ${isWinner ? 'winner' : 'loser'}" style="width:${cellW}">${isWinner ? 'ğŸ‰ ë‹¹ì²¨' : 'ê½'}</div>`;
      }
      const color = COLORS[topCol % COLORS.length];
      return `<div class="order-cell" style="width:${cellW};border-color:${color};color:${color}">${value}</div>`;
    }
    return `<div class="order-cell hidden" style="width:${cellW}"></div>`;
  }).join('');

  renderModeUI();

  document.getElementById('ladderArea').style.width = calcWidth() + 'px';
  updateScoreboard();
}

function buildEditRow() {
  const er = document.getElementById('editRow');
  er.innerHTML = names.map((n, i) =>
    `<input class="edit-input" value="${n}" onchange="updateNameAt(${i}, this.value)">`
  ).join('');
}

function updateNameAt(index, value) {
  const v = String(value || '').trim();
  if (!v) {
    showToast('ë¹ˆ ì´ë¦„ì€ ì €ì¥í•  ìˆ˜ ì—†ì–´ìš”');
    buildEditRow();
    return;
  }
  names[index] = v;
  saveNames();
  buildUI();
}

function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function generateRungs() {
  const n = names.length;
  rungs = [];
  const rows = 14 + Math.floor(Math.random() * 8);
  for (let r = 0; r < rows; r++) {
    const y = (r + 1) / (rows + 1);
    const used = new Set();
    for (let c = 0; c < n - 1; c++) {
      if (used.has(c) || used.has(c - 1)) continue;
      if (Math.random() < 0.45) { rungs.push({ col: c, y }); used.add(c); }
    }
  }
}

function draw() {
  const w = cv.width / 2, h = CANVAS_H, n = names.length;
  ctx.clearRect(0, 0, w, h);
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1.5;
  for (let i = 0; i < n; i++) {
    const x = getX(i);
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.5;
  for (const rung of rungs) {
    const x1 = getX(rung.col), x2 = getX(rung.col + 1), y = getY(rung.y);
    ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
  }
}

function tracePath(startCol) {
  let col = startCol;
  const path = [{ x: getX(col), y: 0 }];
  const sorted = [...rungs].sort((a, b) => a.y - b.y);
  for (const rung of sorted) {
    const y = getY(rung.y);
    if (rung.col === col) {
      path.push({ x: getX(col), y }); col++;
      path.push({ x: getX(col), y });
    } else if (rung.col + 1 === col) {
      path.push({ x: getX(col), y }); col--;
      path.push({ x: getX(col), y });
    }
  }
  path.push({ x: getX(col), y: CANVAS_H });
  return { path, endCol: col };
}

function drawFullPath(startCol) {
  const { path } = tracePath(startCol);
  const color = COLORS[startCol % COLORS.length];
  ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
  ctx.stroke();
}

function animatePath(startCol, color, cb) {
  const { path, endCol } = tracePath(startCol);
  let totalLen = 0;
  const segs = [];
  for (let i = 1; i < path.length; i++) {
    const len = Math.hypot(path[i].x - path[i - 1].x, path[i].y - path[i - 1].y);
    segs.push({ from: path[i - 1], to: path[i], len }); totalLen += len;
  }
  const duration = 900;
  const start = performance.now();
  function step(now) {
    const t = Math.min(1, (now - start) / duration);
    const dist = t * totalLen;
    draw();
    for (const idx of revealed) if (idx !== startCol) drawFullPath(idx);
    ctx.strokeStyle = color; ctx.lineWidth = 3.5; ctx.lineCap = 'round';
    ctx.beginPath();
    let rem = dist, started = false;
    for (const seg of segs) {
      if (rem <= 0) break;
      const frac = Math.min(1, rem / seg.len);
      const ex = seg.from.x + (seg.to.x - seg.from.x) * frac;
      const ey = seg.from.y + (seg.to.y - seg.from.y) * frac;
      if (!started) { ctx.moveTo(seg.from.x, seg.from.y); started = true; }
      else ctx.lineTo(seg.from.x, seg.from.y);
      ctx.lineTo(ex, ey); rem -= seg.len;
    }
    ctx.stroke();
    if (t < 1) requestAnimationFrame(step);
    else { drawFullPath(startCol); cb(endCol); }
  }
  requestAnimationFrame(step);
}

function pickName(i) {
  if (animating || revealed.has(i)) return;
  animating = true;
  revealed.add(i);
  const color = COLORS[i % COLORS.length];
  animatePath(i, color, (endCol) => {
    const isWinner = gameMode === 'winner' ? winnerSlots[endCol] === true : false;
    revealedResults[i] = {
      endCol,
      order: gameMode === 'order' ? orders[endCol] : null,
      resultText: gameMode === 'winner' ? (isWinner ? 'ğŸ‰ ë‹¹ì²¨' : 'ê½') : null,
      isWinner
    };
    animating = false;
    buildUI();
    showBanner(names[i], revealedResults[i]);
  });
}

function showBanner(name, result) {
  const valueEl = document.getElementById('bOrder');
  const labelEl = document.getElementById('bLabel');
  document.getElementById('bName').textContent = name;
  banner.classList.remove('win', 'lose');

  if (gameMode === 'winner') {
    const isWinner = result?.isWinner === true;
    valueEl.textContent = isWinner ? 'ğŸ‰ ë‹¹ì²¨!' : 'ğŸ’¨ ê½!';
    labelEl.textContent = isWinner ? 'ì¶•í•˜í•©ë‹ˆë‹¤!' : 'ë‹¤ìŒ ê¸°íšŒì—!';
    banner.classList.add(isWinner ? 'win' : 'lose');
  } else {
    valueEl.textContent = result?.order ?? '';
    labelEl.textContent = 'ë²ˆì§¸ ìˆœì„œ';
  }

  banner.classList.add('show');
  setTimeout(() => {
    banner.classList.remove('show', 'win', 'lose');
  }, 2000);
}

function showToast(message) {
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => toast.classList.remove('show'), 2000);
}

function setAiLoading(isLoading) {
  const aiBtn = document.getElementById('aiSetupBtn');
  const imgBtn = document.getElementById('aiImageBtn');
  aiBtn.classList.toggle('loading', isLoading);
  imgBtn.classList.toggle('loading', isLoading);
  aiBtn.disabled = isLoading;
  imgBtn.disabled = isLoading;
  aiBtn.innerHTML = isLoading ? '<span class="spinner"></span>ë¶„ì„ì¤‘' : 'âœ¨ AI ì„¤ì •';
}

function tryExtractJson(content) {
  if (!content) return null;
  const trimmed = String(content).trim();
  try { return JSON.parse(trimmed); } catch {}
  const blockMatch = trimmed.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (blockMatch) {
    try { return JSON.parse(blockMatch[1]); } catch {}
  }
  const objMatch = trimmed.match(/\{[\s\S]*\}/);
  if (objMatch) {
    try { return JSON.parse(objMatch[0]); } catch {}
  }
  const arrMatch = trimmed.match(/\[[\s\S]*\]/);
  if (arrMatch) {
    try { return JSON.parse(arrMatch[0]); } catch {}
  }
  return null;
}

function parseNamePayload(payload) {
  if (Array.isArray(payload)) return sanitizeNames(payload);
  if (!payload || typeof payload !== 'object') return [];
  const fromNames = sanitizeNames(payload.names);
  if (fromNames.length) return fromNames;
  const c = Number(payload.count);
  if (Number.isFinite(c) && c >= 2) return genericNames(c);
  return [];
}

function extractCountFromText(text) {
  const match = String(text).match(/(\d+)\s*ëª…/);
  if (!match) return null;
  const count = Number(match[1]);
  return Number.isFinite(count) ? count : null;
}

async function callLlm(model, messages, maxTokens = 220) {
  const res = await fetch(LLM_ENDPOINT, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': LLM_AUTH
    },
    body: JSON.stringify({ model, messages, max_tokens: maxTokens })
  });
  if (!res.ok) {
    throw new Error(`API ì˜¤ë¥˜(${res.status})`);
  }
  const data = await res.json();
  return data?.choices?.[0]?.message?.content ?? '';
}

async function applyAiText() {
  const input = document.getElementById('aiInput');
  const userText = input.value.trim();
  if (!userText) {
    showToast('ë¨¼ì € ë¬¸ì¥ì„ ì…ë ¥í•´ì¤˜');
    return;
  }

  setAiLoading(true);
  try {
    const content = await callLlm('spark', [
      {
        role: 'system',
        content: 'ì‚¬ë‹¤ë¦¬ ê²Œì„ ì°¸ê°€ì ì¶”ì¶œê¸°ë‹¤. ì‚¬ìš©ì ë¬¸ì¥ì—ì„œ ì´ë¦„ ëª©ë¡ ë˜ëŠ” ì¸ì›ìˆ˜ë¥¼ ì¶”ì¶œí•˜ë¼. ë°˜ë“œì‹œ JSONë§Œ ë°˜í™˜: {"names": string[], "count": number|null}. ì´ë¦„ì´ ìˆìœ¼ë©´ names ìš°ì„ , ì—†ê³  ì¸ì›ìˆ˜ë§Œ ìˆìœ¼ë©´ count ì‚¬ìš©.'
      },
      { role: 'user', content: userText }
    ]);

    const parsed = tryExtractJson(content);
    let nextNames = parseNamePayload(parsed);

    if (!nextNames.length) {
      const fallbackCount = extractCountFromText(userText);
      if (fallbackCount && fallbackCount >= 2) nextNames = genericNames(fallbackCount);
    }

    if (!nextNames.length) {
      showToast('ì´ë¦„/ì¸ì›ìˆ˜ë¥¼ ì´í•´í•˜ì§€ ëª»í–ˆì–´');
      return;
    }

    setNames(nextNames);
    showToast('âœ¨ AI ì„¤ì • ì™„ë£Œ');
  } catch (err) {
    console.error(err);
    showToast('AI ì„¤ì • ì‹¤íŒ¨. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì¤˜');
  } finally {
    setAiLoading(false);
  }
}

function pickAiImage() {
  document.getElementById('aiImageInput').click();
}

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(String(reader.result));
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

async function applyAiImage(event) {
  const file = event?.target?.files?.[0];
  event.target.value = '';
  if (!file) return;

  setAiLoading(true);
  try {
    const dataUrl = await fileToDataUrl(file);
    const content = await callLlm('sonnet', [{
      role: 'user',
      content: [
        { type: 'text', text: 'ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•´ë¼.\n1. ì´ë¦„í‘œ, ëª…ì°°, í…ìŠ¤íŠ¸ë¡œ ëœ ì´ë¦„ì´ ë³´ì´ë©´ ì´ë¦„ì„ ì¶”ì¶œ: {"names": ["ì´ë¦„1", "ì´ë¦„2"]}\n2. ì´ë¦„ì€ ì•ˆ ë³´ì´ì§€ë§Œ ì‚¬ëŒë“¤ì´ ë³´ì´ë©´, ê° ì‚¬ëŒì„ ê°„ë‹¨íˆ ë¬˜ì‚¬í•´ì„œ êµ¬ë¶„ ê°€ëŠ¥í•œ ë³„ëª…ìœ¼ë¡œ: {"names": ["ì•ˆê²½ ì“´ ë‚¨ì", "ë¹¨ê°„ ëª¨ì ì—¬ì", "ê¸´ë¨¸ë¦¬ ì—¬ì"]}\n3. ì‚¬ëŒë„ ì´ë¦„ë„ ì—†ìœ¼ë©´: {"names": []}\në°˜ë“œì‹œ JSONë§Œ ë°˜í™˜.' },
        { type: 'image_url', image_url: { url: dataUrl } }
      ]
    }], 300);

    const parsed = tryExtractJson(content);
    const nextNames = parseNamePayload(parsed);

    if (!nextNames.length) {
      showToast('ì´ë¯¸ì§€ì—ì„œ ì´ë¦„ì„ ì°¾ì§€ ëª»í–ˆì–´');
      return;
    }

    setNames(nextNames);
    showToast('âœ¨ ì´ë¯¸ì§€ì—ì„œ ì´ë¦„ ì¶”ì¶œ ì™„ë£Œ');
  } catch (err) {
    console.error(err);
    showToast('ì´ë¯¸ì§€ ë¶„ì„ ì‹¤íŒ¨. ë‹¤ë¥¸ ì‚¬ì§„ìœ¼ë¡œ ì‹œë„í•´ì¤˜');
  } finally {
    setAiLoading(false);
  }
}

function revealAll() {
  if (animating) return;
  for (let i = 0; i < names.length; i++) {
    revealed.add(i);
    const { endCol } = tracePath(i);
    const isWinner = gameMode === 'winner' ? winnerSlots[endCol] === true : false;
    revealedResults[i] = {
      endCol,
      order: gameMode === 'order' ? orders[endCol] : null,
      resultText: gameMode === 'winner' ? (isWinner ? 'ğŸ‰ ë‹¹ì²¨' : 'ê½') : null,
      isWinner
    };
  }
  draw();
  for (let i = 0; i < names.length; i++) drawFullPath(i);
  buildUI();
}

function shuffle() {
  winnerCount = clampWinnerCount(winnerCount);
  orders = shuffleArray(names.map((_, i) => i + 1));
  winnerSlots = Array(names.length).fill(false);
  if (gameMode === 'winner') {
    const picked = shuffleArray(names.map((_, i) => i)).slice(0, winnerCount);
    for (const idx of picked) winnerSlots[idx] = true;
  }
  revealed.clear();
  revealedResults = {};
  generateRungs();
  setupCanvas();
  buildUI();
  draw();
  document.getElementById('scoreboard').classList.remove('show');
}

function updateScoreboard() {
  const sb = document.getElementById('scoreboard');
  const body = document.getElementById('sbBody');
  if (Object.keys(revealedResults).length === 0) { sb.classList.remove('show'); return; }
  sb.classList.add('show');

  if (gameMode === 'winner') {
    const sorted = Object.entries(revealedResults).sort((a, b) => {
      const av = a[1].isWinner ? 0 : 1;
      const bv = b[1].isWinner ? 0 : 1;
      if (av !== bv) return av - bv;
      return Number(a[0]) - Number(b[0]);
    });
    body.innerHTML = sorted.map(([col, v]) =>
      `<div class="sb-row"><span class="sbo ${v.isWinner ? '' : 'muted'}">${v.resultText}</span><span class="sbn">${names[col]}</span></div>`
    ).join('');
    return;
  }

  const sorted = Object.entries(revealedResults).sort((a, b) => a[1].order - b[1].order);
  body.innerHTML = sorted.map(([col, v]) =>
    `<div class="sb-row"><span class="sbo">${v.order}ë²ˆ</span><span class="sbn">${names[col]}</span></div>`
  ).join('');
}

function addPerson() {
  const n = prompt('ì¶”ê°€í•  ì´ë¦„:');
  if (!n || !n.trim()) return;
  names.push(n.trim());
  winnerCount = clampWinnerCount(winnerCount);
  saveNames();
  shuffle();
  if (editMode) buildEditRow();
}

function removeLast() {
  if (names.length <= 2) return;
  names.pop();
  winnerCount = clampWinnerCount(winnerCount);
  saveNames();
  shuffle();
  if (editMode) buildEditRow();
}

function toggleEdit() {
  editMode = !editMode;
  const er = document.getElementById('editRow');
  er.style.display = editMode ? 'flex' : 'none';
  if (editMode) buildEditRow();
}

cv.addEventListener('click', (e) => {
  if (animating) return;
  const rect = cv.getBoundingClientRect();
  const scaleX = (cv.width / 2) / rect.width;
  const x = (e.clientX - rect.left) * scaleX;
  let best = -1, bestD = Infinity;
  for (let i = 0; i < names.length; i++) {
    const d = Math.abs(x - getX(i));
    if (d < bestD) { bestD = d; best = i; }
  }
  if (best >= 0 && bestD < COL_W * 0.6 && !revealed.has(best)) pickName(best);
});

window.addEventListener('resize', () => {
  setupCanvas();
  draw();
  for (const idx of revealed) drawFullPath(idx);
});

shuffle();
</script>
</body>
</html>
