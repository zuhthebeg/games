<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>오목 - Gomoku</title>
    <link rel="icon" href="icon.svg">
    <style>
        :root {
            --bg: #1a1a2e;
            --board: #dcb35c;
            --board-line: #8b6914;
            --text: #eee;
            --accent: #4ecca3;
            --danger: #ff6b6b;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        #app {
            min-height: 100vh;
        }

        /* Game Screen */
        .game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            padding-top: 60px; /* SharedWallet 바 공간 */
            min-height: 100vh;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin-bottom: 12px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            border-radius: 10px;
            background: rgba(255,255,255,0.05);
            transition: all 0.3s;
        }

        .player-info.active {
            background: var(--accent);
            color: #000;
            transform: scale(1.05);
        }

        .player-info .stone {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .stone.black { background: #111; }
        .stone.white { background: #f5f5f5; border: 1px solid #999; }

        .board-wrapper {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            background: var(--board);
            border-radius: 12px;
            padding: 3%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            width: 100%;
            height: 100%;
        }

        .cell {
            position: relative;
            cursor: pointer;
        }

        /* Grid lines */
        .cell::before, .cell::after {
            content: '';
            position: absolute;
            background: var(--board-line);
        }

        /* Horizontal line */
        .cell::before {
            left: 0; right: 0;
            top: 50%; height: 1px;
        }
        .cell[data-col="0"]::before { left: 50%; }
        .cell[data-col="14"]::before { right: 50%; }

        /* Vertical line */
        .cell::after {
            top: 0; bottom: 0;
            left: 50%; width: 1px;
        }
        .cell[data-row="0"]::after { top: 50%; }
        .cell[data-row="14"]::after { bottom: 50%; }

        /* Star points - separate element, not ::before */
        .star-dot {
            position: absolute;
            width: 8px; height: 8px;
            background: var(--board-line);
            border-radius: 50%;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            pointer-events: none;
        }

        .cell .placed-stone {
            position: absolute;
            width: 85%; height: 85%;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: place 0.2s ease-out;
        }

        @keyframes place {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }

        .placed-stone.black {
            background: radial-gradient(circle at 30% 30%, #444, #111);
        }

        .placed-stone.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
            border: 1px solid #bbb;
        }

        .placed-stone.last {
            box-shadow: 0 0 0 3px var(--danger);
        }

        .placed-stone.win {
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            to { transform: translate(-50%, -50%) scale(1.1); }
        }

        .game-status {
            text-align: center;
            padding: 16px;
            font-size: 1.1rem;
            color: var(--text);
        }

        .game-actions {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            color: var(--text);
            transition: all 0.2s;
        }

        .btn:hover { background: rgba(255,255,255,0.2); }
        .btn.primary { background: var(--accent); color: #000; }
    </style>
</head>
<body>
    <div id="app"></div>

    <script src="/lib/multiplayer.js?v=20260210v2"></script>
    <script src="/lib/multiplayer-ui.js?v=20260210v2"></script>
    <script src="/lib/shared-wallet.js?v=20260211"></script>
    <script>
        // ===== 공용 재화 시스템 =====
        let sharedGold = 0;
        let cloudSyncEnabled = false;
        const WIN_REWARD = 1000;  // 승리 보상
        const LOSE_PENALTY = 100; // 패배 페널티
        
        // ===== Sound Effects =====
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        function getAudioCtx() {
            if (!audioCtx) audioCtx = new AudioCtx();
            return audioCtx;
        }
        function playSound(freq, duration = 0.1, type = 'sine') {
            try {
                const ctx = getAudioCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch(e) {}
        }
        function sfxPlace() { playSound(800, 0.06, 'triangle'); }
        function sfxWin() {
            [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playSound(f, 0.2, 'sine'), i * 120));
        }
        function sfxLose() { playSound(200, 0.4, 'sawtooth'); }
        
        async function loadSharedGold() {
            const localData = localStorage.getItem('enhance_game_v3');
            if (localData) {
                const parsed = JSON.parse(localData);
                sharedGold = parsed.gold || 0;
            }
            
            const token = localStorage.getItem('cocy_auth_token');
            if (!token) return;
            
            try {
                const parts = token.split('.');
                if (parts.length !== 3) return;
                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
                
                if (payload.sub) {
                    cloudSyncEnabled = true;
                    const res = await fetch('https://relay.cocy.io/api/user/data', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data.gold !== undefined) sharedGold = data.gold;
                    }
                }
            } catch (e) { console.log('Cloud sync failed:', e); }
        }
        
        async function saveSharedGold() {
            // SharedWallet 사용
            if (typeof SharedWallet !== 'undefined') {
                SharedWallet.setGold(sharedGold);
            } else {
                const localData = localStorage.getItem('enhance_game_v3');
                const parsed = localData ? JSON.parse(localData) : { gold: 0 };
                parsed.gold = sharedGold;
                localStorage.setItem('enhance_game_v3', JSON.stringify(parsed));
            }
        }
        
        // ===== Game State =====
        const BOARD_SIZE = 15;
        const STAR_POINTS = [[3,3],[3,7],[3,11],[7,3],[7,7],[7,11],[11,3],[11,7],[11,11]];
        
        let board = [];
        let currentPlayer = 'black';
        let gameOver = false;
        let myColor = null;
        let isMultiplayer = false;
        let mpUI = null;

        // ===== Initialize =====
        function init() {
            // 공용 재화 로드 (SharedWallet에서)
            if (typeof SharedWallet !== 'undefined') {
                SharedWallet.init().then(() => {
                    sharedGold = SharedWallet.gold;
                    cloudSyncEnabled = SharedWallet.cloudSyncEnabled;
                });
            } else {
                loadSharedGold();
            }
            
            mpUI = new MultiplayerUI({
                gameType: 'gomoku',
                gameName: '⚫⚪ 오목',
                container: document.getElementById('app'),
                maxPlayers: 2,
                onGameStart: handleGameStart,
                onGameEvent: handleGameEvent,
                onLeave: () => { isMultiplayer = false; }
            });

            // Check URL for room code
            const roomCode = MultiplayerUI.checkUrlRoom();
            if (roomCode) {
                mpUI._renderLobby();
                setTimeout(() => {
                    document.getElementById('mp-room-code').value = roomCode;
                }, 100);
            } else {
                mpUI.show();
            }
        }

        // ===== Game Start Handler =====
        function handleGameStart(state) {
            if (state.mode === 'local') {
                startLocalGame();
            } else {
                startMultiplayerGame(state);
            }
        }

        function startLocalGame() {
            isMultiplayer = false;
            myColor = null;
            initBoard();
            renderGame();
        }

        function startMultiplayerGame(state) {
            isMultiplayer = true;
            
            const gs = state.gameState;
            const myId = mpUI.getClient().getMyUserId();
            const me = gs.players.find(p => p.id === myId);
            
            myColor = me?.color;
            currentPlayer = gs.players.find(p => p.id === gs.currentPlayer)?.color || 'black';
            
            // Restore board from state
            board = gs.board.map(row => row.map(cell => {
                if (!cell) return null;
                const p = gs.players.find(pl => pl.id === cell);
                return p?.color || null;
            }));
            
            gameOver = !!gs.winner;
            
            renderGame(gs);
            
            // Setup realtime updates
            mpUI.getClient().onStateChange = (newState) => {
                if (newState.status === 'playing' || newState.status === 'finished') {
                    updateFromState(newState);
                }
            };
            
            showToast(`게임 시작! 당신은 ${myColor === 'black' ? '흑' : '백'}입니다`);
        }

        // ===== Board Logic =====
        function initBoard() {
            board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
            currentPlayer = 'black';
            gameOver = false;
        }

        function handleCellClick(row, col) {
            if (gameOver || board[row][col]) return;
            
            if (isMultiplayer) {
                if (myColor !== currentPlayer) {
                    showToast('상대 차례입니다');
                    return;
                }
                sendMove(row, col);
            } else {
                placeStone(row, col, currentPlayer);
                checkGameEnd(row, col);
                if (!gameOver) {
                    currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                }
                renderGame();
            }
        }

        function placeStone(row, col, color) {
            board[row][col] = color;
            sfxPlace();
        }

        async function sendMove(row, col) {
            try {
                await mpUI.sendAction({ type: 'place', payload: { row, col } });
                placeStone(row, col, myColor);
                renderGame({ lastMove: { row, col } });
            } catch (e) {
                showToast('실패: ' + e.message);
            }
        }

        function updateFromState(state) {
            const gs = state.gameState;
            
            board = gs.board.map(row => row.map(cell => {
                if (!cell) return null;
                const p = gs.players.find(pl => pl.id === cell);
                return p?.color || null;
            }));
            
            if (gs.currentPlayer) {
                const cp = gs.players.find(p => p.id === gs.currentPlayer);
                currentPlayer = cp?.color || 'black';
            }
            
            const wasGameOver = gameOver;
            gameOver = !!gs.winner;
            
            renderGame(gs);
            
            // 새로 게임이 끝났을 때만 결과 표시 (중복 방지)
            if (gameOver && !wasGameOver && gs.winner && gs.winner !== 'draw') {
                const winnerColor = gs.players.find(p => p.id === gs.winner)?.color;
                showResult(winnerColor);
            } else if (gameOver && !wasGameOver && gs.winner === 'draw') {
                showResult(null);
            }
        }

        function checkGameEnd(row, col) {
            const color = board[row][col];
            const directions = [[0,1],[1,0],[1,1],[1,-1]];
            
            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const r = row + dr*i, c = col + dc*i;
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === color) count++;
                    else break;
                }
                for (let i = 1; i < 5; i++) {
                    const r = row - dr*i, c = col - dc*i;
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === color) count++;
                    else break;
                }
                if (count >= 5) {
                    gameOver = true;
                    setTimeout(() => showResult(color), 300);
                    return;
                }
            }
        }

        function showResult(winner) {
            let goldChange = 0;
            let goldText = '';
            
            if (isMultiplayer) {
                const isWin = winner === myColor;
                if (isWin) sfxWin(); else sfxLose();
                goldChange = isWin ? WIN_REWARD : -LOSE_PENALTY;
                sharedGold = Math.max(0, sharedGold + goldChange);
                saveSharedGold();
                
                goldText = goldChange > 0 
                    ? `<span style="color:#4ecca3">+${goldChange}G</span>` 
                    : `<span style="color:#ff6b6b">${goldChange}G</span>`;
                
                mpUI.showResult({
                    title: isWin ? '🎉 승리!' : '😢 패배',
                    detail: `${(winner === 'black' ? '흑' : '백')} 승리 ${goldText}`,
                    isWin: isWin,
                    showRematch: true
                });
            } else {
                // 싱글플레이 (로컬 2인)는 보상 없음
                mpUI.showResult({
                    title: (winner === 'black' ? '⚫ 흑' : '⚪ 백') + ' 승리!',
                    isWin: null,
                    showRematch: false
                });
            }
        }

        // ===== Event Handler =====
        function handleGameEvent(type, data) {
            if (type === 'place' && isMultiplayer) {
                const myId = mpUI.getClient().getMyUserId();
                if (data.playerId !== myId) {
                    const { row, col, color } = data.payload || {};
                    if (row !== undefined) {
                        placeStone(row, col, color);
                        currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                        renderGame({ lastMove: { row, col } });
                    }
                }
            }
        }

        // ===== Rendering =====
        function renderGame(gs = {}) {
            const blackName = gs.players?.find(p => p.color === 'black')?.nickname || 'P1';
            const whiteName = gs.players?.find(p => p.color === 'white')?.nickname || 'P2';
            const myId = mpUI?.getClient()?.getMyUserId();
            
            document.getElementById('app').innerHTML = `
                <div class="game-screen">
                    <div class="game-header">
                        <div class="player-info ${currentPlayer === 'black' && !gameOver ? 'active' : ''}">
                            <div class="stone black"></div>
                            <span>${isMultiplayer ? blackName : '흑'}${gs.players?.find(p => p.color === 'black')?.id === myId ? ' (나)' : ''}</span>
                        </div>
                        <div class="player-info ${currentPlayer === 'white' && !gameOver ? 'active' : ''}">
                            <div class="stone white"></div>
                            <span>${isMultiplayer ? whiteName : '백'}${gs.players?.find(p => p.color === 'white')?.id === myId ? ' (나)' : ''}</span>
                        </div>
                    </div>
                    
                    <div class="board-wrapper">
                        <div class="board" id="board"></div>
                    </div>
                    
                    <div class="game-status">
                        ${gameOver ? '게임 종료' : 
                          (isMultiplayer ? 
                            (myColor === currentPlayer ? '내 차례' : '상대 차례') :
                            (currentPlayer === 'black' ? '흑' : '백') + '의 차례')}
                    </div>
                    
                    <div class="game-actions">
                        ${!isMultiplayer ? '<button class="btn" onclick="restartGame()">새 게임</button>' : ''}
                        <button class="btn" onclick="exitGame()">나가기</button>
                    </div>
                </div>
            `;
            
            renderBoard(gs.lastMove, gs.winLine);
        }

        function renderBoard(lastMove, winLine) {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    if (STAR_POINTS.some(([r,c]) => r === row && c === col) && !board[row][col]) {
                        const dot = document.createElement('div');
                        dot.className = 'star-dot';
                        cell.appendChild(dot);
                    }
                    
                    if (board[row][col]) {
                        const stone = document.createElement('div');
                        stone.className = `placed-stone ${board[row][col]}`;
                        
                        if (lastMove && lastMove.row === row && lastMove.col === col) {
                            stone.classList.add('last');
                        }
                        
                        if (winLine?.some(p => p.row === row && p.col === col)) {
                            stone.classList.add('win');
                        }
                        
                        cell.appendChild(stone);
                    }
                    
                    cell.onclick = () => handleCellClick(row, col);
                    boardEl.appendChild(cell);
                }
            }
        }

        function restartGame() {
            initBoard();
            renderGame();
        }

        function exitGame() {
            if (isMultiplayer && mpUI.getClient()) {
                if (confirm('게임을 나가시겠습니까?')) {
                    mpUI.getClient().leaveRoom().catch(() => {});
                    MultiplayerClient.resetInstance();
                    isMultiplayer = false;
                    mpUI.show();
                }
            } else {
                mpUI.show();
            }
        }

        function showToast(msg) {
            const existing = document.querySelector('.mp-toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = 'mp-toast';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // Start
        init();
    </script>
</body>
</html>
