<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Line Rush</title>
  <script src="/lib/shared-wallet.js?v=20260214"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #080612;
      overflow: hidden;
      font-family: 'Trebuchet MS', sans-serif;
      min-height: 100dvh;
    }
    #game-wrap {
      position: fixed;
      top: calc(48px + env(safe-area-inset-top));
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    canvas { display: block; touch-action: none; max-width: 100%; }

    #joyWrap {
      position: fixed;
      bottom: 28px;
      right: 20px;
      width: 120px;
      height: 120px;
      z-index: 50;
      display: none;
      touch-action: none;
    }
    #joyBase {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.07);
      border: 2px solid rgba(255, 255, 255, 0.18);
    }
    #joyKnob {
      position: absolute;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: rgba(0, 210, 255, 0.50);
      border: 2px solid rgba(0, 230, 255, 0.85);
      top: 34px;
      left: 34px;
      will-change: transform;
      pointer-events: none;
    }

    #scene-ui {
      position: fixed;
      inset: 0;
      z-index: 120;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      padding: calc(52px + env(safe-area-inset-top)) 16px 20px;
    }
    .ui-panel {
      width: min(360px, calc(100vw - 24px));
      max-height: min(84vh, 720px);
      overflow: auto;
      background: rgba(10, 12, 26, 0.88);
      border: 1px solid rgba(130, 175, 255, 0.52);
      border-radius: 14px;
      color: #e9f0ff;
      padding: 18px 16px;
      pointer-events: auto;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.45);
    }
    .ui-title {
      text-align: center;
      font-size: 30px;
      color: #ff89cb;
      margin-bottom: 8px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }
    .ui-sub {
      text-align: center;
      color: #9dc9ff;
      font-size: 13px;
      margin-bottom: 12px;
    }
    .ui-btn {
      width: 100%;
      border: none;
      border-radius: 9px;
      padding: 12px 10px;
      font-size: 16px;
      font-weight: 700;
      margin-top: 8px;
      cursor: pointer;
    }
    .ui-btn:active { transform: translateY(1px); }
    .ui-btn.primary { background: #6f2fd1; color: #fff; }
    .ui-btn.next { background: #1d4f83; color: #fff; }
    .ui-btn.warn { background: #ffd700; color: #222; }
    .ui-btn.danger { background: #a52e4d; color: #fff; }
    .ui-row { display: flex; gap: 8px; }
    .rank-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 2px;
      font-size: 13px;
      border-bottom: 1px solid rgba(120, 140, 190, 0.12);
    }
    .score-line { text-align: center; margin-top: 8px; font-size: 17px; }
  </style>
</head>
<body>
<div id="game-wrap"></div>
<div id="joyWrap"><div id="joyBase"></div><div id="joyKnob"></div></div>
<div id="scene-ui"></div>
<script type="text/plain" id="legacy-phaser-script">
window.addEventListener('error', (e) => {
  const msg = document.createElement('div');
  msg.style.cssText = 'position:fixed;left:12px;right:12px;top:12px;z-index:99999;background:#300;color:#fff;padding:10px 12px;border-radius:8px;font:12px/1.4 sans-serif';
  msg.textContent = 'Line Rush ë¡œë”© ì˜¤ë¥˜: ' + (e.message || 'unknown');
  document.body.appendChild(msg);
});
const STAGE_COUNT        = 15;
const BG_ORIG_START      = 1;   // bg1-10: stage 4-10 random backgrounds
const BG_ORIG_END        = 10;
// stage 1â†’char1, 2â†’char2, 3â†’char4 (luminarqmix-v7 portrait crops)
const STAGE_CHAR_MAP     = { 1: 'char1', 2: 'char2', 3: 'char4' };
const STAGE_REWARD       = 1000;  // ìŠ¤í…Œì´ì§€ë‹¹ ê³¨ë“œ ë³´ìƒ (stage Ã— STAGE_REWARD)
const RELAY_URL          = 'https://relay.cocy.io';
const STORAGE_BEST_KEY   = 'linerush_best_stage';
const STORAGE_PLAYER_KEY = 'linerush_player_id';
// (legacy) unlock key - kept for migration
const STORAGE_UNLOCK_KEY = 'linerush_unlocked_stage';
// Main boss per stage (Galspanic-style colorful round enemies)
const MAIN_MONSTERS = [
  { name:'ìŠ¬ë¼ì„',   color:0x44ff44, ring:0x00cc00, radius:9,  spdMul:1.4, img:'boss1' },
  { name:'ìŠ¤í•€',     color:0xffaa22, ring:0xff6600, radius:10, spdMul:1.5, img:'boss2' },
  { name:'ì´‰ìˆ˜',     color:0xcc44ff, ring:0x8800cc, radius:10, spdMul:1.48,img:'boss3' },
  { name:'ì•„ì´ë³¼',   color:0xff2244, ring:0xcc0022, radius:11, spdMul:1.55,img:'boss4' },
  { name:'ì•„ì´ìŠ¤',   color:0x88ddff, ring:0x0088cc, radius:11, spdMul:1.52,img:'boss5' },
  { name:'í”Œë ˆì„',   color:0xff6600, ring:0xff2200, radius:12, spdMul:1.6, img:'boss6' },
  { name:'ì¬ë”',     color:0xffff22, ring:0xcc9900, radius:12, spdMul:1.58,img:'boss7' },
  { name:'ë‹¤í¬',     color:0xaa44ff, ring:0x660099, radius:13, spdMul:1.65,img:'boss8' },
  { name:'ì¹´ì˜¤ìŠ¤',   color:0xff44aa, ring:0xcc0077, radius:13, spdMul:1.7, img:'boss9' },
  { name:'ë³´ì´ë“œ',   color:0xff0000, ring:0x880000, radius:14, spdMul:1.75,img:'boss10'},
  // Stages 11-15: harder variants of stages 1-5 (reuse boss1-5 images)
  { name:'ìŠ¬ë¼ì„EX', color:0x44ff44, ring:0x00cc00, radius:11, spdMul:1.95,img:'boss1' },
  { name:'ìŠ¤í•€EX',   color:0xffaa22, ring:0xff6600, radius:12, spdMul:2.0, img:'boss2' },
  { name:'ì´‰ìˆ˜EX',   color:0xcc44ff, ring:0x8800cc, radius:12, spdMul:1.98,img:'boss3' },
  { name:'ì•„ì´ë³¼EX', color:0xff2244, ring:0xcc0022, radius:13, spdMul:2.05,img:'boss4' },
  { name:'ì•„ì´ìŠ¤EX', color:0x88ddff, ring:0x0088cc, radius:13, spdMul:2.1, img:'boss5' },
];

const ITEM_TYPES = ['freeze','speed','shield','slow'];
const ITEM_EMOJI = { freeze:'âœ‹',speed:'ğŸƒ',shield:'ğŸ›¡',slow:'âŒ›' };
const ITEM_DUR   = { freeze:5000, speed:4000, shield:7000, slow:6000 };
const ITEM_LIFE  = 14000;
const ITEM_BLINK = 5000;
const ITEM_SPAWN = 20000;
const MAX_ITEMS  = 3;

function getLRPlayerId() {
  let id = localStorage.getItem(STORAGE_PLAYER_KEY);
  if (!id) { id = 'lr_' + Math.random().toString(36).slice(2, 11); localStorage.setItem(STORAGE_PLAYER_KEY, id); }
  return id;
}
function getLRBestStage() { return parseInt(localStorage.getItem(STORAGE_BEST_KEY) || '0'); }
function setLRBestStage(s) {
  if (s > getLRBestStage()) {
    localStorage.setItem(STORAGE_BEST_KEY, String(s));
    // ë¹„ë™ê¸°ë¡œ ì„œë²„ì— ê¸°ë¡
    const nickname = window.SharedWallet?.user?.nickname || window.SharedWallet?.user?.username || null;
    fetch(`${RELAY_URL}/api/rankings/linerush`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: getLRPlayerId(), nickname, stage: s })
    }).catch(() => {});
  }
}
const COLS = 52;
const ROWS = 76;
const CELL = 8;
const W = COLS * CELL;
const H = ROWS * CELL;
const TARGET_PERCENT = 80;

function getUnlockedStage() {
  try {
    const v = Number(localStorage.getItem(STORAGE_UNLOCK_KEY) || '1');
    return Math.min(STAGE_COUNT, Math.max(1, Number.isFinite(v) ? v : 1));
  } catch (_) {
    return 1;
  }
}

function setUnlockedStage(stage) {
  try {
    const next = Math.min(STAGE_COUNT, Math.max(getUnlockedStage(), stage));
    localStorage.setItem(STORAGE_UNLOCK_KEY, String(next));
  } catch (_) {}
}

class BootScene extends Phaser.Scene {
  constructor() { super('Boot'); }

  preload() {
    // Stage 1-3 character backgrounds (luminarqmix-v7 portrait)
    ['char1', 'char2', 'char4'].forEach(k =>
      this.load.image(k, `/linerush/img/${k}.jpg`)
    );
    // Stage backgrounds (bg1-15)
    for (let i = 1; i <= STAGE_COUNT; i++) {
      this.load.image(`bg${i}`, `/linerush/img/bg${i}.jpg`);
    }
    // Stage 11-15 character images
    for (let i = 11; i <= STAGE_COUNT; i++) {
      this.load.image(`char${i}`, `/linerush/img/char${i}.jpg`);
    }
    for (let i = 1; i <= STAGE_COUNT; i++) {
      this.load.image(`boss${i}`, `/linerush/img/boss${i}.png`);
    }
  }

  create() {
    const white = this.make.graphics({ x: 0, y: 0, add: false });
    white.fillStyle(0xffffff, 1);
    white.fillRect(0, 0, 2, 2);
    white.generateTexture('pixel', 2, 2);
    white.destroy();

    const palettes = [
      [0xff6b9d, 0xffa8c4],
      [0x7e57c2, 0x5dade2],
      [0xf39c12, 0xffd700],
      [0x2ecc71, 0x27ae60],
      [0x00c2ff, 0x3f5efb],
      [0xff4d6d, 0xff9e00],
      [0x8e44ad, 0xe056fd],
      [0x16a085, 0x48dbfb],
      [0xe67e22, 0xf1c40f],
      [0x34495e, 0x6c5ce7]
    ];

    for (let s = 1; s <= STAGE_COUNT; s++) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      const [c1, c2] = palettes[(s - 1) % palettes.length];
      g.fillGradientStyle(c1, c1, c2, c2, 1);
      g.fillRect(0, 0, W, H);

      g.fillStyle(0x000000, 0.24);
      g.fillCircle(W * 0.5, H * 0.24, 38);
      g.fillRoundedRect(W * 0.5 - 42, H * 0.32, 84, 140, 32);
      g.fillEllipse(W * 0.44, H * 0.77, 42, 84);
      g.fillEllipse(W * 0.56, H * 0.77, 42, 84);

      g.fillStyle(0xffffff, 0.08);
      g.fillCircle(W * 0.66, H * 0.21, 54);
      g.fillCircle(W * 0.31, H * 0.68, 72);

      g.generateTexture(`stage${s}_placeholder`, W, H);
      g.destroy();
    }

    this.scene.start('Menu');
  }
}

class MenuScene extends Phaser.Scene {
  constructor() { super('Menu'); }

  create() {
    // ë°°ê²½
    const bg = this.add.graphics();
    bg.fillGradientStyle(0x120320, 0x120320, 0x220833, 0x220833, 1);
    bg.fillRect(0, 0, W, H);

    // íƒ€ì´í‹€
    this.add.text(W / 2, 60, 'LINE RUSH', {
      fontFamily: 'Verdana', fontSize: '40px',
      color: '#ff79c6', stroke: '#ff2ea6', strokeThickness: 8
    }).setOrigin(0.5).setShadow(0, 0, '#ff2ea6', 24, true, true);

    this.add.text(W / 2, 104, 'ì˜ì—­ì„ ì ë ¹í•˜ê³  80% ëŒíŒŒ!', {
      fontFamily: 'Verdana', fontSize: '13px', color: '#aacfff'
    }).setOrigin(0.5);

    // ë‚´ ê¸°ë¡
    const best = getLRBestStage();
    const bestTxt = best > 0
      ? `ğŸ† ë‚´ ìµœê³ : STAGE ${best} | ìµœëŒ€ë³´ìƒ: ${(best * STAGE_REWARD).toLocaleString()}G`
      : 'ê¸°ë¡ ì—†ìŒ';
    this.add.text(W / 2, 140, bestTxt, {
      fontFamily: 'Verdana', fontSize: '13px', color: '#ffd700'
    }).setOrigin(0.5);

    // PLAY ë²„íŠ¼
    const playBtn = this.add.rectangle(W / 2, 210, 220, 58, 0x7020d0, 0.92)
      .setStrokeStyle(2, 0xff79c6, 1).setInteractive({ useHandCursor: true });
    this.add.text(W / 2, 210, 'â–¶  STAGE 1 START', {
      fontFamily: 'Verdana', fontSize: '18px', color: '#ffffff', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5);
    playBtn.on('pointerover', () => playBtn.setFillStyle(0x9030e8, 0.95));
    playBtn.on('pointerout', () => playBtn.setFillStyle(0x7020d0, 0.92));
    playBtn.on('pointerdown', () => this.scene.start('Game', { stage: 1, score: 0, lives: 3 }));

    // ë³´ìƒ ì•ˆë‚´
    this.add.text(W / 2, 254, `ê° ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì‹œ stageÃ—${STAGE_REWARD.toLocaleString()}G ë³´ìƒ!`, {
      fontFamily: 'Verdana', fontSize: '11px', color: '#80d0ff'
    }).setOrigin(0.5);

    // ë­í‚¹ ì˜ì—­ â€” rankBg ë¨¼ì € ê·¸ë ¤ì•¼ íƒ€ì´í‹€ì´ ìœ„ì— ë Œë”ë¨
    const rankBg = this.add.rectangle(W / 2, 415, W - 20, 240, 0x050514, 0.7)
      .setStrokeStyle(1, 0x334466, 0.8);

    const rankTitle = this.add.text(W / 2, 284, 'ğŸ† ìµœê³  ìŠ¤í…Œì´ì§€ ë­í‚¹', {
      fontFamily: 'Verdana', fontSize: '14px', color: '#ffd700'
    }).setOrigin(0.5);

    const loadingTxt = this.add.text(W / 2, 415, 'ë­í‚¹ ë¡œë”© ì¤‘...', {
      fontFamily: 'Verdana', fontSize: '13px', color: '#6677aa'
    }).setOrigin(0.5);

    // ë¹„ë™ê¸° ë­í‚¹ fetch
    fetch(`${RELAY_URL}/api/rankings/linerush?limit=10`)
      .then(r => r.json())
      .then(data => {
        loadingTxt.destroy();
        const rows = data.rankings || [];
        if (rows.length === 0) {
          this.add.text(W / 2, 415, 'ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤\në¨¼ì € í”Œë ˆì´í•´ë³´ì„¸ìš”!', {
            fontFamily: 'Verdana', fontSize: '13px', color: '#6677aa', align: 'center'
          }).setOrigin(0.5);
          return;
        }
        rows.slice(0, 9).forEach((r, i) => {
          const y = 300 + i * 26;
          const medal = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][i] || `${i+1}.`;
          const nick = (r.nickname || 'ìµëª…').slice(0, 10);
          const color = i === 0 ? '#ffd700' : i === 1 ? '#e0e0e0' : i === 2 ? '#cc8844' : '#99b4cc';
          this.add.text(16, y, `${medal} ${nick}`, {
            fontFamily: 'Verdana', fontSize: '13px', color, stroke: '#000', strokeThickness: 2
          });
          this.add.text(W - 16, y, `STAGE ${r.best_stage}`, {
            fontFamily: 'Verdana', fontSize: '13px', color: '#5ddcff', stroke: '#000', strokeThickness: 2
          }).setOrigin(1, 0);
        });
      })
      .catch(() => {
        loadingTxt.setText('ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      });

    this.add.text(W / 2, H - 18, 'game.cocy.io', {
      fontFamily: 'Verdana', fontSize: '11px', color: '#445566'
    }).setOrigin(0.5);
  }
}

class GameScene extends Phaser.Scene {
  constructor() {
    super('Game');
  }

  create(data) {
    this.stage = data.stage || 1;
    this.score = data.score || 0;
    this.lives = (typeof data.lives === 'number') ? data.lives : 3;
    this.claimedCells = 0;
    this.total = (COLS - 2) * (ROWS - 2);
    this.percent = 0;

    this.grid = [];
    for (let r = 0; r < ROWS; r++) {
      this.grid[r] = [];
      for (let c = 0; c < COLS; c++) {
        this.grid[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
      }
    }

    // Bg selection: stages 1-3 â†’ char portraits, stages 4+ â†’ random from bg1-10 (cycles for 11-15)
    let bgKey;
    if (STAGE_CHAR_MAP[this.stage]) {
      bgKey = STAGE_CHAR_MAP[this.stage];
    } else if (this.stage >= 11) {
      // Stages 11-15: use dedicated bg images
      bgKey = `bg${this.stage}`;
    } else {
      const effectiveStage = this.stage;
      if (!window._lrBgMap || this.stage === 4) {
        const origPool = Array.from({ length: BG_ORIG_END - BG_ORIG_START + 1 }, (_, i) => i + BG_ORIG_START);
        for (let i = origPool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [origPool[i], origPool[j]] = [origPool[j], origPool[i]];
        }
        window._lrBgMap = origPool; // 10 shuffled picks for stages 4-10
      }
      const mapIdx = Math.min(effectiveStage - 4, window._lrBgMap.length - 1);
      bgKey = `bg${window._lrBgMap[Math.max(0, mapIdx)]}`;
    }
    this.bgKey = bgKey;
    const key = this.textures.exists(bgKey) ? bgKey : `bg1`;
    this.bgImage = this.add.image(W / 2, H / 2, key).setDepth(0).setDisplaySize(W, H);


    this.overlayGfx = this.add.graphics().setDepth(1);
    this.claimedGfx = this.add.graphics().setDepth(2);
    this.trailGfx = this.add.graphics().setDepth(3).setBlendMode(Phaser.BlendModes.ADD);
    this.actorGfx = this.add.graphics().setDepth(4);
    this.itemGfx  = this.add.graphics().setDepth(5);

    this.playerRow = 0;
    this.playerCol = Math.floor(COLS / 2);
    this.trail = [];
    this.isDrawing = false;
    this.drawStart = null;
    this.retracting = false;
    this.moveTimer = 0;
    this.moveDelay = 60;
    this.retractSpeedMul = 1.5;
    this.invuln = 0;

    this.fx = { freeze: 0, speed: 0, slow: 0, shield: 0 };
    this.items = [];
    this.itemSpawnTimer = ITEM_SPAWN * 0.5; // first item at 10s

    const enemyCount = Math.min(5, this.stage);   // max 5 enemies (was 8)
    this.enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      const baseSpeed = CELL * (1.2 + this.stage * 0.38 + i * 0.04); // slower base speed
      const kind = (i % 3 === 0) ? 'hunter' : (i % 3 === 1 ? 'zigzag' : 'bouncer');
      this.enemies.push({
        x: Phaser.Math.FloatBetween(CELL * 2, W - CELL * 2),
        y: Phaser.Math.FloatBetween(CELL * 2, H - CELL * 2),
        vx: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        vy: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        baseSpeed,
        kind,
        radius: kind === 'hunter' ? 5 : 4.5,
        pulse: Math.random() * Math.PI * 2,
        shootCd: Phaser.Math.Between(2000, 4000) // delayed first shot
      });
    }

    this.enemyBullets = [];
    this.bossAttackTimer = 30000;
    this.bossCharging = false;

    // ìŠ¤í…Œì´ì§€ë³„ ë©”ì¸ ë³´ìŠ¤ ëª¬ìŠ¤í„°
    const mmDef = MAIN_MONSTERS[Math.min(this.stage - 1, MAIN_MONSTERS.length - 1)];
    const mmSpeed = CELL * (1.2 + this.stage * 0.38) * mmDef.spdMul; // balanced with enemy speed
    this.mainMonster = {
      x: Phaser.Math.FloatBetween(CELL * 5, W - CELL * 5),
      y: Phaser.Math.FloatBetween(CELL * 5, H - CELL * 5),
      vx: (Math.random() > 0.5 ? 1 : -1) * mmSpeed,
      vy: (Math.random() > 0.5 ? 1 : -1) * mmSpeed,
      baseSpeed: mmSpeed, kind: 'boss', pulse: 0, shootCd: 600,
      radius: mmDef.radius, color: mmDef.color, ring: mmDef.ring,
      name: mmDef.name, img: mmDef.img,
    };
    const bossKey = mmDef.img;
    this.mainMonsterSprite = this.textures.exists(bossKey)
      ? this.add.image(this.mainMonster.x, this.mainMonster.y, bossKey)
          .setDisplaySize(mmDef.radius * 2.4, mmDef.radius * 2.4).setDepth(7)
      : null;
    this.mainMonsterLabel = this.add.text(
      this.mainMonster.x, this.mainMonster.y - mmDef.radius - 8,
      `â˜… ${mmDef.name}`, { fontSize: '11px', color: '#ffdd44', stroke: '#000', strokeThickness: 2 }
    ).setOrigin(0.5, 1).setDepth(8);

    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.touchAxis = { x: 0, y: 0 };
    this.createTouchControls();

    this.createHUD();
    this.updateClaimStats();
    this.redrawOverlay();
    this.drawGrid();
  }

  createTouchControls() {
    const isTouch = this.sys.game.device.input.touch;
    if (!isTouch) return;

    const joyCenter = { x: W - 72, y: H - 80 };
    const joyRadius = 42;
    const knobRadius = 18;

    this.joyBase = this.add.circle(joyCenter.x, joyCenter.y, joyRadius, 0x001a2e, 0.42)
      .setStrokeStyle(2, 0x63d9ff, 0.9).setDepth(20).setScrollFactor(0);
    this.joyKnob = this.add.circle(joyCenter.x, joyCenter.y, knobRadius, 0x39c6ff, 0.75)
      .setStrokeStyle(2, 0xb8f1ff, 0.95).setDepth(21).setScrollFactor(0);

    const joyZone = this.add.zone(joyCenter.x, joyCenter.y, joyRadius * 2.3, joyRadius * 2.3)
      .setOrigin(0.5).setDepth(22).setScrollFactor(0).setInteractive();

    let joyPointerId = null;

    const resetStick = () => {
      this.touchAxis.x = 0;
      this.touchAxis.y = 0;
      this.joyKnob.setPosition(joyCenter.x, joyCenter.y);
      joyPointerId = null;
    };

    const updateStick = (pointer) => {
      const dx = pointer.x - joyCenter.x;
      const dy = pointer.y - joyCenter.y;
      const dist = Math.hypot(dx, dy) || 1;
      const clamped = Math.min(joyRadius, dist);
      const nx = dx / dist;
      const ny = dy / dist;
      this.joyKnob.setPosition(joyCenter.x + nx * clamped, joyCenter.y + ny * clamped);
      this.touchAxis.x = nx * (clamped / joyRadius);
      this.touchAxis.y = ny * (clamped / joyRadius);
    };

    joyZone.on('pointerdown', (p) => {
      joyPointerId = p.id;
      updateStick(p);
    });

    this.input.on('pointermove', (p) => {
      if (joyPointerId === null || p.id !== joyPointerId || !p.isDown) return;
      updateStick(p);
    });

    this.input.on('pointerup', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });

    joyZone.on('pointerout', (p) => {
      // keep moving even if finger leaves circle; release on pointerup only
      if (joyPointerId === null || p.id !== joyPointerId) return;
    });
    joyZone.on('pointerupoutside', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });
  }

  createHUD() {
    this.hudBg = this.add.rectangle(W / 2, 16, W, 32, 0x000000, 0.45).setDepth(10);
    this.hudLives = this.add.text(12, 8, '', {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffffff'
    }).setDepth(11);
    this.hudStage = this.add.text(W / 2 - 68, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#7de5ff'
    }).setDepth(11);
    this.hudPercent = this.add.text(W / 2 + 14, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#fff176'
    }).setDepth(11);
    this.hudScore = this.add.text(W - 12, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#ffb4d8'
    }).setOrigin(1, 0).setDepth(11);
    this.hudFx = this.add.text(W / 2, H - 18, '', {
      fontSize: '18px'
    }).setOrigin(0.5, 1).setDepth(11);

    this.refreshHUD();
  }

  refreshHUD() {
    this.hudLives.setText('â¤ï¸'.repeat(Math.max(0, this.lives)));
    this.hudStage.setText(`STAGE ${this.stage}`);
    this.hudPercent.setText(`${this.percent}%`);
    this.hudScore.setText(`SCORE: ${this.score}`);
    if (this.hudFx) {
      const active = [];
      if (this.fx?.freeze > 0) active.push('âœ‹');
      if (this.fx?.speed  > 0) active.push('ğŸƒ');
      if (this.fx?.slow   > 0) active.push('âŒ›');
      if (this.fx?.shield > 0) active.push('ğŸ›¡');
      this.hudFx.setText(active.join(' '));
    }
  }

  update(time, delta) {
    this.moveTimer += delta;

    const baseDelay = this.fx.speed > 0 ? this.moveDelay / 5 : this.moveDelay;
    const stepDelay = this.retracting ? baseDelay / this.retractSpeedMul : baseDelay;
    if (this.moveTimer >= stepDelay) {
      if (this.retracting) {
        this.stepRetreat();
      } else {
        this.handleInput();
        this.checkItemPickup();
      }
      this.moveTimer = 0;
    }

    if (this.invuln > 0) this.invuln -= delta;

    // fx timers
    if (this.fx.freeze > 0) this.fx.freeze -= delta;
    if (this.fx.speed  > 0) this.fx.speed  -= delta;
    if (this.fx.slow   > 0) this.fx.slow   -= delta;
    if (this.fx.shield > 0) this.fx.shield -= delta;

    // item spawn + lifetime
    this.itemSpawnTimer -= delta;
    if (this.itemSpawnTimer <= 0 && this.items.length < MAX_ITEMS) {
      this.spawnItem();
      this.itemSpawnTimer = ITEM_SPAWN;
    }
    for (let i = this.items.length - 1; i >= 0; i--) {
      const it = this.items[i];
      it.timeLeft -= delta;
      if (it.timeLeft <= 0) { it.label.destroy(); this.items.splice(i, 1); continue; }
      if (it.timeLeft <= ITEM_BLINK) {
        it.label.setAlpha(Math.floor(this.time.now / 250) % 2 === 0 ? 1 : 0.15);
      }
    }

    // Boss mega-attack timer
    if (this.mainMonster && !this.bossCharging) {
      this.bossAttackTimer -= delta;
      if (this.bossAttackTimer <= 0) {
        this.triggerBossMegaAttack();
        this.bossAttackTimer = 30000;
      }
    }

    this.updateEnemies(delta);
    this.updateBullets(delta);
    if (this.invuln <= 0) {
      this.checkCollisions();
    }
    this.refreshHUD();
    this.drawGrid();
  }

  handleInput() {
    let dr = 0;
    let dc = 0;

    const axisX = this.touchAxis?.x || 0;
    const axisY = this.touchAxis?.y || 0;

    if (this.cursors.left.isDown || this.wasd.A.isDown) dc = -1;
    else if (this.cursors.right.isDown || this.wasd.D.isDown) dc = 1;
    else if (this.cursors.up.isDown || this.wasd.W.isDown) dr = -1;
    else if (this.cursors.down.isDown || this.wasd.S.isDown) dr = 1;
    else {
      if (Math.abs(axisX) > Math.abs(axisY) && Math.abs(axisX) > 0.25) dc = axisX < 0 ? -1 : 1;
      else if (Math.abs(axisY) > 0.25) dr = axisY < 0 ? -1 : 1;
    }

    if (dr === 0 && dc === 0) {
      // No input while drawing â†’ retract trail at 1.5x speed
      if (this.isDrawing && !this.retracting && this.trail.length > 0) {
        this.retracting = true;
      }
      return;
    }
    // Directional input: cancel retraction
    this.retracting = false;

    const nr = this.playerRow + dr;
    const nc = this.playerCol + dc;

    if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;

    const next = this.grid[nr][nc];
    if (next === 2) {
      // ìê¸° íŠ¸ë ˆì¼ì— ë§‰í˜ â€” ì£½ì§€ ì•Šê³  ì´ë™ë§Œ ë¬´ì‹œ
      return;
    }

    if (next === 0) {
      if (!this.isDrawing) {
        this.isDrawing = true;
        this.drawStart = { row: this.playerRow, col: this.playerCol };
        this.trail = [];
      }

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }

      this.playerRow = nr;
      this.playerCol = nc;

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }
      return;
    }

    if (next === 1) {
      // Allow movement to any claimed cell (frontier restriction removed â€” caused corner bug)
      this.playerRow = nr;
      this.playerCol = nc;
      if (this.isDrawing) {
        // íŠ¸ë ˆì¼ì´ ë„ˆë¬´ ì§§ìœ¼ë©´ (â‰¤2ì¹¸) ìº¡ì²˜ ëŒ€ì‹  ê°•ì œ ì·¨ì†Œ (ì™¸ê³½ì„  ì‹¤ìˆ˜ ë°©ì§€)
        if (this.trail.length <= 2) {
          for (const cell of this.trail) {
            if (this.grid[cell.row][cell.col] === 2) this.grid[cell.row][cell.col] = 0;
          }
          this.trail = [];
          this.isDrawing = false;
          this.retracting = false;
          this.drawStart = null;
          this.redrawOverlay();
        } else {
          this.captureTerritory();
        }
      }
    }
  }

  isFrontier(r, c) {
    if (this.grid[r][c] !== 1) return false;
    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    for (const [dr, dc] of dirs) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && this.grid[nr][nc] === 0) return true;
    }
    return false;
  }

  stepRetreat() {
    if (!this.trail.length) {
      this.retracting = false;
      this.isDrawing = false;
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.drawStart = null;
      return;
    }

    const removed = this.trail.pop();
    if (this.grid[removed.row][removed.col] === 2) {
      this.grid[removed.row][removed.col] = 0;
    }

    if (this.trail.length) {
      const back = this.trail[this.trail.length - 1];
      this.playerRow = back.row;
      this.playerCol = back.col;
    } else {
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.retracting = false;
      this.isDrawing = false;
      this.drawStart = null;
    }

    this.redrawOverlay();
  }

  captureTerritory() {
    for (const cell of this.trail) {
      this.grid[cell.row][cell.col] = 1;
    }

    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    const regions = [];
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0 || visited[r][c]) continue;
        const queue = [{ r, c }];
        visited[r][c] = true;
        const cells = [];
        while (queue.length) {
          const cur = queue.shift();
          cells.push(cur);
          for (const [dr2, dc2] of [[1,0],[-1,0],[0,1],[0,-1]]) {
            const nr2 = cur.r + dr2, nc2 = cur.c + dc2;
            if (nr2 < 1 || nr2 >= ROWS-1 || nc2 < 1 || nc2 >= COLS-1) continue;
            if (visited[nr2][nc2] || this.grid[nr2][nc2] !== 0) continue;
            visited[nr2][nc2] = true;
            queue.push({ r: nr2, c: nc2 });
          }
        }
        regions.push({ cells });
      }
    }

    // dead-end (íŠ¸ë ˆì¼ì´ ì˜ì—­ì„ ë‚˜ëˆ„ì§€ ëª»í•¨) â†’
    // ì˜ˆì „ì—” ì·¨ì†Œí–ˆì§€ë§Œ, ê¸¸ê³  ì–‡ì€ ê²½ë¡œë„ ìœ íš¨í•˜ë¯€ë¡œ íŠ¸ë ˆì¼ì„ ì˜í† ë¡œ ìœ ì§€
    if (regions.length <= 1) {
      // íŠ¸ë ˆì¼ ì…€ì€ ì´ë¯¸ grid=1 ì²˜ë¦¬ë¨ â†’ ê·¸ëŒ€ë¡œ ë‘ê³  ë§ˆë¬´ë¦¬
      this.isDrawing = false; this.retracting = false;
      this.drawStart = null; this.trail = [];
      this.updateClaimStats(); this.redrawOverlay(); return;
    }

    // ê°€ì¥ í° region ì œì™¸, ë‚˜ë¨¸ì§€ ì „ë¶€ ìº¡ì²˜
    regions.sort((a, b) => a.cells.length - b.cells.length);
    const claimRegions = regions.slice(0, regions.length - 1);

    // ë©”ì¸ ëª¬ìŠ¤í„° í¬íš ì²´í¬
    const mm = this.mainMonster;
    let mainCaptured = false;
    let bossRegion = null;
    if (mm) {
      const mmR = Phaser.Math.Clamp(Math.floor(mm.y / CELL), 0, ROWS-1);
      const mmC = Phaser.Math.Clamp(Math.floor(mm.x / CELL), 0, COLS-1);
      bossRegion = claimRegions.find(reg => reg.cells.some(c => c.r === mmR && c.c === mmC)) || null;
      mainCaptured = bossRegion !== null;
    }

    // ì¼ë°˜ ëª¬ìŠ¤í„° í¬íš â†’ ì†Œë©¸
    const toKill = [];
    for (const e of this.enemies) {
      const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS-1);
      const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS-1);
      if (claimRegions.some(reg => reg.cells.some(c => c.r === er && c.c === ec))) toKill.push(e);
    }
    toKill.forEach(e => {
      const b2 = this.add.particles(e.x, e.y, 'pixel', {
        speed:{min:50,max:180}, lifespan:380, quantity:18,
        scale:{start:1.3,end:0}, tint:[0xff7848,0xffd4a6,0xffff66], blendMode:'ADD'
      }).setDepth(9);
      this.time.delayedCall(420, () => b2.destroy());
    });
    this.enemies = this.enemies.filter(e => !toKill.includes(e));
    if (toKill.length > 0) this.score += toKill.length * 500 * this.stage;

    let gained = 0;
    for (const region of claimRegions) {
      for (const cell of region.cells) {
        if (this.grid[cell.r][cell.c] === 0) { this.grid[cell.r][cell.c] = 1; gained++; }
      }
    }

    // Auto-collect items inside captured territory
    for (let i = this.items.length - 1; i >= 0; i--) {
      const it = this.items[i];
      if (this.grid[it.row][it.col] === 1) {
        this.collectItem(it.type);
        it.label.destroy();
        this.items.splice(i, 1);
      }
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];

    if (gained > 0) {
      this.score += gained * 50 * this.stage;
      this.cameras.main.flash(300, 255, 255, 200);
      this.captureBurst();
      // 10% ì´ìƒ í•œë²ˆì— íšë“ â†’ ì‰´ë“œ ë°œë™
      if (gained >= Math.ceil(this.total * 0.10)) {
        this.activateShieldArc();
        this.showItemMsg('10%â†‘ ë°©ì–´ë§‰ ë°œë™!', 0x44ff88);
      }
    }

    // ë©”ì¸ ëª¬ìŠ¤í„° í¬íš â†’ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´!
    if (mainCaptured && mm) {
      // ë³´ìŠ¤ í¬íš ì‹œ í¼ì„¼íŠ¸ = 100% - ë³´ìŠ¤ë¥¼ ì¡ì€ ì˜ì—­ í¬ê¸°
      const bossRegionCells = bossRegion ? bossRegion.cells.length : 0;
      const bossRegionPct = Math.floor(bossRegionCells / this.total * 100);
      const finalPercent = Math.max(0, 100 - bossRegionPct);

      const b3 = this.add.particles(mm.x, mm.y, 'pixel', {
        speed:{min:80,max:280}, lifespan:550, quantity:40,
        scale:{start:2,end:0}, tint:[mm.color, 0xffffff, 0xffd700], blendMode:'ADD'
      }).setDepth(12);
      this.time.delayedCall(600, () => b3.destroy());
      if (this.mainMonsterSprite) this.mainMonsterSprite.destroy();
      if (this.mainMonsterLabel) this.mainMonsterLabel.destroy();
      this.mainMonster = null; this.mainMonsterSprite = null; this.mainMonsterLabel = null;
      this.score += 3000 * this.stage;
      const t2 = this.add.text(W/2, H/2-30, `â˜… ${mm.name} í¬íš!\n+${(3000*this.stage).toLocaleString()}ì `, {
        fontSize:'20px', color:'#ffd700', stroke:'#000', strokeThickness:4, align:'center'
      }).setOrigin(0.5).setDepth(20);
      this.cameras.main.flash(600, 255, 200, 0);
      this.time.delayedCall(1200, () => {
        t2.destroy();
        this.updateClaimStats();
        this.percent = finalPercent; // ë³´ìŠ¤ íŠ¸ë© ì˜ì—­ ì œì™¸ í¼ì„¼íŠ¸
        this.explodeEnemiesAndClear();
      });
      this.updateClaimStats(); this.redrawOverlay(); return;
    }

    this.updateClaimStats();
    this.redrawOverlay();

    if (this.percent >= TARGET_PERCENT) {
      this.explodeEnemiesAndClear();
    }
  }

  explodeEnemiesAndClear() {
    // 80% í´ë¦¬ì–´ ì‹œ ë©”ì¸ ëª¬ìŠ¤í„°ë„ ì œê±°
    if (this.mainMonster) {
      const mm = this.mainMonster;
      const bm = this.add.particles(mm.x, mm.y, 'pixel', {
        speed:{min:80,max:260}, lifespan:500, quantity:35,
        scale:{start:1.8,end:0}, tint:[mm.color,0xffffff,0xffd700], blendMode:'ADD'
      }).setDepth(12);
      this.time.delayedCall(550, () => bm.destroy());
      if (this.mainMonsterSprite) { this.mainMonsterSprite.destroy(); this.mainMonsterSprite = null; }
      if (this.mainMonsterLabel) { this.mainMonsterLabel.destroy(); this.mainMonsterLabel = null; }
      this.mainMonster = null;
    }
    if (!this.enemies.length) {
      this.time.delayedCall(380, () => {
        this.scene.start('Clear', {
          stage: this.stage,
          score: this.score,
          lives: this.lives,
          percent: this.percent,
          bgKey: this.bgKey
        });
      });
      return;
    }

    const enemyCount = this.enemies.length;
    this.enemies.forEach((e, idx) => {
      this.time.delayedCall(idx * 85, () => {
        const burst = this.add.particles(e.x, e.y, 'pixel', {
          speed: { min: 70, max: 240 },
          lifespan: 420,
          quantity: 26,
          scale: { start: 1.4, end: 0 },
          tint: [0xffd36e, 0xff7f6e, 0xffffff],
          blendMode: 'ADD'
        }).setDepth(9);
        this.time.delayedCall(430, () => burst.destroy());
      });
    });
    this.enemies = [];
    this.enemyBullets = [];

    this.time.delayedCall(enemyCount * 85 + 460, () => {
      this.scene.start('Clear', {
        stage: this.stage,
        score: this.score,
        lives: this.lives,
        percent: this.percent,
        bgKey: this.bgKey
      });
    });
  }

  updateClaimStats() {
    let claimed = 0;
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] === 1) claimed++;
      }
    }
    this.claimedCells = claimed;
    this.percent = Math.floor((claimed / this.total) * 100);
    this.refreshHUD();
  }

  redrawOverlay() {
    this.overlayGfx.clear();

    // 1) dark mask for unrevealed area (very hidden before capture)
    this.overlayGfx.fillStyle(0x02030a, 0.965);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 0 || this.grid[r][c] === 2) {
          this.overlayGfx.fillRect(c * CELL, r * CELL, CELL, CELL);
        }
      }
    }

    // 2) silhouette-like contour glow on unrevealed area boundary
    this.overlayGfx.lineStyle(1.2, 0xbec6ff, 0.22);
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0) continue;
        const nearClaimed = this.grid[r-1][c] === 1 || this.grid[r+1][c] === 1 || this.grid[r][c-1] === 1 || this.grid[r][c+1] === 1;
        if (nearClaimed) {
          this.overlayGfx.strokeRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        }
      }
    }
  }

  updateEnemies(delta) {
    if (this.fx.freeze > 0) return; // frozen
    const slowMul = this.fx.slow > 0 ? 0.5 : 1;
    const dt = (delta / 1000) * slowMul;
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    // ë©”ì¸ ëª¬ìŠ¤í„° ì—…ë°ì´íŠ¸ â€” ëŸ¬ì‰¬ ì¤‘ì¼ ë•Œë§Œ ì¶”ì , ì•„ë‹ ë• ëœë¤ ë°”ìš´ìŠ¤
    if (this.mainMonster) {
      const mm = this.mainMonster;
      mm.pulse += dt * 5;
      const dx = px - mm.x, dy = py - mm.y;
      const d = Math.hypot(dx, dy) || 1;
      if (this.isDrawing) {
        // ëŸ¬ì‰¬ ì¤‘: ì ê·¹ì ìœ¼ë¡œ í”Œë ˆì´ì–´ ì¶”ì 
        mm.vx = mm.vx * 0.82 + (dx / d) * mm.baseSpeed * 0.24;
        mm.vy = mm.vy * 0.82 + (dy / d) * mm.baseSpeed * 0.24;
      }
      // ëŸ¬ì‰¬ ì•ˆ í•  ë•Œ: ì†ë„ ìœ ì§€í•˜ë©° ë²½/ê²½ê³„ë§Œ ë°˜ì‚¬ (ì¶”ì  ì—†ìŒ)
      let nx = mm.x + mm.vx * dt, ny = mm.y + mm.vy * dt;
      if (nx < CELL || nx > W - CELL) { mm.vx *= -1; nx = Phaser.Math.Clamp(nx, CELL, W - CELL); }
      if (ny < CELL || ny > H - CELL) { mm.vy *= -1; ny = Phaser.Math.Clamp(ny, CELL, H - CELL); }
      // ì ë ¹ì§€ ê²½ê³„ ë°˜ì‚¬
      const gr = r => Phaser.Math.Clamp(Math.floor(r / CELL), 0, ROWS - 1);
      if (this.grid[gr(ny)][gr(nx + Math.sign(mm.vx) * mm.radius)] === 1) { mm.vx *= -1; }
      if (this.grid[gr(ny + Math.sign(mm.vy) * mm.radius)][gr(nx)] === 1) { mm.vy *= -1; }
      mm.x += mm.vx * dt; mm.y += mm.vy * dt;
      mm.shootCd -= delta;
      if (mm.shootCd <= 0) {
        const speed = CELL * (3.2 + this.stage * 0.28); // slower bullets
        this.enemyBullets.push({ x: mm.x, y: mm.y,
          vx: (dx / d) * speed, vy: (dy / d) * speed, r: 4, life: 99999 });
        mm.shootCd = Math.max(800, 2000 - this.stage * 80) + Phaser.Math.Between(-150, 150); // much longer interval
      }
      // ìŠ¤í”„ë¼ì´íŠ¸ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      if (this.mainMonsterSprite) {
        this.mainMonsterSprite.setPosition(mm.x, mm.y);
      }
      if (this.mainMonsterLabel) {
        this.mainMonsterLabel.setPosition(mm.x, mm.y - mm.radius - 8);
      }
    }

    for (const e of this.enemies) {
      e.pulse += dt * 6;

      // behavior patterns
      if (e.kind === 'hunter' && this.isDrawing) {
        const dx = px - e.x;
        const dy = py - e.y;
        const d = Math.hypot(dx, dy) || 1;
        const aim = e.baseSpeed * 1.06;
        e.vx = (e.vx * 0.9) + (dx / d) * aim * 0.1;
        e.vy = (e.vy * 0.9) + (dy / d) * aim * 0.1;
      } else if (e.kind === 'zigzag') {
        const w = Math.sin(this.time.now * 0.006 + e.pulse) * 0.22;
        const vx = e.vx;
        e.vx = vx * Math.cos(w) - e.vy * Math.sin(w);
        e.vy = vx * Math.sin(w) + e.vy * Math.cos(w);
      }

      let nx = e.x + e.vx * dt;
      let ny = e.y + e.vy * dt;

      if (nx < CELL || nx > W - CELL) {
        e.vx *= -1;
        nx = Phaser.Math.Clamp(nx, CELL, W - CELL);
      }
      if (ny < CELL || ny > H - CELL) {
        e.vy *= -1;
        ny = Phaser.Math.Clamp(ny, CELL, H - CELL);
      }

      const testCell = (x, y) => {
        const rr = Phaser.Math.Clamp(Math.floor(y / CELL), 0, ROWS - 1);
        const cc = Phaser.Math.Clamp(Math.floor(x / CELL), 0, COLS - 1);
        return this.grid[rr][cc];
      };

      const hitX = testCell(nx + Math.sign(e.vx || 1) * e.radius, e.y) === 1;
      const hitY = testCell(e.x, ny + Math.sign(e.vy || 1) * e.radius) === 1;

      if (hitX) e.vx *= -1;
      if (hitY) e.vy *= -1;

      e.x += e.vx * dt;
      e.y += e.vy * dt;

      // stage-scaled shooting â€” ëŸ¬ì‰¬ ì¤‘ì—ë§Œ ë°œì‚¬ or í° ì¸í„°ë²Œ
      e.shootCd -= delta;
      if (e.shootCd <= 0) {
        // Hunter: ëŸ¬ì‰¬ ì¤‘ì—ë§Œ ë°œì‚¬; zigzag/bouncer: ê¸´ ê°„ê²©ìœ¼ë¡œë§Œ ë°œì‚¬
        const intervalBase = e.kind === 'hunter'
          ? Math.max(1200, 3600 - this.stage * 180)
          : Math.max(2000, 5000 - this.stage * 200);
        if (e.kind !== 'hunter' || this.isDrawing) {
          const bulletSpeed = CELL * (2.6 + this.stage * 0.20); // slower bullets
          this.fireEnemyBullet(e, bulletSpeed);
        }
        e.shootCd = intervalBase + Phaser.Math.Between(-300, 300);
      }
    }
  }

  fireEnemyBullet(enemy, speed) {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const dx = px - enemy.x;
    const dy = py - enemy.y;
    const d = Math.hypot(dx, dy) || 1;
    this.enemyBullets.push({
      x: enemy.x,
      y: enemy.y,
      vx: (dx / d) * speed,
      vy: (dy / d) * speed,
      r: Math.min(3.5, 1.8 + this.stage * 0.1),
      life: 99999
    });
  }

  updateBullets(delta) {
    if (this.fx.freeze > 0) return; // frozen
    const slowMul = this.fx.slow > 0 ? 0.5 : 1;
    const dt = (delta / 1000) * slowMul;
    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= delta;

      if (b.life <= 0 || b.x < -12 || b.x > W + 12 || b.y < -12 || b.y > H + 12) {
        this.enemyBullets.splice(i, 1);
        continue;
      }

      // Mega bullet: check if it hit owned territory
      if (b.isMega) {
        const br = Phaser.Math.Clamp(Math.floor(b.y / CELL), 0, ROWS - 1);
        const bc = Phaser.Math.Clamp(Math.floor(b.x / CELL), 0, COLS - 1);
        if (this.grid[br][bc] === 1) {
          this.megaBulletImpact(b.x, b.y);
          this.enemyBullets.splice(i, 1);
        }
      }
    }
  }

  checkCollisions() {
    // Shield: full invincibility while active
    if (this.fx.shield > 0) return;

    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    // ë©”ì¸ ëª¬ìŠ¤í„° ì¶©ëŒ
    if (this.mainMonster) {
      const mm = this.mainMonster;
      const dist = Phaser.Math.Distance.Between(px, py, mm.x, mm.y);
      if (dist < mm.radius + 5 && this.isDrawing) {
        this.playerDie(); return;
      }
    }

    for (const e of this.enemies) {
      const dist = Phaser.Math.Distance.Between(px, py, e.x, e.y);
      if (dist < e.radius + 5) {
        if (this.isDrawing) {
          this.playerDie();
          return;
        }
        // Shield: safe when not rushing
        continue;
      }

      if (this.isDrawing) {
        const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
        const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
        for (let rr = er - 1; rr <= er + 1; rr++) {
          for (let cc = ec - 1; cc <= ec + 1; cc++) {
            if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
            if (this.grid[rr][cc] === 2) {
              this.playerDie();
              return;
            }
          }
        }
      }
    }

    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      const dist = Phaser.Math.Distance.Between(px, py, b.x, b.y);
      if (dist < b.r + 6) {
        this.enemyBullets.splice(i, 1);
        if (this.isDrawing) {
          this.playerDie();
          return;
        }
        // Shield: bullet absorbed, no death
        continue;
      }
      if (this.isDrawing) {
        const br = Phaser.Math.Clamp(Math.floor(b.y / CELL), 0, ROWS - 1);
        const bc = Phaser.Math.Clamp(Math.floor(b.x / CELL), 0, COLS - 1);
        if (this.grid[br][bc] === 2) {
          this.enemyBullets.splice(i, 1);
          this.playerDie();
          return;
        }
      }
    }
  }

  findNearestClaimed(row, col) {
    let best = { row: 0, col: 0, d: Infinity };
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] !== 1) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (d < best.d) best = { row: r, col: c, d };
      }
    }
    return { row: best.row, col: best.col };
  }

  findNearestFrontier(row, col) {
    // Find nearest frontier cell (claimed + adjacent to unclaimed)
    let best = null;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!this.isFrontier(r, c)) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (!best || d < best.d) best = { row: r, col: c, d };
      }
    }
    // Fallback to any claimed cell if no frontier found
    return best || this.findNearestClaimed(row, col);
  }

  playerDie() {
    if (this.invuln > 0) return;

    this.lives--;
    this.cameras.main.shake(500, 0.02);
    this.cameras.main.flash(300, 255, 0, 0);

    for (const cell of this.trail) {
      if (this.grid[cell.row][cell.col] === 2) this.grid[cell.row][cell.col] = 0;
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];
    this.enemyBullets = [];
    this.redrawOverlay();

    // ì£½ì„ ë•Œ ëœë¤ ì•„ì´í…œ 2ê°œ ë“œë¡­
    this.spawnItem(); this.spawnItem();

    if (this.lives <= 0) {
      const gold = window.SharedWallet?.gold || 0;
      if (gold >= 100) {
        this.showContinuePrompt();
      } else {
        this.scene.start('GameOver', { score: this.score, stage: this.stage });
      }
      return;
    }

    const respawn = this.findNearestFrontier(this.playerRow, this.playerCol);
    this.playerRow = respawn.row;
    this.playerCol = respawn.col;
    this.invuln = 900;
    this.refreshHUD();
  }

  spawnItem(forcedType = null) {
    const free = [];
    for (let r = 2; r < ROWS - 2; r++)
      for (let c = 2; c < COLS - 2; c++)
        if (this.grid[r][c] === 0) free.push({ r, c });
    if (!free.length) return;
    const cell = free[Phaser.Math.Between(0, free.length - 1)];
    const type = forcedType || ITEM_TYPES[Phaser.Math.Between(0, ITEM_TYPES.length - 1)];
    const cx = cell.c * CELL + CELL / 2;
    const cy = cell.r * CELL + CELL / 2;
    const label = this.add.text(cx, cy, ITEM_EMOJI[type], {
      fontSize: '16px', stroke: '#000', strokeThickness: 2
    }).setOrigin(0.5).setDepth(6);
    this.items.push({ type, row: cell.r, col: cell.c, timeLeft: ITEM_LIFE, label });
  }

  checkItemPickup() {
    for (let i = this.items.length - 1; i >= 0; i--) {
      const it = this.items[i];
      if (it.row === this.playerRow && it.col === this.playerCol) {
        this.collectItem(it.type);
        it.label.destroy();
        this.items.splice(i, 1);
      }
    }
  }

  collectItem(type) {
    const dur = ITEM_DUR[type];
    const colors = { freeze: '#88ddff', speed: '#ffff88', shield: '#88ff88', slow: '#ffbb88' };
    const msgs   = { freeze: 'âœ‹ ëª¬ìŠ¤í„° ì •ì§€!', speed: 'ğŸƒ 5ë°° ìŠ¤í”¼ë“œ!', shield: 'ğŸ›¡ ë°©ì–´ë§‰!', slow: 'âŒ› ê°ì†!' };
    this.showItemMsg(msgs[type], colors[type]);
    if (type === 'shield') {
      this.activateShieldArc();
      this.fx.shield = dur;
    } else {
      this.fx[type] = Math.max(this.fx[type], dur);
    }
  }

  showItemMsg(msg, color) {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const t = this.add.text(px, py - 18, msg, {
      fontSize: '13px', color, stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setDepth(15);
    this.tweens.add({ targets: t, y: py - 56, alpha: 0, duration: 1600,
      onComplete: () => t.destroy() });
  }

  activateShieldArc() {
    this.enemyBullets = [];
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const g = this.add.graphics().setDepth(12);
    let step = 0;
    const ev = this.time.addEvent({ delay: 18, repeat: 35, callback: () => {
      g.clear();
      const r = 14 + step * 6;
      g.lineStyle(3, 0x44ff88, Math.max(0, 0.9 - step * 0.025));
      g.strokeCircle(px, py, r);
      g.lineStyle(1.5, 0xaaffcc, Math.max(0, 0.5 - step * 0.012));
      g.strokeCircle(px, py, r + 5);
      if (step % 5 === 0) this.enemyBullets = [];
      step++;
    }});
    this.time.delayedCall(700, () => { g.destroy(); ev.remove(); });
    this.invuln = Math.max(this.invuln, 2000);
  }

  triggerBossMegaAttack() {
    if (!this.mainMonster || this.bossCharging) return;
    // Find random owned territory cells
    const owned = [];
    for (let r = 2; r < ROWS - 2; r++)
      for (let c = 2; c < COLS - 2; c++)
        if (this.grid[r][c] === 1) owned.push({ r, c });
    if (owned.length < 10) { return; } // not enough territory to bomb
    const target = owned[Phaser.Math.Between(0, owned.length - 1)];
    const tx = target.c * CELL + CELL / 2;
    const ty = target.r * CELL + CELL / 2;
    const mm = this.mainMonster;
    this.bossCharging = true;
    mm.charging = true;

    // Warning flash on target area
    const warnGfx = this.add.graphics().setDepth(13);
    let warnPhase = 0;
    const warnEv = this.time.addEvent({ delay: 120, repeat: 12, callback: () => {
      warnGfx.clear();
      if (warnPhase % 2 === 0) {
        warnGfx.fillStyle(0xff4400, 0.35);
        warnGfx.fillCircle(tx, ty, CELL * 7);
        warnGfx.lineStyle(3, 0xff8800, 0.9);
        warnGfx.strokeCircle(tx, ty, CELL * 7);
      }
      warnPhase++;
    }});

    // Show warning text
    const warnTxt = this.add.text(W / 2, H / 2 - 60, 'âš ï¸ ë³´ìŠ¤ í­ê²© ì¤€ë¹„!', {
      fontSize: '18px', color: '#ff4400', stroke: '#000', strokeThickness: 4
    }).setOrigin(0.5).setDepth(16);

    this.time.delayedCall(1500, () => {
      warnGfx.destroy(); warnEv.remove(); warnTxt.destroy();
      if (!this.mainMonster) { this.bossCharging = false; return; }
      mm.charging = false;
      const dx = tx - mm.x, dy = ty - mm.y;
      const d = Math.hypot(dx, dy) || 1;
      const speed = CELL * 2.8;
      this.enemyBullets.push({
        x: mm.x, y: mm.y,
        vx: (dx / d) * speed, vy: (dy / d) * speed,
        r: 22, life: 7000, isMega: true
      });
      this.bossCharging = false;
    });
  }

  megaBulletImpact(x, y) {
    const radius = 7; // cells
    const impactR = Math.floor(y / CELL);
    const impactC = Math.floor(x / CELL);
    for (let r = impactR - radius; r <= impactR + radius; r++) {
      for (let c = impactC - radius; c <= impactC + radius; c++) {
        if (r < 1 || r >= ROWS - 1 || c < 1 || c >= COLS - 1) continue;
        const dr = r - impactR, dc = c - impactC;
        if (Math.hypot(dr, dc) <= radius && this.grid[r][c] === 1) {
          this.grid[r][c] = 0;
        }
      }
    }
    // Visual explosion
    const burst = this.add.particles(x, y, 'pixel', {
      speed: { min: 80, max: 360 }, lifespan: 700, quantity: 60,
      scale: { start: 2.8, end: 0 },
      tint: [0xff4400, 0xff8800, 0xffdd00, 0xff0000, 0xffffff], blendMode: 'ADD'
    }).setDepth(13);
    this.time.delayedCall(750, () => { if (burst.active) burst.destroy(); });
    // Secondary ring
    const ring = this.add.graphics().setDepth(13);
    let ringFrame = 0;
    const ringEv = this.time.addEvent({ delay: 30, repeat: 10, callback: () => {
      ring.clear();
      ring.lineStyle(4, 0xff6600, Math.max(0, 0.9 - ringFrame * 0.09));
      ring.strokeCircle(x, y, CELL * 7 * (ringFrame / 10 + 0.1));
      ringFrame++;
    }});
    this.time.delayedCall(350, () => { ring.destroy(); ringEv.remove(); });
    this.cameras.main.shake(700, 0.03);
    this.cameras.main.flash(400, 255, 60, 0);
    this.updateClaimStats();
    this.redrawOverlay();
    this.showItemMsg('ğŸ’¥ ì˜ì—­ í­ê²©!', '#ff4400');
  }

  showContinuePrompt() {
    const gold = window.SharedWallet?.gold || 0;
    const overlay = this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.78).setDepth(20);
    const box = this.add.rectangle(W / 2, H / 2, W * 0.84, 200, 0x0a0a1a, 0.96)
      .setStrokeStyle(2, 0xffd700).setDepth(21);
    this.add.text(W / 2, H / 2 - 72, 'ğŸ’€ ê²Œì„ ì˜¤ë²„', {
      fontSize: '22px', color: '#ff6666', fontStyle: 'bold', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setDepth(22);
    this.add.text(W / 2, H / 2 - 28, `100Gë¡œ ì´ì–´ê°€ì‹œê² ìŠµë‹ˆê¹Œ?\ní˜„ì¬ ë³´ìœ : ${gold.toLocaleString()}G`, {
      fontSize: '13px', color: '#ffffff', align: 'center'
    }).setOrigin(0.5).setDepth(22);
    const contBtn = this.add.text(W / 2 - 54, H / 2 + 42, 'ê³„ì† (100G)', {
      fontSize: '14px', color: '#000', backgroundColor: '#ffd700',
      padding: { x: 10, y: 8 }
    }).setOrigin(0.5).setInteractive({ useHandCursor: true }).setDepth(22);
    const quitBtn = this.add.text(W / 2 + 60, H / 2 + 42, 'í¬ê¸°', {
      fontSize: '14px', color: '#fff', backgroundColor: '#cc3333',
      padding: { x: 18, y: 8 }
    }).setOrigin(0.5).setInteractive({ useHandCursor: true }).setDepth(22);
    contBtn.on('pointerdown', () => {
      if (window.SharedWallet) SharedWallet.spendGold(100);
      overlay.destroy(); box.destroy();
      [contBtn, quitBtn].forEach(b => b.destroy());
      this.children.list.filter(c => c.depth === 22).forEach(c => c.destroy());
      this.lives = 1;
      this.fx = { freeze: 0, speed: 0, slow: 0, shield: 0 };
      const respawn = this.findNearestFrontier(this.playerRow, this.playerCol);
      this.playerRow = respawn.row; this.playerCol = respawn.col;
      this.invuln = 2500;
      this.refreshHUD();
    });
    quitBtn.on('pointerdown', () => {
      this.scene.start('GameOver', { score: this.score, stage: this.stage });
    });
  }

  captureBurst() {
    if (!this.trail.length) return;
    let sr = 0;
    let sc = 0;
    for (const t of this.trail) {
      sr += t.row;
      sc += t.col;
    }
    const cx = (sc / this.trail.length) * CELL + CELL / 2;
    const cy = (sr / this.trail.length) * CELL + CELL / 2;

    const p = this.add.particles(cx, cy, 'pixel', {
      speed: { min: 40, max: 180 },
      lifespan: 380,
      quantity: 24,
      scale: { start: 1.5, end: 0 },
      tint: [0x9cfbff, 0xfff799, 0xff9fd6],
      blendMode: 'ADD'
    }).setDepth(9);

    this.time.delayedCall(420, () => p.destroy());
  }

  drawGrid() {
    this.claimedGfx.clear();
    this.trailGfx.clear();
    this.actorGfx.clear();

    this.claimedGfx.lineStyle(1, 0x3e9eff, 0.65);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 1 && (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1)) {
          this.claimedGfx.strokeRect(c * CELL + 0.5, r * CELL + 0.5, CELL - 1, CELL - 1);
        }
      }
    }

    // visually smoothed trail (curve-like feel over grid movement)
    this.trailGfx.lineStyle(2.5, 0x00ffff, 0.92);
    this.trailGfx.fillStyle(0x8affff, 0.38);
    let prev = null;
    for (const t of this.trail) {
      const cx = t.col * CELL + CELL / 2;
      const cy = t.row * CELL + CELL / 2;
      this.trailGfx.fillCircle(cx, cy, 3);
      if (prev) {
        this.trailGfx.beginPath();
        this.trailGfx.moveTo(prev.x, prev.y);
        this.trailGfx.lineTo(cx, cy);
        this.trailGfx.strokePath();
      }
      prev = { x: cx, y: cy };
    }

    for (const e of this.enemies) {
      const glow = 10 + Math.sin(e.pulse) * 3;
      this.actorGfx.fillStyle(0xff4f32, 0.18);
      this.actorGfx.fillCircle(e.x, e.y, glow);
      this.actorGfx.fillStyle(0xff7848, 0.85);
      this.actorGfx.fillCircle(e.x, e.y, e.radius);
      this.actorGfx.fillStyle(0xffd4a6, 0.65);
      this.actorGfx.fillCircle(e.x - 1.5, e.y - 1.5, 2);
      if (e.kind === 'hunter') {
        this.actorGfx.lineStyle(1.6, 0xffd7d7, 0.9);
        this.actorGfx.strokeCircle(e.x, e.y, e.radius + 2.5);
      } else if (e.kind === 'zigzag') {
        this.actorGfx.lineStyle(1.2, 0xffe4a8, 0.85);
        this.actorGfx.strokeTriangle(e.x, e.y - (e.radius + 2), e.x - (e.radius + 2), e.y + (e.radius + 2), e.x + (e.radius + 2), e.y + (e.radius + 2));
      } else {
        this.actorGfx.lineStyle(1.2, 0xffc9a2, 0.85);
        this.actorGfx.strokeRect(e.x - (e.radius + 2), e.y - (e.radius + 2), (e.radius + 2) * 2, (e.radius + 2) * 2);
      }
    }

    // ë©”ì¸ ëª¬ìŠ¤í„° ë Œë”ë§ (ì´ë¯¸ì§€ ì—†ìœ¼ë©´ ì ˆì°¨ì  ê·¸ë¦¬ê¸°)
    if (this.mainMonster) {
      const mm = this.mainMonster;
      const pulse = 0.6 + 0.3 * Math.sin(mm.pulse);
      const glowR = mm.radius + 6 + 3 * Math.sin(mm.pulse * 1.3);
      this.actorGfx.lineStyle(2.5, mm.ring, 0.9);
      this.actorGfx.strokeCircle(mm.x, mm.y, glowR);
      this.actorGfx.lineStyle(1.2, 0xffffff, 0.4);
      this.actorGfx.strokeCircle(mm.x, mm.y, glowR + 5);
      if (!this.mainMonsterSprite) {
        // ì´ë¯¸ì§€ ì—†ìœ¼ë©´ ì»¬ëŸ¬ ì›
        this.actorGfx.fillStyle(mm.color, 0.2);
        this.actorGfx.fillCircle(mm.x, mm.y, mm.radius + 4);
        this.actorGfx.fillStyle(mm.color, 0.9);
        this.actorGfx.fillCircle(mm.x, mm.y, mm.radius);
        this.actorGfx.fillStyle(0xffffff, 0.7 * pulse);
        this.actorGfx.fillCircle(mm.x - mm.radius*0.3, mm.y - mm.radius*0.3, mm.radius * 0.32);
      }
    }

    // enemy bullets
    for (const b of this.enemyBullets) {
      if (b.isMega) {
        // Mega bullet: pulsing large red-orange orb
        const pulse = 0.7 + 0.3 * Math.sin(this.time.now * 0.01);
        this.actorGfx.fillStyle(0xff2200, 0.3 * pulse);
        this.actorGfx.fillCircle(b.x, b.y, b.r + 8);
        this.actorGfx.fillStyle(0xff6600, 0.9);
        this.actorGfx.fillCircle(b.x, b.y, b.r);
        this.actorGfx.fillStyle(0xffd700, 0.85);
        this.actorGfx.fillCircle(b.x, b.y, b.r * 0.5);
        this.actorGfx.lineStyle(3, 0xff4400, 0.9 * pulse);
        this.actorGfx.strokeCircle(b.x, b.y, b.r + 4);
      } else {
        this.actorGfx.fillStyle(0xfff47c, 0.95);
        this.actorGfx.fillCircle(b.x, b.y, b.r);
      }
    }

    // Charging boss flash
    if (this.mainMonster && this.mainMonster.charging) {
      const mm = this.mainMonster;
      const flashAlpha = 0.5 + 0.5 * Math.sin(this.time.now * 0.025);
      this.actorGfx.fillStyle(0xff4400, 0.55 * flashAlpha);
      this.actorGfx.fillCircle(mm.x, mm.y, mm.radius * 2.2);
      this.actorGfx.lineStyle(4, 0xff8800, flashAlpha);
      this.actorGfx.strokeCircle(mm.x, mm.y, mm.radius * 2.5);
    }

    // items glow
    this.itemGfx.clear();
    const glowColors = { freeze: 0x88ddff, speed: 0xffff88, shield: 0x88ff88, slow: 0xffbb88 };
    for (const it of this.items) {
      const cx = it.col * CELL + CELL / 2;
      const cy = it.row * CELL + CELL / 2;
      const pulse = 0.5 + 0.35 * Math.sin(this.time.now * 0.005 + it.col);
      const alpha = it.timeLeft <= ITEM_BLINK ? (Math.floor(this.time.now / 250) % 2 === 0 ? pulse : 0.1) : pulse;
      this.itemGfx.fillStyle(glowColors[it.type], alpha * 0.5);
      this.itemGfx.fillCircle(cx, cy, CELL * 0.72);
      this.itemGfx.lineStyle(1.5, glowColors[it.type], alpha * 0.8);
      this.itemGfx.strokeCircle(cx, cy, CELL * 0.72);
    }

    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const blink = this.invuln > 0 ? (Math.floor(this.time.now / 80) % 2 === 0 ? 0.45 : 1) : 1;

    // high-contrast player marker
    this.actorGfx.lineStyle(1.5, 0x000000, 0.9 * blink);
    this.actorGfx.strokeCircle(px, py, 6);
    this.actorGfx.fillStyle(0x00ffff, 0.35 * blink);
    this.actorGfx.fillCircle(px, py, 6);
    this.actorGfx.fillStyle(0xffffff, 1 * blink);
    this.actorGfx.fillCircle(px, py, 3.5);
    this.actorGfx.fillStyle(0x0a0f1a, 0.95 * blink);
    this.actorGfx.fillCircle(px, py, 1.5);

    // Shield ring: visible when safe (not rushing)
    if (!this.isDrawing && this.invuln <= 0) {
      const sp = Math.sin(this.time.now * 0.006);
      const shieldR = 9 + sp * 1.5;
      this.actorGfx.lineStyle(1.8, 0x44ffdd, (0.55 + sp * 0.2) * blink);
      this.actorGfx.strokeCircle(px, py, shieldR);
      this.actorGfx.lineStyle(0.8, 0x88ffee, (0.2 + sp * 0.1) * blink);
      this.actorGfx.strokeCircle(px, py, shieldR + 3);
    }
  }
}

class ClearScene extends Phaser.Scene {
  constructor() { super('Clear'); }

  create(data) {
    const { stage = 1, score = 0, lives = 3, percent = 0, bgKey = null } = data;
    setUnlockedStage(stage + 1);

    // ê³¨ë“œ ë³´ìƒ ì§€ê¸‰ + ìµœê³  ê¸°ë¡ ê°±ì‹ 
    const goldReward = stage * STAGE_REWARD;
    if (window.SharedWallet) SharedWallet.addGold(goldReward);
    setLRBestStage(stage);

    const clearBonus = 2000 * stage;
    const totalScore = score + clearBonus;

    // â”€â”€ Background: show the stage image in full glory â”€â”€
    if (bgKey && this.textures.exists(bgKey)) {
      this.add.image(W / 2, H / 2, bgKey).setDisplaySize(W, H).setDepth(0);
    } else {
      this.add.rectangle(W / 2, H / 2, W, H, 0x0a0f1a).setDepth(0);
    }
    // subtle dark overlay so text is readable but bg still visible
    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.48).setDepth(1);

    // â”€â”€ Camera flash â”€â”€
    this.cameras.main.flash(600, 255, 220, 80);

    // â”€â”€ STAGE CLEAR! title â”€â”€
    const titleTxt = this.add.text(W / 2, 110, 'STAGE CLEAR!', {
      fontFamily: 'Verdana',
      fontSize: '46px',
      color: '#ffd56b',
      stroke: '#7a3800',
      strokeThickness: 7
    }).setOrigin(0.5).setAlpha(0).setScale(0.4).setDepth(2);

    this.tweens.add({
      targets: titleTxt,
      alpha: 1,
      scale: 1,
      duration: 420,
      ease: 'Back.Out',
      delay: 150
    });

    // â”€â”€ Confetti burst â”€â”€
    this.time.delayedCall(180, () => {
      const conf = this.add.particles(W / 2, 80, 'pixel', {
        speed: { min: 60, max: 240 },
        angle: { min: 190, max: 350 },
        gravityY: 260,
        lifespan: 1400,
        quantity: 5,
        scale: { start: 1.8, end: 0.1 },
        tint: [0xffd56b, 0xff7aa2, 0x7ce8ff, 0xa8ff78],
        blendMode: 'ADD'
      }).setDepth(10);
      this.time.delayedCall(2200, () => { if (conf.active) conf.stop(); });
    });

    // â”€â”€ CAPTURE % â€” big bounce animation â”€â”€
    const pctTxt = this.add.text(W / 2, 230, `${percent}%`, {
      fontFamily: 'Verdana',
      fontSize: '82px',
      color: '#ffffff',
      stroke: '#003366',
      strokeThickness: 10
    }).setOrigin(0.5).setAlpha(0).setScale(2.4).setDepth(2);

    this.tweens.add({
      targets: pctTxt,
      alpha: 1,
      scale: 1,
      duration: 500,
      ease: 'Back.Out',
      delay: 520,
      onComplete: () => {
        // pulse: big â†’ normal Ã— 2
        this.tweens.add({
          targets: pctTxt,
          scale: { from: 1, to: 1.22 },
          duration: 200,
          ease: 'Quad.InOut',
          yoyo: true,
          repeat: 1,
          delay: 100
        });
      }
    });

    const capLabel = this.add.text(W / 2, 285, 'CAPTURED', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#c8e8ff',
      stroke: '#001a33',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);
    this.tweens.add({ targets: capLabel, alpha: 1, duration: 300, delay: 700 });

    // â”€â”€ Star rating â”€â”€
    const stars = percent >= 95 ? 3 : percent >= 90 ? 2 : 1;
    const starSpacing = 58;
    const starY = 360;
    const starObjs = [];

    for (let i = 0; i < 3; i++) {
      const sx = W / 2 + (i - 1) * starSpacing;
      const starTxt = this.add.text(sx, starY, 'â˜…', {
        fontFamily: 'Verdana',
        fontSize: '48px',
        color: i < stars ? '#ffd700' : '#444466',
        stroke: i < stars ? '#a06000' : '#222233',
        strokeThickness: 5
      }).setOrigin(0.5).setAlpha(0).setScale(0).setDepth(2);
      starObjs.push(starTxt);
    }

    for (let i = 0; i < stars; i++) {
      const delay = 1100 + i * 340;
      ((idx, d) => {
        this.time.delayedCall(d, () => {
          // pop in with overshoot
          this.tweens.add({
            targets: starObjs[idx],
            alpha: 1,
            scale: { from: 0, to: 1 },
            duration: 320,
            ease: 'Back.Out'
          });
          // burst particles at star position
          const sx = W / 2 + (idx - 1) * starSpacing;
          const burst = this.add.particles(sx, starY, 'pixel', {
            speed: { min: 50, max: 160 },
            lifespan: 500,
            quantity: 16,
            scale: { start: 1.4, end: 0 },
            tint: [0xffd700, 0xfff0a0, 0xffaa00],
            blendMode: 'ADD'
          }).setDepth(9);
          this.time.delayedCall(520, () => { if (burst.active) burst.destroy(); });
        });
      })(i, delay);
    }

    // unearned stars fade in dim
    for (let i = stars; i < 3; i++) {
      this.time.delayedCall(1100 + i * 340, () => {
        this.tweens.add({ targets: starObjs[i], alpha: 0.55, scale: 1, duration: 280, ease: 'Back.Out' });
      });
    }

    // â”€â”€ Score row â”€â”€
    const scoreTxt = this.add.text(W / 2, 435, `SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffb4d8',
      stroke: '#330011',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const bonusTxt = this.add.text(W / 2, 462, `CLEAR BONUS: +${clearBonus}`, {
      fontFamily: 'Verdana',
      fontSize: '17px',
      color: '#9cfbff',
      stroke: '#001133',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const totalTxt = this.add.text(W / 2, 491, `TOTAL: ${totalScore}`, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff',
      stroke: '#002244',
      strokeThickness: 5
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const goldTxt = this.add.text(W / 2, 516, `ğŸ’° +${goldReward.toLocaleString()} G íšë“!`, {
      fontFamily: 'Verdana',
      fontSize: '17px',
      color: '#ffd700',
      stroke: '#332200',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    this.tweens.add({ targets: [scoreTxt, bonusTxt, totalTxt, goldTxt], alpha: 1, duration: 360, delay: 2100 });

    // â”€â”€ Next button â”€â”€
    const nextLabel = (stage < STAGE_COUNT) ? 'NEXT STAGE â†’' : 'ğŸ  BACK TO MENU';
    const btn = this.add.rectangle(W / 2, 568, 210, 48, 0x123966, 0.92)
      .setStrokeStyle(2, 0x7ce8ff, 1)
      .setInteractive({ useHandCursor: true })
      .setAlpha(0).setDepth(2);
    const btnTxt = this.add.text(W / 2, 568, nextLabel, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff'
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    this.tweens.add({ targets: [btn, btnTxt], alpha: 1, duration: 360, delay: 2500 });

    btn.on('pointerover', () => btn.setFillStyle(0x1d588f, 0.95));
    btn.on('pointerout', () => btn.setFillStyle(0x123966, 0.92));
    btn.on('pointerdown', () => {
      if (stage < STAGE_COUNT) {
        this.scene.start('Game', { stage: stage + 1, score: totalScore, lives });
      } else {
        this.scene.start('Menu');
      }
    });
  }
}

class GameOverScene extends Phaser.Scene {
  constructor() { super('GameOver'); }

  create(data) {
    const score = data.score || 0;

    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.86);
    this.add.text(W / 2, 122, 'GAME OVER', {
      fontFamily: 'Verdana',
      fontSize: '56px',
      color: '#ff6666',
      stroke: '#5c0000',
      strokeThickness: 8
    }).setOrigin(0.5);

    this.add.text(W / 2, 190, `FINAL SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '22px',
      color: '#ffffff'
    }).setOrigin(0.5);

    const makeButton = (x, y, label, onClick) => {
      const b = this.add.rectangle(x, y, 150, 42, 0x2a1e48, 0.95)
        .setStrokeStyle(2, 0xff7ab6, 1)
        .setInteractive({ useHandCursor: true });
      this.add.text(x, y, label, {
        fontFamily: 'Verdana',
        fontSize: '20px',
        color: '#ffffff'
      }).setOrigin(0.5);
      b.on('pointerover', () => b.setFillStyle(0x3b2b66, 0.95));
      b.on('pointerout', () => b.setFillStyle(0x2a1e48, 0.95));
      b.on('pointerdown', onClick);
    };

    makeButton(W / 2 - 84, 266, 'RETRY', () => {
      this.scene.start('Game', { stage: data.stage || 1, score: 0, lives: 3 });
    });

    makeButton(W / 2 + 84, 266, 'MENU', () => {
      this.scene.start('Menu');
    });
  }
}

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  parent: 'game',
  backgroundColor: '#1a0a2e',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: [BootScene, MenuScene, GameScene, ClearScene, GameOverScene]
};

// SharedWallet ì´ˆê¸°í™” í›„ Phaser ì‹œì‘
(async function() {
  if (window.SharedWallet) {
    try { await SharedWallet.init(); } catch (_) {}
  }
  new Phaser.Game(config);
})();

</script>
<script src="https://unpkg.com/kaplay@4000.0.0-alpha.26/dist/kaplay.js"></script>
<script>
(() => {
  window.addEventListener('error', (e) => {
    const msg = document.createElement('div');
    msg.style.cssText = 'position:fixed;left:12px;right:12px;top:12px;z-index:99999;background:#300;color:#fff;padding:10px 12px;border-radius:8px;font:12px/1.4 sans-serif';
    msg.textContent = 'Line Rush ë¡œë”© ì˜¤ë¥˜: ' + (e.message || 'unknown');
    document.body.appendChild(msg);
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Constants / Storage / Network
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const STAGE_COUNT        = 15;
  const BG_ORIG_START      = 1;
  const BG_ORIG_END        = 10;
  const STAGE_CHAR_MAP     = { 1: 'char1', 2: 'char2', 3: 'char4' };
  const STAGE_REWARD       = 1000;
  const RELAY_URL          = 'https://relay.cocy.io';
  const STORAGE_BEST_KEY   = 'linerush_best_stage';
  const STORAGE_PLAYER_KEY = 'linerush_player_id';
  const STORAGE_UNLOCK_KEY = 'linerush_unlocked_stage';

  const MAIN_MONSTERS = [
    { name:'ìŠ¬ë¼ì„',   color:0x44ff44, ring:0x00cc00, radius:9,  spdMul:1.4, img:'boss1' },
    { name:'ìŠ¤í•€',     color:0xffaa22, ring:0xff6600, radius:10, spdMul:1.5, img:'boss2' },
    { name:'ì´‰ìˆ˜',     color:0xcc44ff, ring:0x8800cc, radius:10, spdMul:1.48,img:'boss3' },
    { name:'ì•„ì´ë³¼',   color:0xff2244, ring:0xcc0022, radius:11, spdMul:1.55,img:'boss4' },
    { name:'ì•„ì´ìŠ¤',   color:0x88ddff, ring:0x0088cc, radius:11, spdMul:1.52,img:'boss5' },
    { name:'í”Œë ˆì„',   color:0xff6600, ring:0xff2200, radius:12, spdMul:1.6, img:'boss6' },
    { name:'ì¬ë”',     color:0xffff22, ring:0xcc9900, radius:12, spdMul:1.58,img:'boss7' },
    { name:'ë‹¤í¬',     color:0xaa44ff, ring:0x660099, radius:13, spdMul:1.65,img:'boss8' },
    { name:'ì¹´ì˜¤ìŠ¤',   color:0xff44aa, ring:0xcc0077, radius:13, spdMul:1.7, img:'boss9' },
    { name:'ë³´ì´ë“œ',   color:0xff0000, ring:0x880000, radius:14, spdMul:1.75,img:'boss10'},
    { name:'ìŠ¬ë¼ì„EX', color:0x44ff44, ring:0x00cc00, radius:11, spdMul:1.95,img:'boss1' },
    { name:'ìŠ¤í•€EX',   color:0xffaa22, ring:0xff6600, radius:12, spdMul:2.0, img:'boss2' },
    { name:'ì´‰ìˆ˜EX',   color:0xcc44ff, ring:0x8800cc, radius:12, spdMul:1.98,img:'boss3' },
    { name:'ì•„ì´ë³¼EX', color:0xff2244, ring:0xcc0022, radius:13, spdMul:2.05,img:'boss4' },
    { name:'ì•„ì´ìŠ¤EX', color:0x88ddff, ring:0x0088cc, radius:13, spdMul:2.1, img:'boss5' },
  ];

  const ITEM_TYPES = ['freeze','speed','shield','slow'];
  const ITEM_EMOJI = { freeze:'âœ‹',speed:'ğŸƒ',shield:'ğŸ›¡',slow:'âŒ›' };
  const ITEM_DUR   = { freeze:5000, speed:4000, shield:7000, slow:6000 };
  const ITEM_LIFE  = 14000;
  const ITEM_BLINK = 5000;
  const ITEM_SPAWN = 20000;
  const MAX_ITEMS  = 3;
  const ITEMS      = ITEM_TYPES;

  const COLS = 52;
  const ROWS = 76;
  const CELL = 8;
  const W = COLS * CELL;
  const H = ROWS * CELL;
  const TARGET_PERCENT = 80;

  function getLRPlayerId() {
    let id = localStorage.getItem(STORAGE_PLAYER_KEY);
    if (!id) {
      id = 'lr_' + Math.random().toString(36).slice(2, 11);
      localStorage.setItem(STORAGE_PLAYER_KEY, id);
    }
    return id;
  }
  function getLRBestStage() {
    return parseInt(localStorage.getItem(STORAGE_BEST_KEY) || '0');
  }
  function setLRBestStage(s) {
    if (s > getLRBestStage()) {
      localStorage.setItem(STORAGE_BEST_KEY, String(s));
      const nickname = window.SharedWallet?.user?.nickname || window.SharedWallet?.user?.username || null;
      fetch(`${RELAY_URL}/api/rankings/linerush`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId: getLRPlayerId(), nickname, stage: s }),
      }).catch(() => {});
    }
  }
  function getUnlockedStage() {
    try {
      const v = Number(localStorage.getItem(STORAGE_UNLOCK_KEY) || '1');
      return Math.min(STAGE_COUNT, Math.max(1, Number.isFinite(v) ? v : 1));
    } catch (_) {
      return 1;
    }
  }
  function setUnlockedStage(stage) {
    try {
      const next = Math.min(STAGE_COUNT, Math.max(getUnlockedStage(), stage));
      localStorage.setItem(STORAGE_UNLOCK_KEY, String(next));
    } catch (_) {}
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DOM helpers / UI / joystick
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const gameWrap = document.getElementById('game-wrap');
  const uiRoot = document.getElementById('scene-ui');

  function setWrapBackground(key) {
    if (!key) {
      gameWrap.style.backgroundImage = '';
      return;
    }
    gameWrap.style.backgroundImage = `url('/linerush/img/${key}.jpg')`;
  }

  function showPanel(html) {
    uiRoot.innerHTML = `<div class="ui-panel">${html}</div>`;
    uiRoot.style.display = 'flex';
  }
  function hidePanel() {
    uiRoot.style.display = 'none';
    uiRoot.innerHTML = '';
  }

  const joyWrap = document.getElementById('joyWrap');
  const joyKnob = document.getElementById('joyKnob');
  const JOY_MAX = 48;
  let joyX = 0, joyY = 0, joyTouchId = null, joyCX = 0, joyCY = 0;

  function joyShow() { joyWrap.style.display = 'block'; }
  function joyHide() { joyWrap.style.display = 'none'; }
  function joyCenter() {
    const r = joyWrap.getBoundingClientRect();
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  function joyApply(dx, dy) {
    const len = Math.sqrt(dx * dx + dy * dy);
    const nx = len > JOY_MAX ? dx / len * JOY_MAX : dx;
    const ny = len > JOY_MAX ? dy / len * JOY_MAX : dy;
    joyKnob.style.transform = `translate(${nx}px,${ny}px)`;
    joyX = nx / JOY_MAX;
    joyY = ny / JOY_MAX;
  }
  function joyReset() {
    joyKnob.style.transform = 'translate(0,0)';
    joyX = 0;
    joyY = 0;
    joyTouchId = null;
  }

  document.addEventListener('touchstart', (e) => {
    if (joyWrap.style.display === 'none') return;
    for (const t of e.changedTouches) {
      if (joyTouchId !== null) continue;
      const c = joyCenter();
      const dx = t.clientX - c.x;
      const dy = t.clientY - c.y;
      if (Math.sqrt(dx * dx + dy * dy) < 90) {
        joyTouchId = t.identifier;
        joyCX = c.x;
        joyCY = c.y;
        joyApply(dx, dy);
        e.preventDefault();
      }
    }
  }, { passive: false });

  document.addEventListener('touchmove', (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === joyTouchId) {
        joyApply(t.clientX - joyCX, t.clientY - joyCY);
        e.preventDefault();
      }
    }
  }, { passive: false });

  document.addEventListener('touchend', (e) => {
    for (const t of e.changedTouches) if (t.identifier === joyTouchId) joyReset();
  });
  document.addEventListener('touchcancel', (e) => {
    for (const t of e.changedTouches) if (t.identifier === joyTouchId) joyReset();
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Kaplay setup
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const gameCanvas = document.createElement('canvas');
  gameWrap.appendChild(gameCanvas);

  function resizeCanvas() {
    const aw = gameWrap.clientWidth || window.innerWidth;
    const ah = gameWrap.clientHeight || Math.max(320, window.innerHeight - 48);
    const scale = Math.min(aw / W, ah / H, 2.1);
    gameCanvas.style.width = Math.round(W * scale) + 'px';
    gameCanvas.style.height = Math.round(H * scale) + 'px';
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  window.visualViewport?.addEventListener('resize', resizeCanvas);

  const k = kaplay({
    canvas: gameCanvas,
    width: W,
    height: H,
    background: [26, 10, 46],
    letterbox: true,
    pixelDensity: window.devicePixelRatio || 1,
    global: false,
    debug: false,
  });

  const hex2rgb = (hex) => [ (hex >> 16) & 255, (hex >> 8) & 255, hex & 255 ];
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const randInt = (lo, hi) => Math.floor(lo + Math.random() * (hi - lo + 1));

  let bgShuffle = null;
  function getStageBgKey(stage) {
    if (STAGE_CHAR_MAP[stage]) return STAGE_CHAR_MAP[stage];
    if (stage >= 11) return `bg${stage}`;

    if (!bgShuffle || stage === 4) {
      bgShuffle = Array.from({ length: BG_ORIG_END - BG_ORIG_START + 1 }, (_, i) => i + BG_ORIG_START);
      for (let i = bgShuffle.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [bgShuffle[i], bgShuffle[j]] = [bgShuffle[j], bgShuffle[i]];
      }
    }
    const idx = Math.min(stage - 4, bgShuffle.length - 1);
    return `bg${bgShuffle[Math.max(0, idx)]}`;
  }

  let assetsReady = false;
  let walletReady = false;

  function queueAssets() {
    ['char1', 'char2', 'char4'].forEach((n) => k.loadSprite(n, `/linerush/img/${n}.jpg`));
    for (let i = 1; i <= STAGE_COUNT; i++) k.loadSprite(`bg${i}`, `/linerush/img/bg${i}.jpg`);
    for (let i = 11; i <= STAGE_COUNT; i++) k.loadSprite(`char${i}`, `/linerush/img/char${i}.jpg`);
    for (let i = 1; i <= STAGE_COUNT; i++) k.loadSprite(`boss${i}`, `/linerush/img/boss${i}.png`);
  }

  k.onLoad(() => { assetsReady = true; });
  queueAssets();
  (async () => {
    if (window.SharedWallet) {
      try { await SharedWallet.init(); } catch (_) {}
    }
    walletReady = true;
  })();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Scene: boot
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  k.scene('boot', () => {
    hidePanel();
    joyHide();
    setWrapBackground('');

    const t = k.add([
      k.pos(W / 2, H / 2),
      k.anchor('center'),
      k.text('LOADING...', { size: 24, font: 'monospace' }),
      k.color(180, 210, 255),
    ]);

    let blink = 0;
    let timeout = 0;

    k.onUpdate(() => {
      blink += k.dt();
      timeout += k.dt();
      t.opacity = 0.5 + Math.sin(blink * 6) * 0.5;
      if ((assetsReady && walletReady) || timeout > 3.2) {
        k.go('menu');
      }
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Scene: menu
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  k.scene('menu', () => {
    joyHide();
    setWrapBackground('');

    showPanel(`
      <div class="ui-title">LINE RUSH</div>
      <div class="ui-sub">ì˜ì—­ì„ ì ë ¹í•˜ê³  80% ëŒíŒŒ!</div>
      <div style="text-align:center;color:#ffd36e;font-size:13px;margin-bottom:10px" id="bestRow"></div>
      <button class="ui-btn primary" id="playBtn">â–¶ STAGE 1 START</button>
      <div style="text-align:center;color:#86d7ff;font-size:12px;margin:8px 0 10px">
        ê° ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì‹œ stageÃ—${STAGE_REWARD.toLocaleString()}G ë³´ìƒ!
      </div>
      <div style="margin-top:8px;padding:10px;border-radius:10px;background:rgba(5,8,20,0.72);border:1px solid rgba(90,120,190,.35)">
        <div style="text-align:center;color:#ffd700;font-size:14px;margin-bottom:6px">ğŸ† ìµœê³  ìŠ¤í…Œì´ì§€ ë­í‚¹</div>
        <div id="rankBox" style="font-size:13px;color:#8aa3c8;text-align:center">ë­í‚¹ ë¡œë”© ì¤‘...</div>
      </div>
      <div style="text-align:center;color:#4d6488;font-size:11px;margin-top:10px">game.cocy.io</div>
    `);

    const best = getLRBestStage();
    const bestRow = document.getElementById('bestRow');
    bestRow.textContent = best > 0
      ? `ğŸ† ë‚´ ìµœê³ : STAGE ${best} | ìµœëŒ€ë³´ìƒ: ${(best * STAGE_REWARD).toLocaleString()}G`
      : 'ê¸°ë¡ ì—†ìŒ';

    document.getElementById('playBtn').onclick = () => {
      hidePanel();
      k.go('game', { stage: 1, score: 0, lives: 3 });
    };

    fetch(`${RELAY_URL}/api/rankings/linerush?limit=10`)
      .then((r) => r.json())
      .then((data) => {
        const box = document.getElementById('rankBox');
        if (!box) return;
        const rows = data.rankings || [];
        if (!rows.length) {
          box.innerHTML = 'ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤<br>ë¨¼ì € í”Œë ˆì´í•´ë³´ì„¸ìš”!';
          return;
        }
        box.innerHTML = rows.slice(0, 9).map((r, i) => {
          const medal = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'][i] || `${i + 1}.`;
          const nick = (r.nickname || 'ìµëª…').slice(0, 10);
          return `<div class="rank-row"><span>${medal} ${nick}</span><span style="color:#79d5ff">STAGE ${r.best_stage}</span></div>`;
        }).join('');
      })
      .catch(() => {
        const box = document.getElementById('rankBox');
        if (box) box.textContent = 'ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
      });

    k.onDraw(() => {
      k.drawRect({ pos: k.vec2(0, 0), width: W, height: H, color: k.rgb(16, 4, 34) });
      k.drawRect({ pos: k.vec2(0, 0), width: W, height: H, color: k.rgb(30, 8, 52), opacity: 0.38 });
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Scene: game
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  k.scene('game', (data) => {
    hidePanel();
    joyShow();

    const S = {
      stage: data?.stage || 1,
      score: data?.score || 0,
      lives: typeof data?.lives === 'number' ? data.lives : 3,
      claimedCells: 0,
      total: (COLS - 2) * (ROWS - 2),
      percent: 0,

      grid: Array.from({ length: ROWS }, (_, r) =>
        Array.from({ length: COLS }, (_, c) => (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1) ? 1 : 0)
      ),

      playerRow: 0,
      playerCol: Math.floor(COLS / 2),
      trail: [],
      isDrawing: false,
      drawStart: null,
      retracting: false,
      moveTimer: 0,
      moveDelay: 60,
      retractSpeedMul: 1.5,
      invuln: 0,

      fx: { freeze: 0, speed: 0, slow: 0, shield: 0 },
      items: [],
      itemSpawnTimer: ITEM_SPAWN * 0.5,

      enemies: [],
      enemyBullets: [],

      bossAttackTimer: 30000,
      bossCharging: false,

      particles: [],
      shieldRings: [],

      overlayDirty: true,
      overlayRects: [],
      boundaryRects: [],

      paused: false,
      dead: false,
      stageClearing: false,
      bgKey: getStageBgKey(data?.stage || 1),
    };

    setWrapBackground(S.bgKey);

    const enemyCount = Math.min(5, S.stage);
    for (let i = 0; i < enemyCount; i++) {
      const baseSpeed = CELL * (1.2 + S.stage * 0.38 + i * 0.04);
      const kind = (i % 3 === 0) ? 'hunter' : (i % 3 === 1 ? 'zigzag' : 'bouncer');
      S.enemies.push({
        x: k.rand(CELL * 2, W - CELL * 2),
        y: k.rand(CELL * 2, H - CELL * 2),
        vx: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        vy: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        baseSpeed,
        kind,
        radius: kind === 'hunter' ? 5 : 4.5,
        pulse: Math.random() * Math.PI * 2,
        shootCd: randInt(2000, 4000),
      });
    }

    const mmDef = MAIN_MONSTERS[Math.min(S.stage - 1, MAIN_MONSTERS.length - 1)];
    const mmSpeed = CELL * (1.2 + S.stage * 0.38) * mmDef.spdMul;
    S.mainMonster = {
      x: k.rand(CELL * 5, W - CELL * 5),
      y: k.rand(CELL * 5, H - CELL * 5),
      vx: (Math.random() > 0.5 ? 1 : -1) * mmSpeed,
      vy: (Math.random() > 0.5 ? 1 : -1) * mmSpeed,
      baseSpeed: mmSpeed,
      kind: 'boss',
      pulse: 0,
      shootCd: 600,
      radius: mmDef.radius,
      color: mmDef.color,
      ring: mmDef.ring,
      name: mmDef.name,
      img: mmDef.img,
      charging: false,
    };

    let bossSprite = null;
    if (k.getSprite(mmDef.img)) {
      bossSprite = k.add([
        k.sprite(mmDef.img),
        k.pos(S.mainMonster.x, S.mainMonster.y),
        k.anchor('center'),
        k.scale(0.55),
        k.z(95),
      ]);
    }
    let bossLabel = k.add([
      k.pos(S.mainMonster.x, S.mainMonster.y - mmDef.radius - 8),
      k.anchor('center'),
      k.text(`â˜… ${mmDef.name}`, { size: 11, font: 'monospace' }),
      k.color(255, 221, 68),
      k.z(96),
    ]);

    const hudLives = k.add([k.pos(12, 8), k.text('', { size: 18, font: 'monospace' }), k.z(120)]);
    const hudStage = k.add([k.pos(W / 2 - 74, 10), k.text('', { size: 15, font: 'monospace' }), k.color(125, 229, 255), k.z(120)]);
    const hudPercent = k.add([k.pos(W / 2 + 14, 10), k.text('', { size: 15, font: 'monospace' }), k.color(255, 241, 118), k.z(120)]);
    const hudScore = k.add([k.pos(W - 10, 10), k.anchor('topright'), k.text('', { size: 15, font: 'monospace' }), k.color(255, 180, 216), k.z(120)]);
    const hudFx = k.add([k.pos(W / 2, H - 10), k.anchor('bot'), k.text('', { size: 16, font: 'monospace' }), k.z(120)]);

    function refreshHUD() {
      hudLives.text = 'â¤ï¸'.repeat(Math.max(0, S.lives));
      hudStage.text = `STAGE ${S.stage}`;
      hudPercent.text = `${S.percent}%`;
      hudScore.text = `SCORE: ${S.score}`;
      const active = [];
      if (S.fx.freeze > 0) active.push('âœ‹');
      if (S.fx.speed > 0) active.push('ğŸƒ');
      if (S.fx.slow > 0) active.push('âŒ›');
      if (S.fx.shield > 0) active.push('ğŸ›¡');
      hudFx.text = active.join(' ');
    }

    function updateClaimStats() {
      let claimed = 0;
      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (S.grid[r][c] === 1) claimed++;
        }
      }
      S.claimedCells = claimed;
      S.percent = Math.floor((claimed / S.total) * 100);
      refreshHUD();
    }

    function redrawOverlayCache() {
      S.overlayRects.length = 0;
      S.boundaryRects.length = 0;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (S.grid[r][c] === 0 || S.grid[r][c] === 2) {
            S.overlayRects.push({ x: c * CELL, y: r * CELL });
          }
        }
      }

      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (S.grid[r][c] !== 0) continue;
          const nearClaimed = S.grid[r - 1][c] === 1 || S.grid[r + 1][c] === 1 || S.grid[r][c - 1] === 1 || S.grid[r][c + 1] === 1;
          if (nearClaimed) S.boundaryRects.push({ x: c * CELL + 1, y: r * CELL + 1 });
        }
      }

      S.overlayDirty = false;
    }

    function addParticles(x, y, count, colors, cfg = {}) {
      const minS = cfg.minS || 40;
      const maxS = cfg.maxS || 180;
      const life = cfg.life || 0.42;
      const size = cfg.size || [1, 3];
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const spd = k.rand(minS, maxS);
        const col = colors[randInt(0, colors.length - 1)];
        S.particles.push({
          x, y,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          life,
          maxLife: life,
          size: k.rand(size[0], size[1]),
          color: col,
        });
      }
    }

    function showItemMsg(msg) {
      const px = S.playerCol * CELL + CELL / 2;
      const py = S.playerRow * CELL + CELL / 2;
      const t = k.add([
        k.pos(px, py - 18),
        k.anchor('center'),
        k.text(msg, { size: 13, font: 'monospace' }),
        k.color(240, 252, 255),
        k.z(130),
      ]);
      let life = 1.6;
      t.onUpdate(() => {
        life -= k.dt();
        t.pos = k.vec2(t.pos.x, t.pos.y - 20 * k.dt());
        t.opacity = Math.max(0, life / 1.6);
        if (life <= 0) k.destroy(t);
      });
    }

    function activateShieldArc() {
      S.enemyBullets = [];
      const px = S.playerCol * CELL + CELL / 2;
      const py = S.playerRow * CELL + CELL / 2;
      for (let i = 0; i < 3; i++) {
        S.shieldRings.push({ x: px, y: py, radius: 12, life: 0.7 + i * 0.12, speed: 240 + i * 65 });
      }
      S.invuln = Math.max(S.invuln, 2000);
    }

    function collectItem(type) {
      const msgs = { freeze: 'âœ‹ ëª¬ìŠ¤í„° ì •ì§€!', speed: 'ğŸƒ 5ë°° ìŠ¤í”¼ë“œ!', shield: 'ğŸ›¡ ë°©ì–´ë§‰!', slow: 'âŒ› ê°ì†!' };
      showItemMsg(msgs[type]);
      if (type === 'shield') {
        activateShieldArc();
        S.fx.shield = ITEM_DUR[type];
      } else {
        S.fx[type] = Math.max(S.fx[type], ITEM_DUR[type]);
      }
      refreshHUD();
    }

    function spawnItem(forcedType = null) {
      const free = [];
      for (let r = 2; r < ROWS - 2; r++) {
        for (let c = 2; c < COLS - 2; c++) {
          if (S.grid[r][c] === 0) free.push({ r, c });
        }
      }
      if (!free.length) return;
      const cell = free[randInt(0, free.length - 1)];
      const type = forcedType || ITEM_TYPES[randInt(0, ITEM_TYPES.length - 1)];
      const cx = cell.c * CELL + CELL / 2;
      const cy = cell.r * CELL + CELL / 2;
      const label = k.add([
        k.pos(cx, cy),
        k.anchor('center'),
        k.text(ITEM_EMOJI[type], { size: 16, font: 'monospace' }),
        k.z(98),
      ]);
      S.items.push({ type, row: cell.r, col: cell.c, timeLeft: ITEM_LIFE, label });
    }

    function checkItemPickup() {
      for (let i = S.items.length - 1; i >= 0; i--) {
        const it = S.items[i];
        if (it.row === S.playerRow && it.col === S.playerCol) {
          collectItem(it.type);
          if (it.label) k.destroy(it.label);
          S.items.splice(i, 1);
        }
      }
    }

    function findNearestClaimed(row, col) {
      let best = { row: 0, col: 0, d: Infinity };
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (S.grid[r][c] !== 1) continue;
          const d = Math.abs(r - row) + Math.abs(c - col);
          if (d < best.d) best = { row: r, col: c, d };
        }
      }
      return { row: best.row, col: best.col };
    }

    function isFrontier(r, c) {
      if (S.grid[r][c] !== 1) return false;
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      for (const [dr, dc] of dirs) {
        const nr = r + dr;
        const nc = c + dc;
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && S.grid[nr][nc] === 0) return true;
      }
      return false;
    }

    function findNearestFrontier(row, col) {
      let best = null;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!isFrontier(r, c)) continue;
          const d = Math.abs(r - row) + Math.abs(c - col);
          if (!best || d < best.d) best = { row: r, col: c, d };
        }
      }
      return best || findNearestClaimed(row, col);
    }

    function showContinuePrompt() {
      S.paused = true;
      joyHide();
      const gold = window.SharedWallet?.gold || 0;

      showPanel(`
        <div style="text-align:center;font-size:28px;color:#ff6b6b;font-weight:700;margin-bottom:8px">ğŸ’€ GAME OVER</div>
        <div style="text-align:center;font-size:14px;color:#fff;line-height:1.45;margin-bottom:14px">
          100Gë¡œ ì´ì–´ê°€ì‹œê² ìŠµë‹ˆê¹Œ?<br>í˜„ì¬ ë³´ìœ : ${gold.toLocaleString()}G
        </div>
        <div class="ui-row">
          <button class="ui-btn warn" id="contBtn">ê³„ì† (100G)</button>
          <button class="ui-btn danger" id="quitBtn">í¬ê¸°</button>
        </div>
      `);

      document.getElementById('contBtn').onclick = async () => {
        if ((window.SharedWallet?.gold || 0) < 100) {
          hidePanel();
          k.go('gameover', { score: S.score, stage: S.stage });
          return;
        }
        try { await window.SharedWallet?.spendGold?.(100); } catch (_) {}
        hidePanel();
        S.paused = false;
        joyShow();
        S.lives = 1;
        S.fx = { freeze: 0, speed: 0, slow: 0, shield: 0 };
        const respawn = findNearestFrontier(S.playerRow, S.playerCol);
        S.playerRow = respawn.row;
        S.playerCol = respawn.col;
        S.invuln = 2500;
        refreshHUD();
      };

      document.getElementById('quitBtn').onclick = () => {
        hidePanel();
        k.go('gameover', { score: S.score, stage: S.stage });
      };
    }

    function playerDie() {
      if (S.invuln > 0 || S.dead || S.stageClearing) return;

      S.lives--;

      for (const cell of S.trail) {
        if (S.grid[cell.row][cell.col] === 2) S.grid[cell.row][cell.col] = 0;
      }
      S.overlayDirty = true;

      S.isDrawing = false;
      S.retracting = false;
      S.drawStart = null;
      S.trail = [];
      S.enemyBullets = [];

      spawnItem();
      spawnItem();

      if (S.lives <= 0) {
        const gold = window.SharedWallet?.gold || 0;
        if (gold >= 100) showContinuePrompt();
        else k.go('gameover', { score: S.score, stage: S.stage });
        return;
      }

      const respawn = findNearestFrontier(S.playerRow, S.playerCol);
      S.playerRow = respawn.row;
      S.playerCol = respawn.col;
      S.invuln = 900;
      refreshHUD();
    }

    function goClear(finalPercent = null) {
      if (S.stageClearing) return;
      S.stageClearing = true;
      joyHide();
      hidePanel();
      k.wait(0.45, () => {
        if (finalPercent !== null) S.percent = finalPercent;
        k.go('clear', {
          stage: S.stage,
          score: S.score,
          lives: S.lives,
          percent: S.percent,
          bgKey: S.bgKey,
        });
      });
    }

    function explodeEnemiesAndClear(finalPercent = null) {
      if (S.mainMonster) {
        addParticles(S.mainMonster.x, S.mainMonster.y, 36, [0xffd700, 0xffffff, S.mainMonster.color], { minS: 80, maxS: 260, life: 0.55, size: [2, 4] });
        if (bossSprite) k.destroy(bossSprite);
        if (bossLabel) k.destroy(bossLabel);
        bossSprite = null;
        bossLabel = null;
        S.mainMonster = null;
      }

      if (!S.enemies.length) {
        goClear(finalPercent);
        return;
      }

      S.enemies.forEach((e, idx) => {
        k.wait(idx * 0.085, () => {
          addParticles(e.x, e.y, 24, [0xffd36e, 0xff7f6e, 0xffffff], { minS: 70, maxS: 230, life: 0.44, size: [1.4, 2.6] });
        });
      });
      S.enemies = [];
      S.enemyBullets = [];

      k.wait(S.enemies.length * 0.085 + 0.46, () => goClear(finalPercent));
    }

    function captureTerritory() {
      for (const cell of S.trail) S.grid[cell.row][cell.col] = 1;

      const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      const regions = [];

      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (S.grid[r][c] !== 0 || visited[r][c]) continue;
          const queue = [{ r, c }];
          visited[r][c] = true;
          const cells = [];
          for (let qi = 0; qi < queue.length; qi++) {
            const cur = queue[qi];
            cells.push(cur);
            for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {
              const nr = cur.r + dr;
              const nc = cur.c + dc;
              if (nr < 1 || nr >= ROWS - 1 || nc < 1 || nc >= COLS - 1) continue;
              if (visited[nr][nc] || S.grid[nr][nc] !== 0) continue;
              visited[nr][nc] = true;
              queue.push({ r: nr, c: nc });
            }
          }
          regions.push({ cells });
        }
      }

      if (regions.length <= 1) {
        S.isDrawing = false;
        S.retracting = false;
        S.drawStart = null;
        S.trail = [];
        S.overlayDirty = true;
        updateClaimStats();
        return;
      }

      regions.sort((a, b) => a.cells.length - b.cells.length);
      const claimRegions = regions.slice(0, regions.length - 1);
      const captureMask = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      for (const reg of claimRegions) {
        for (const cell of reg.cells) captureMask[cell.r][cell.c] = true;
      }

      let mainCaptured = false;
      let bossRegionCells = 0;
      if (S.mainMonster) {
        const mmR = clamp(Math.floor(S.mainMonster.y / CELL), 0, ROWS - 1);
        const mmC = clamp(Math.floor(S.mainMonster.x / CELL), 0, COLS - 1);
        mainCaptured = captureMask[mmR][mmC];
        if (mainCaptured) {
          const found = claimRegions.find((reg) => reg.cells.some((cc) => cc.r === mmR && cc.c === mmC));
          bossRegionCells = found ? found.cells.length : 0;
        }
      }

      const toKill = [];
      for (const e of S.enemies) {
        const er = clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
        const ec = clamp(Math.floor(e.x / CELL), 0, COLS - 1);
        if (captureMask[er][ec]) toKill.push(e);
      }
      toKill.forEach((e) => addParticles(e.x, e.y, 18, [0xff7848, 0xffd4a6, 0xffff66], { minS: 50, maxS: 180, life: 0.38 }));
      S.enemies = S.enemies.filter((e) => !toKill.includes(e));
      if (toKill.length > 0) S.score += toKill.length * 500 * S.stage;

      let gained = 0;
      for (const reg of claimRegions) {
        for (const cell of reg.cells) {
          if (S.grid[cell.r][cell.c] === 0) {
            S.grid[cell.r][cell.c] = 1;
            gained++;
          }
        }
      }

      for (let i = S.items.length - 1; i >= 0; i--) {
        const it = S.items[i];
        if (S.grid[it.row][it.col] === 1) {
          collectItem(it.type);
          if (it.label) k.destroy(it.label);
          S.items.splice(i, 1);
        }
      }

      S.isDrawing = false;
      S.retracting = false;
      S.drawStart = null;
      S.trail = [];

      if (gained > 0) {
        S.score += gained * 50 * S.stage;
        addParticles(S.playerCol * CELL + CELL / 2, S.playerRow * CELL + CELL / 2, 26, [0x9cfbff, 0xfff799, 0xff9fd6], { minS: 40, maxS: 180, life: 0.42, size: [1.5, 3.2] });
        if (gained >= Math.ceil(S.total * 0.10)) {
          activateShieldArc();
          showItemMsg('10%â†‘ ë°©ì–´ë§‰ ë°œë™!');
        }
      }

      S.overlayDirty = true;
      updateClaimStats();

      if (mainCaptured && S.mainMonster) {
        const mm = S.mainMonster;
        addParticles(mm.x, mm.y, 44, [mm.color, 0xffffff, 0xffd700], { minS: 80, maxS: 280, life: 0.55, size: [2, 4.2] });
        if (bossSprite) k.destroy(bossSprite);
        if (bossLabel) k.destroy(bossLabel);
        S.mainMonster = null;
        bossSprite = null;
        bossLabel = null;
        S.score += 3000 * S.stage;
        showItemMsg(`â˜… ${mm.name} í¬íš! +${(3000 * S.stage).toLocaleString()}ì `);

        const bossRegionPct = Math.floor((bossRegionCells / S.total) * 100);
        const finalPercent = Math.max(0, 100 - bossRegionPct);
        explodeEnemiesAndClear(finalPercent);
        return;
      }

      if (S.percent >= TARGET_PERCENT) {
        explodeEnemiesAndClear();
      }
    }

    function stepRetreat() {
      if (!S.trail.length) {
        S.retracting = false;
        S.isDrawing = false;
        if (S.drawStart) {
          S.playerRow = S.drawStart.row;
          S.playerCol = S.drawStart.col;
        }
        S.drawStart = null;
        return;
      }

      const removed = S.trail.pop();
      if (S.grid[removed.row][removed.col] === 2) S.grid[removed.row][removed.col] = 0;
      S.overlayDirty = true;

      if (S.trail.length) {
        const back = S.trail[S.trail.length - 1];
        S.playerRow = back.row;
        S.playerCol = back.col;
      } else {
        if (S.drawStart) {
          S.playerRow = S.drawStart.row;
          S.playerCol = S.drawStart.col;
        }
        S.retracting = false;
        S.isDrawing = false;
        S.drawStart = null;
      }
    }

    function handleInput() {
      let dr = 0;
      let dc = 0;

      const axisX = joyX || 0;
      const axisY = joyY || 0;

      if (k.isKeyDown('left') || k.isKeyDown('a')) dc = -1;
      else if (k.isKeyDown('right') || k.isKeyDown('d')) dc = 1;
      else if (k.isKeyDown('up') || k.isKeyDown('w')) dr = -1;
      else if (k.isKeyDown('down') || k.isKeyDown('s')) dr = 1;
      else {
        if (Math.abs(axisX) > Math.abs(axisY) && Math.abs(axisX) > 0.25) dc = axisX < 0 ? -1 : 1;
        else if (Math.abs(axisY) > 0.25) dr = axisY < 0 ? -1 : 1;
      }

      if (dr === 0 && dc === 0) {
        if (S.isDrawing && !S.retracting && S.trail.length > 0) S.retracting = true;
        return;
      }
      S.retracting = false;

      const nr = S.playerRow + dr;
      const nc = S.playerCol + dc;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;

      const next = S.grid[nr][nc];
      if (next === 2) return;

      if (next === 0) {
        if (!S.isDrawing) {
          S.isDrawing = true;
          S.drawStart = { row: S.playerRow, col: S.playerCol };
          S.trail = [];
        }

        if (S.grid[S.playerRow][S.playerCol] === 0) {
          S.grid[S.playerRow][S.playerCol] = 2;
          S.trail.push({ row: S.playerRow, col: S.playerCol });
        }

        S.playerRow = nr;
        S.playerCol = nc;

        if (S.grid[S.playerRow][S.playerCol] === 0) {
          S.grid[S.playerRow][S.playerCol] = 2;
          S.trail.push({ row: S.playerRow, col: S.playerCol });
        }
        S.overlayDirty = true;
        return;
      }

      if (next === 1) {
        S.playerRow = nr;
        S.playerCol = nc;
        if (S.isDrawing) {
          if (S.trail.length <= 2) {
            for (const cell of S.trail) if (S.grid[cell.row][cell.col] === 2) S.grid[cell.row][cell.col] = 0;
            S.trail = [];
            S.isDrawing = false;
            S.retracting = false;
            S.drawStart = null;
            S.overlayDirty = true;
          } else {
            captureTerritory();
          }
        }
      }
    }

    function fireEnemyBullet(enemy, speed) {
      const px = S.playerCol * CELL + CELL / 2;
      const py = S.playerRow * CELL + CELL / 2;
      const dx = px - enemy.x;
      const dy = py - enemy.y;
      const d = Math.hypot(dx, dy) || 1;
      S.enemyBullets.push({
        x: enemy.x,
        y: enemy.y,
        vx: (dx / d) * speed,
        vy: (dy / d) * speed,
        r: Math.min(3.5, 1.8 + S.stage * 0.1),
        life: 99999,
      });
    }

    function triggerBossMegaAttack() {
      if (!S.mainMonster || S.bossCharging) return;
      const owned = [];
      for (let r = 2; r < ROWS - 2; r++) {
        for (let c = 2; c < COLS - 2; c++) {
          if (S.grid[r][c] === 1) owned.push({ r, c });
        }
      }
      if (owned.length < 10) return;

      const target = owned[randInt(0, owned.length - 1)];
      const tx = target.c * CELL + CELL / 2;
      const ty = target.r * CELL + CELL / 2;
      const mm = S.mainMonster;
      S.bossCharging = true;
      mm.charging = true;

      showItemMsg('âš ï¸ ë³´ìŠ¤ í­ê²© ì¤€ë¹„!');
      S.shieldRings.push({ x: tx, y: ty, radius: CELL * 2, life: 1.2, speed: 90, warn: true });

      k.wait(1.5, () => {
        if (!S.mainMonster) { S.bossCharging = false; return; }
        mm.charging = false;
        const dx = tx - mm.x;
        const dy = ty - mm.y;
        const d = Math.hypot(dx, dy) || 1;
        const speed = CELL * 2.8;
        S.enemyBullets.push({
          x: mm.x,
          y: mm.y,
          vx: (dx / d) * speed,
          vy: (dy / d) * speed,
          r: 22,
          life: 7000,
          isMega: true,
        });
        S.bossCharging = false;
      });
    }

    function megaBulletImpact(x, y) {
      const radius = 7;
      const impactR = Math.floor(y / CELL);
      const impactC = Math.floor(x / CELL);
      for (let r = impactR - radius; r <= impactR + radius; r++) {
        for (let c = impactC - radius; c <= impactC + radius; c++) {
          if (r < 1 || r >= ROWS - 1 || c < 1 || c >= COLS - 1) continue;
          const dr = r - impactR;
          const dc = c - impactC;
          if (Math.hypot(dr, dc) <= radius && S.grid[r][c] === 1) S.grid[r][c] = 0;
        }
      }
      S.overlayDirty = true;
      addParticles(x, y, 64, [0xff4400, 0xff8800, 0xffdd00, 0xff0000, 0xffffff], { minS: 80, maxS: 360, life: 0.7, size: [2.4, 4.1] });
      S.shieldRings.push({ x, y, radius: CELL * 4, life: 0.36, speed: 420, warn: true });
      updateClaimStats();
      showItemMsg('ğŸ’¥ ì˜ì—­ í­ê²©!');
    }

    function updateEnemies(deltaMs) {
      if (S.fx.freeze > 0) return;
      const slowMul = S.fx.slow > 0 ? 0.5 : 1;
      const dt = (deltaMs / 1000) * slowMul;
      const px = S.playerCol * CELL + CELL / 2;
      const py = S.playerRow * CELL + CELL / 2;

      if (S.mainMonster) {
        const mm = S.mainMonster;
        mm.pulse += dt * 5;
        const dx = px - mm.x;
        const dy = py - mm.y;
        const d = Math.hypot(dx, dy) || 1;

        if (S.isDrawing) {
          mm.vx = mm.vx * 0.82 + (dx / d) * mm.baseSpeed * 0.24;
          mm.vy = mm.vy * 0.82 + (dy / d) * mm.baseSpeed * 0.24;
        }

        let nx = mm.x + mm.vx * dt;
        let ny = mm.y + mm.vy * dt;
        if (nx < CELL || nx > W - CELL) { mm.vx *= -1; nx = clamp(nx, CELL, W - CELL); }
        if (ny < CELL || ny > H - CELL) { mm.vy *= -1; ny = clamp(ny, CELL, H - CELL); }

        const gr = (v) => clamp(Math.floor(v / CELL), 0, ROWS - 1);
        if (S.grid[gr(ny)][gr(nx + Math.sign(mm.vx || 1) * mm.radius)] === 1) mm.vx *= -1;
        if (S.grid[gr(ny + Math.sign(mm.vy || 1) * mm.radius)][gr(nx)] === 1) mm.vy *= -1;

        mm.x += mm.vx * dt;
        mm.y += mm.vy * dt;
        mm.shootCd -= deltaMs;

        if (mm.shootCd <= 0) {
          const speed = CELL * (3.2 + S.stage * 0.28);
          S.enemyBullets.push({
            x: mm.x,
            y: mm.y,
            vx: (dx / d) * speed,
            vy: (dy / d) * speed,
            r: 4,
            life: 99999,
          });
          mm.shootCd = Math.max(800, 2000 - S.stage * 80) + randInt(-150, 150);
        }

        if (bossSprite) bossSprite.pos = k.vec2(mm.x, mm.y);
        if (bossLabel) bossLabel.pos = k.vec2(mm.x, mm.y - mm.radius - 8);
      }

      for (const e of S.enemies) {
        e.pulse += dt * 6;

        if (e.kind === 'hunter' && S.isDrawing) {
          const dx = px - e.x;
          const dy = py - e.y;
          const d = Math.hypot(dx, dy) || 1;
          const aim = e.baseSpeed * 1.06;
          e.vx = (e.vx * 0.9) + (dx / d) * aim * 0.1;
          e.vy = (e.vy * 0.9) + (dy / d) * aim * 0.1;
        } else if (e.kind === 'zigzag') {
          const w = Math.sin(performance.now() * 0.006 + e.pulse) * 0.22;
          const vx = e.vx;
          e.vx = vx * Math.cos(w) - e.vy * Math.sin(w);
          e.vy = vx * Math.sin(w) + e.vy * Math.cos(w);
        }

        let nx = e.x + e.vx * dt;
        let ny = e.y + e.vy * dt;

        if (nx < CELL || nx > W - CELL) {
          e.vx *= -1;
          nx = clamp(nx, CELL, W - CELL);
        }
        if (ny < CELL || ny > H - CELL) {
          e.vy *= -1;
          ny = clamp(ny, CELL, H - CELL);
        }

        const testCell = (x, y) => {
          const rr = clamp(Math.floor(y / CELL), 0, ROWS - 1);
          const cc = clamp(Math.floor(x / CELL), 0, COLS - 1);
          return S.grid[rr][cc];
        };

        const hitX = testCell(nx + Math.sign(e.vx || 1) * e.radius, e.y) === 1;
        const hitY = testCell(e.x, ny + Math.sign(e.vy || 1) * e.radius) === 1;
        if (hitX) e.vx *= -1;
        if (hitY) e.vy *= -1;

        e.x += e.vx * dt;
        e.y += e.vy * dt;

        e.shootCd -= deltaMs;
        if (e.shootCd <= 0) {
          const intervalBase = e.kind === 'hunter'
            ? Math.max(1200, 3600 - S.stage * 180)
            : Math.max(2000, 5000 - S.stage * 200);
          if (e.kind !== 'hunter' || S.isDrawing) {
            const bulletSpeed = CELL * (2.6 + S.stage * 0.20);
            fireEnemyBullet(e, bulletSpeed);
          }
          e.shootCd = intervalBase + randInt(-300, 300);
        }
      }
    }

    function updateBullets(deltaMs) {
      if (S.fx.freeze > 0) return;
      const slowMul = S.fx.slow > 0 ? 0.5 : 1;
      const dt = (deltaMs / 1000) * slowMul;
      for (let i = S.enemyBullets.length - 1; i >= 0; i--) {
        const b = S.enemyBullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= deltaMs;

        if (b.life <= 0 || b.x < -12 || b.x > W + 12 || b.y < -12 || b.y > H + 12) {
          S.enemyBullets.splice(i, 1);
          continue;
        }

        if (b.isMega) {
          const br = clamp(Math.floor(b.y / CELL), 0, ROWS - 1);
          const bc = clamp(Math.floor(b.x / CELL), 0, COLS - 1);
          if (S.grid[br][bc] === 1) {
            megaBulletImpact(b.x, b.y);
            S.enemyBullets.splice(i, 1);
          }
        }
      }
    }

    function checkCollisions() {
      if (S.fx.shield > 0) return;

      const px = S.playerCol * CELL + CELL / 2;
      const py = S.playerRow * CELL + CELL / 2;

      if (S.mainMonster) {
        const mm = S.mainMonster;
        const dist = Math.hypot(px - mm.x, py - mm.y);
        if (dist < mm.radius + 5 && S.isDrawing) {
          playerDie();
          return;
        }
      }

      for (const e of S.enemies) {
        const dist = Math.hypot(px - e.x, py - e.y);
        if (dist < e.radius + 5) {
          if (S.isDrawing) {
            playerDie();
            return;
          }
          continue;
        }

        if (S.isDrawing) {
          const er = clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
          const ec = clamp(Math.floor(e.x / CELL), 0, COLS - 1);
          for (let rr = er - 1; rr <= er + 1; rr++) {
            for (let cc = ec - 1; cc <= ec + 1; cc++) {
              if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
              if (S.grid[rr][cc] === 2) {
                playerDie();
                return;
              }
            }
          }
        }
      }

      for (let i = S.enemyBullets.length - 1; i >= 0; i--) {
        const b = S.enemyBullets[i];
        const dist = Math.hypot(px - b.x, py - b.y);
        if (dist < b.r + 6) {
          S.enemyBullets.splice(i, 1);
          if (S.isDrawing) {
            playerDie();
            return;
          }
          continue;
        }

        if (S.isDrawing) {
          const br = clamp(Math.floor(b.y / CELL), 0, ROWS - 1);
          const bc = clamp(Math.floor(b.x / CELL), 0, COLS - 1);
          if (S.grid[br][bc] === 2) {
            S.enemyBullets.splice(i, 1);
            playerDie();
            return;
          }
        }
      }
    }

    updateClaimStats();
    redrawOverlayCache();

    k.onUpdate(() => {
      const deltaMs = k.dt() * 1000;
      if (S.paused || S.dead || S.stageClearing) return;

      S.moveTimer += deltaMs;
      const baseDelay = S.fx.speed > 0 ? S.moveDelay / 5 : S.moveDelay;
      const stepDelay = S.retracting ? baseDelay / S.retractSpeedMul : baseDelay;
      if (S.moveTimer >= stepDelay) {
        if (S.retracting) stepRetreat();
        else {
          handleInput();
          checkItemPickup();
        }
        S.moveTimer = 0;
      }

      if (S.invuln > 0) S.invuln -= deltaMs;
      if (S.fx.freeze > 0) S.fx.freeze -= deltaMs;
      if (S.fx.speed > 0) S.fx.speed -= deltaMs;
      if (S.fx.slow > 0) S.fx.slow -= deltaMs;
      if (S.fx.shield > 0) S.fx.shield -= deltaMs;

      S.itemSpawnTimer -= deltaMs;
      if (S.itemSpawnTimer <= 0 && S.items.length < MAX_ITEMS) {
        spawnItem();
        S.itemSpawnTimer = ITEM_SPAWN;
      }

      for (let i = S.items.length - 1; i >= 0; i--) {
        const it = S.items[i];
        it.timeLeft -= deltaMs;
        if (it.timeLeft <= 0) {
          if (it.label) k.destroy(it.label);
          S.items.splice(i, 1);
          continue;
        }
        if (it.timeLeft <= ITEM_BLINK) {
          if (it.label) it.label.opacity = (Math.floor(performance.now() / 250) % 2 === 0 ? 1 : 0.15);
        }
      }

      if (S.mainMonster && !S.bossCharging) {
        S.bossAttackTimer -= deltaMs;
        if (S.bossAttackTimer <= 0) {
          triggerBossMegaAttack();
          S.bossAttackTimer = 30000;
        }
      }

      updateEnemies(deltaMs);
      updateBullets(deltaMs);
      if (S.invuln <= 0) checkCollisions();

      for (let i = S.particles.length - 1; i >= 0; i--) {
        const p = S.particles[i];
        p.life -= k.dt();
        p.x += p.vx * k.dt();
        p.y += p.vy * k.dt();
        if (p.life <= 0) S.particles.splice(i, 1);
      }

      for (let i = S.shieldRings.length - 1; i >= 0; i--) {
        const r = S.shieldRings[i];
        r.life -= k.dt();
        r.radius += r.speed * k.dt();
        if (r.life <= 0) S.shieldRings.splice(i, 1);
      }

      if (S.overlayDirty) redrawOverlayCache();
      refreshHUD();
    });

    k.onDraw(() => {
      // Canvas backdrop tint (actual stage image comes from #game-wrap bg)
      k.drawRect({ pos: k.vec2(0, 0), width: W, height: H, color: k.rgb(7, 8, 20), opacity: 0.33 });

      // Overlay cache
      for (const rect of S.overlayRects) {
        k.drawRect({ pos: k.vec2(rect.x, rect.y), width: CELL, height: CELL, color: k.rgb(2, 3, 10), opacity: 0.965 });
      }
      for (const b of S.boundaryRects) {
        k.drawRect({ pos: k.vec2(b.x, b.y), width: CELL - 2, height: CELL - 2, color: k.rgb(190, 198, 255), opacity: 0.15 });
      }

      // Frontier border
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (S.grid[r][c] === 1 && (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1)) {
            k.drawRect({ pos: k.vec2(c * CELL + 0.5, r * CELL + 0.5), width: CELL - 1, height: CELL - 1, color: k.rgb(62, 158, 255), opacity: 0.48 });
          }
        }
      }

      // Trail
      let prev = null;
      for (const t of S.trail) {
        const cx = t.col * CELL + CELL / 2;
        const cy = t.row * CELL + CELL / 2;
        k.drawCircle({ pos: k.vec2(cx, cy), radius: 3, color: k.rgb(138, 255, 255), opacity: 0.38 });
        if (prev) {
          k.drawLine({ p1: k.vec2(prev.x, prev.y), p2: k.vec2(cx, cy), width: 2.5, color: k.rgb(0, 255, 255), opacity: 0.92 });
        }
        prev = { x: cx, y: cy };
      }

      // Enemies
      for (const e of S.enemies) {
        const glow = 10 + Math.sin(e.pulse) * 3;
        k.drawCircle({ pos: k.vec2(e.x, e.y), radius: glow, color: k.rgb(255, 79, 50), opacity: 0.18 });
        k.drawCircle({ pos: k.vec2(e.x, e.y), radius: e.radius, color: k.rgb(255, 120, 72), opacity: 0.85 });
        k.drawCircle({ pos: k.vec2(e.x - 1.5, e.y - 1.5), radius: 2, color: k.rgb(255, 212, 166), opacity: 0.65 });
      }

      // Boss fallback / effects
      if (S.mainMonster) {
        const mm = S.mainMonster;
        const pulse = 0.6 + 0.3 * Math.sin(mm.pulse);
        const glowR = mm.radius + 6 + 3 * Math.sin(mm.pulse * 1.3);
        const [rr, rg, rb] = hex2rgb(mm.ring);
        const [cr, cg, cb] = hex2rgb(mm.color);

        k.drawCircle({ pos: k.vec2(mm.x, mm.y), radius: glowR, color: k.rgb(rr, rg, rb), opacity: 0.44 });
        k.drawCircle({ pos: k.vec2(mm.x, mm.y), radius: glowR + 5, color: k.rgb(255, 255, 255), opacity: 0.22 });

        if (!bossSprite) {
          k.drawCircle({ pos: k.vec2(mm.x, mm.y), radius: mm.radius + 4, color: k.rgb(cr, cg, cb), opacity: 0.2 });
          k.drawCircle({ pos: k.vec2(mm.x, mm.y), radius: mm.radius, color: k.rgb(cr, cg, cb), opacity: 0.9 });
          k.drawCircle({ pos: k.vec2(mm.x - mm.radius * 0.3, mm.y - mm.radius * 0.3), radius: mm.radius * 0.32, color: k.rgb(255, 255, 255), opacity: 0.7 * pulse });
        }

        if (mm.charging) {
          const flashAlpha = 0.5 + 0.5 * Math.sin(performance.now() * 0.025);
          k.drawCircle({ pos: k.vec2(mm.x, mm.y), radius: mm.radius * 2.2, color: k.rgb(255, 68, 0), opacity: 0.55 * flashAlpha });
          k.drawCircle({ pos: k.vec2(mm.x, mm.y), radius: mm.radius * 2.5, color: k.rgb(255, 136, 0), opacity: 0.42 * flashAlpha });
        }
      }

      // Bullets
      for (const b of S.enemyBullets) {
        if (b.isMega) {
          const pulse = 0.7 + 0.3 * Math.sin(performance.now() * 0.01);
          k.drawCircle({ pos: k.vec2(b.x, b.y), radius: b.r + 8, color: k.rgb(255, 34, 0), opacity: 0.3 * pulse });
          k.drawCircle({ pos: k.vec2(b.x, b.y), radius: b.r, color: k.rgb(255, 102, 0), opacity: 0.9 });
          k.drawCircle({ pos: k.vec2(b.x, b.y), radius: b.r * 0.5, color: k.rgb(255, 215, 0), opacity: 0.85 });
        } else {
          k.drawCircle({ pos: k.vec2(b.x, b.y), radius: b.r, color: k.rgb(255, 244, 124), opacity: 0.95 });
        }
      }

      // Items glow
      const glowColors = { freeze: [136,221,255], speed: [255,255,136], shield: [136,255,136], slow: [255,187,136] };
      for (const it of S.items) {
        const cx = it.col * CELL + CELL / 2;
        const cy = it.row * CELL + CELL / 2;
        const pulse = 0.5 + 0.35 * Math.sin(performance.now() * 0.005 + it.col);
        const alpha = it.timeLeft <= ITEM_BLINK ? (Math.floor(performance.now() / 250) % 2 === 0 ? pulse : 0.1) : pulse;
        const [r, g, b] = glowColors[it.type];
        k.drawCircle({ pos: k.vec2(cx, cy), radius: CELL * 0.72, color: k.rgb(r, g, b), opacity: alpha * 0.5 });
      }

      // Player
      const px = S.playerCol * CELL + CELL / 2;
      const py = S.playerRow * CELL + CELL / 2;
      const blink = S.invuln > 0 ? (Math.floor(performance.now() / 80) % 2 === 0 ? 0.45 : 1) : 1;

      k.drawCircle({ pos: k.vec2(px, py), radius: 6, color: k.rgb(0, 0, 0), opacity: 0.9 * blink });
      k.drawCircle({ pos: k.vec2(px, py), radius: 6, color: k.rgb(0, 255, 255), opacity: 0.35 * blink });
      k.drawCircle({ pos: k.vec2(px, py), radius: 3.5, color: k.rgb(255, 255, 255), opacity: 1 * blink });
      k.drawCircle({ pos: k.vec2(px, py), radius: 1.5, color: k.rgb(10, 15, 26), opacity: 0.95 * blink });

      if (!S.isDrawing && S.invuln <= 0) {
        const sp = Math.sin(performance.now() * 0.006);
        const shieldR = 9 + sp * 1.5;
        k.drawCircle({ pos: k.vec2(px, py), radius: shieldR, color: k.rgb(68, 255, 221), opacity: (0.55 + sp * 0.2) * blink });
        k.drawCircle({ pos: k.vec2(px, py), radius: shieldR + 3, color: k.rgb(136, 255, 238), opacity: (0.2 + sp * 0.1) * blink });
      }

      // Custom rings / particles
      for (const ring of S.shieldRings) {
        const alpha = Math.max(0, ring.life / (ring.warn ? 1.2 : 0.82));
        if (ring.warn) {
          k.drawCircle({ pos: k.vec2(ring.x, ring.y), radius: ring.radius, color: k.rgb(255, 102, 0), opacity: alpha * 0.4 });
        } else {
          k.drawCircle({ pos: k.vec2(ring.x, ring.y), radius: ring.radius, color: k.rgb(68, 255, 136), opacity: alpha * 0.44 });
          k.drawCircle({ pos: k.vec2(ring.x, ring.y), radius: ring.radius + 5, color: k.rgb(170, 255, 204), opacity: alpha * 0.22 });
        }
      }

      for (const p of S.particles) {
        const [r, g, b] = hex2rgb(p.color);
        k.drawCircle({ pos: k.vec2(p.x, p.y), radius: p.size, color: k.rgb(r, g, b), opacity: Math.max(0, p.life / p.maxLife) });
      }

      // HUD top bar
      k.drawRect({ pos: k.vec2(0, 0), width: W, height: 32, color: k.rgb(0, 0, 0), opacity: 0.45 });
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Scene: clear
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  k.scene('clear', (data) => {
    joyHide();
    const stage = data?.stage || 1;
    const score = data?.score || 0;
    const lives = typeof data?.lives === 'number' ? data.lives : 3;
    const percent = data?.percent || 0;
    const bgKey = data?.bgKey || getStageBgKey(stage);

    setWrapBackground(bgKey);
    setUnlockedStage(stage + 1);

    const goldReward = stage * STAGE_REWARD;
    if (window.SharedWallet) window.SharedWallet.addGold(goldReward);
    setLRBestStage(stage);

    const clearBonus = 2000 * stage;
    const totalScore = score + clearBonus;
    const stars = percent >= 95 ? 3 : percent >= 90 ? 2 : 1;

    showPanel(`
      <div style="text-align:center;font-size:44px;color:#ffd56b;font-weight:800;text-shadow:0 2px 0 #6b3400">STAGE CLEAR!</div>
      <div style="text-align:center;font-size:70px;color:#fff;margin-top:10px">${percent}%</div>
      <div style="text-align:center;color:#c8e8ff;font-size:15px;letter-spacing:1px">CAPTURED</div>
      <div style="text-align:center;font-size:46px;margin-top:6px">${'â˜…'.repeat(stars)}<span style="color:#444466">${'â˜…'.repeat(3 - stars)}</span></div>

      <div class="score-line" style="color:#ffb4d8">SCORE: ${score}</div>
      <div class="score-line" style="color:#9cfbff">CLEAR BONUS: +${clearBonus}</div>
      <div class="score-line" style="color:#fff;font-size:19px">TOTAL: ${totalScore}</div>
      <div class="score-line" style="color:#ffd700">ğŸ’° +${goldReward.toLocaleString()} G íšë“!</div>

      <button class="ui-btn next" id="nextBtn" style="margin-top:14px">${stage < STAGE_COUNT ? 'NEXT STAGE â†’' : 'ğŸ  BACK TO MENU'}</button>
    `);

    document.getElementById('nextBtn').onclick = () => {
      hidePanel();
      if (stage < STAGE_COUNT) k.go('game', { stage: stage + 1, score: totalScore, lives });
      else k.go('menu');
    };

    k.onDraw(() => {
      k.drawRect({ pos: k.vec2(0, 0), width: W, height: H, color: k.rgb(0, 0, 0), opacity: 0.48 });
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Scene: gameover
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  k.scene('gameover', (data) => {
    joyHide();
    setWrapBackground('');

    const score = data?.score || 0;
    const stage = data?.stage || 1;

    showPanel(`
      <div style="text-align:center;font-size:52px;color:#ff6666;font-weight:800;margin-bottom:10px">GAME OVER</div>
      <div style="text-align:center;font-size:22px;color:#fff;margin-bottom:16px">FINAL SCORE: ${score}</div>
      <div class="ui-row">
        <button class="ui-btn primary" id="retryBtn">RETRY</button>
        <button class="ui-btn danger" id="menuBtn">MENU</button>
      </div>
    `);

    document.getElementById('retryBtn').onclick = () => {
      hidePanel();
      k.go('game', { stage, score: 0, lives: 3 });
    };
    document.getElementById('menuBtn').onclick = () => {
      hidePanel();
      k.go('menu');
    };

    k.onDraw(() => {
      k.drawRect({ pos: k.vec2(0, 0), width: W, height: H, color: k.rgb(0, 0, 0), opacity: 0.86 });
    });
  });

  k.go('boot');
})();
</script>
</body>
</html>
