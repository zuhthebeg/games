<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Line Rush</title>
  <script src="./phaser.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; display: flex; justify-content: center; align-items: flex-start;
           min-height: 100dvh; overflow: hidden; font-family: 'Trebuchet MS', sans-serif;
           padding-top: calc(48px + env(safe-area-inset-top)); }
    #game { width: 100vw; height: calc(100dvh - 48px - env(safe-area-inset-top));
            display: flex; justify-content: center; align-items: center; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
<div id="game"></div>
<script>
window.addEventListener('error', (e) => {
  const msg = document.createElement('div');
  msg.style.cssText = 'position:fixed;left:12px;right:12px;top:12px;z-index:99999;background:#300;color:#fff;padding:10px 12px;border-radius:8px;font:12px/1.4 sans-serif';
  msg.textContent = 'Line Rush Î°úÎî© Ïò§Î•ò: ' + (e.message || 'unknown');
  document.body.appendChild(msg);
});
const STAGE_COUNT        = 10;  // Ïù¥ÎØ∏ÏßÄ ÏäπÏù∏ ÌõÑ 15Î°ú ÏóÖÎç∞Ïù¥Ìä∏
const BG_ORIG_START      = 1;   // bg1-10: stage 4-10 random backgrounds
const BG_ORIG_END        = 10;
// stage 1‚Üíchar1, 2‚Üíchar2, 3‚Üíchar4 (luminarqmix-v7 portrait crops)
const STAGE_CHAR_MAP     = { 1: 'char1', 2: 'char2', 3: 'char4' };
const STAGE_REWARD       = 1000;  // Ïä§ÌÖåÏù¥ÏßÄÎãπ Í≥®Îìú Î≥¥ÏÉÅ (stage √ó STAGE_REWARD)
const RELAY_URL          = 'https://relay.cocy.io';
const STORAGE_BEST_KEY   = 'linerush_best_stage';
const STORAGE_PLAYER_KEY = 'linerush_player_id';
// (legacy) unlock key - kept for migration
const STORAGE_UNLOCK_KEY = 'linerush_unlocked_stage';
const ITEM_TYPES = ['freeze','speed','shield','slow'];
const ITEM_EMOJI = { freeze:'‚úã',speed:'üèÉ',shield:'üõ°',slow:'‚åõ' };
const ITEM_DUR   = { freeze:5000, speed:4000, shield:7000, slow:6000 };
const ITEM_LIFE  = 14000;
const ITEM_BLINK = 5000;
const ITEM_SPAWN = 20000;
const MAX_ITEMS  = 3;

function getLRPlayerId() {
  let id = localStorage.getItem(STORAGE_PLAYER_KEY);
  if (!id) { id = 'lr_' + Math.random().toString(36).slice(2, 11); localStorage.setItem(STORAGE_PLAYER_KEY, id); }
  return id;
}
function getLRBestStage() { return parseInt(localStorage.getItem(STORAGE_BEST_KEY) || '0'); }
function setLRBestStage(s) {
  if (s > getLRBestStage()) {
    localStorage.setItem(STORAGE_BEST_KEY, String(s));
    // ÎπÑÎèôÍ∏∞Î°ú ÏÑúÎ≤ÑÏóê Í∏∞Î°ù
    const nickname = window.SharedWallet?.user?.nickname || window.SharedWallet?.user?.username || null;
    fetch(`${RELAY_URL}/api/rankings/linerush`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: getLRPlayerId(), nickname, stage: s })
    }).catch(() => {});
  }
}
const COLS = 26;
const ROWS = 38;
const CELL = 16;
const W = COLS * CELL;
const H = ROWS * CELL;
const TARGET_PERCENT = 80;

function getUnlockedStage() {
  try {
    const v = Number(localStorage.getItem(STORAGE_UNLOCK_KEY) || '1');
    return Math.min(STAGE_COUNT, Math.max(1, Number.isFinite(v) ? v : 1));
  } catch (_) {
    return 1;
  }
}

function setUnlockedStage(stage) {
  try {
    const next = Math.min(STAGE_COUNT, Math.max(getUnlockedStage(), stage));
    localStorage.setItem(STORAGE_UNLOCK_KEY, String(next));
  } catch (_) {}
}

class BootScene extends Phaser.Scene {
  constructor() { super('Boot'); }

  preload() {
    // Stage 1-3 character backgrounds (luminarqmix-v7 portrait)
    ['char1', 'char2', 'char4'].forEach(k =>
      this.load.image(k, `/linerush/img/${k}.jpg`)
    );
    // Stage 4-10 original backgrounds
    for (let i = BG_ORIG_START; i <= BG_ORIG_END; i++) {
      this.load.image(`bg${i}`, `/linerush/img/bg${i}.jpg`);
    }
  }

  create() {
    const white = this.make.graphics({ x: 0, y: 0, add: false });
    white.fillStyle(0xffffff, 1);
    white.fillRect(0, 0, 2, 2);
    white.generateTexture('pixel', 2, 2);
    white.destroy();

    const palettes = [
      [0xff6b9d, 0xffa8c4],
      [0x7e57c2, 0x5dade2],
      [0xf39c12, 0xffd700],
      [0x2ecc71, 0x27ae60],
      [0x00c2ff, 0x3f5efb],
      [0xff4d6d, 0xff9e00],
      [0x8e44ad, 0xe056fd],
      [0x16a085, 0x48dbfb],
      [0xe67e22, 0xf1c40f],
      [0x34495e, 0x6c5ce7]
    ];

    for (let s = 1; s <= STAGE_COUNT; s++) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      const [c1, c2] = palettes[(s - 1) % palettes.length];
      g.fillGradientStyle(c1, c1, c2, c2, 1);
      g.fillRect(0, 0, W, H);

      g.fillStyle(0x000000, 0.24);
      g.fillCircle(W * 0.5, H * 0.24, 38);
      g.fillRoundedRect(W * 0.5 - 42, H * 0.32, 84, 140, 32);
      g.fillEllipse(W * 0.44, H * 0.77, 42, 84);
      g.fillEllipse(W * 0.56, H * 0.77, 42, 84);

      g.fillStyle(0xffffff, 0.08);
      g.fillCircle(W * 0.66, H * 0.21, 54);
      g.fillCircle(W * 0.31, H * 0.68, 72);

      g.generateTexture(`stage${s}_placeholder`, W, H);
      g.destroy();
    }

    this.scene.start('Menu');
  }
}

class MenuScene extends Phaser.Scene {
  constructor() { super('Menu'); }

  create() {
    // Î∞∞Í≤Ω
    const bg = this.add.graphics();
    bg.fillGradientStyle(0x120320, 0x120320, 0x220833, 0x220833, 1);
    bg.fillRect(0, 0, W, H);

    // ÌÉÄÏù¥ÌãÄ
    this.add.text(W / 2, 60, 'LINE RUSH', {
      fontFamily: 'Verdana', fontSize: '40px',
      color: '#ff79c6', stroke: '#ff2ea6', strokeThickness: 8
    }).setOrigin(0.5).setShadow(0, 0, '#ff2ea6', 24, true, true);

    this.add.text(W / 2, 104, 'ÏòÅÏó≠ÏùÑ Ï†êÎ†πÌïòÍ≥† 80% ÎèåÌåå!', {
      fontFamily: 'Verdana', fontSize: '13px', color: '#aacfff'
    }).setOrigin(0.5);

    // ÎÇ¥ Í∏∞Î°ù
    const best = getLRBestStage();
    const bestTxt = best > 0
      ? `üèÜ ÎÇ¥ ÏµúÍ≥†: STAGE ${best} | ÏµúÎåÄÎ≥¥ÏÉÅ: ${(best * STAGE_REWARD).toLocaleString()}G`
      : 'Í∏∞Î°ù ÏóÜÏùå';
    this.add.text(W / 2, 140, bestTxt, {
      fontFamily: 'Verdana', fontSize: '13px', color: '#ffd700'
    }).setOrigin(0.5);

    // PLAY Î≤ÑÌäº
    const playBtn = this.add.rectangle(W / 2, 210, 220, 58, 0x7020d0, 0.92)
      .setStrokeStyle(2, 0xff79c6, 1).setInteractive({ useHandCursor: true });
    this.add.text(W / 2, 210, '‚ñ∂  STAGE 1 START', {
      fontFamily: 'Verdana', fontSize: '18px', color: '#ffffff', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5);
    playBtn.on('pointerover', () => playBtn.setFillStyle(0x9030e8, 0.95));
    playBtn.on('pointerout', () => playBtn.setFillStyle(0x7020d0, 0.92));
    playBtn.on('pointerdown', () => this.scene.start('Game', { stage: 1, score: 0, lives: 3 }));

    // Î≥¥ÏÉÅ ÏïàÎÇ¥
    this.add.text(W / 2, 254, `Í∞Å Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ïãú stage√ó${STAGE_REWARD.toLocaleString()}G Î≥¥ÏÉÅ!`, {
      fontFamily: 'Verdana', fontSize: '11px', color: '#80d0ff'
    }).setOrigin(0.5);

    // Îû≠ÌÇπ ÏòÅÏó≠
    const rankTitle = this.add.text(W / 2, 284, 'üèÜ ÏµúÍ≥† Ïä§ÌÖåÏù¥ÏßÄ Îû≠ÌÇπ', {
      fontFamily: 'Verdana', fontSize: '14px', color: '#ffd700'
    }).setOrigin(0.5);

    const rankBg = this.add.rectangle(W / 2, 430, W - 20, 290, 0x050514, 0.7)
      .setStrokeStyle(1, 0x334466, 0.8);

    const loadingTxt = this.add.text(W / 2, 430, 'Îû≠ÌÇπ Î°úÎî© Ï§ë...', {
      fontFamily: 'Verdana', fontSize: '13px', color: '#6677aa'
    }).setOrigin(0.5);

    // ÎπÑÎèôÍ∏∞ Îû≠ÌÇπ fetch
    fetch(`${RELAY_URL}/api/rankings/linerush?limit=10`)
      .then(r => r.json())
      .then(data => {
        loadingTxt.destroy();
        const rows = data.rankings || [];
        if (rows.length === 0) {
          this.add.text(W / 2, 430, 'ÏïÑÏßÅ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§\nÎ®ºÏ†Ä ÌîåÎ†àÏù¥Ìï¥Î≥¥ÏÑ∏Ïöî!', {
            fontFamily: 'Verdana', fontSize: '13px', color: '#6677aa', align: 'center'
          }).setOrigin(0.5);
          return;
        }
        rows.slice(0, 9).forEach((r, i) => {
          const y = 300 + i * 30;
          const medal = ['ü•á','ü•à','ü•â'][i] || `${i+1}.`;
          const nick = (r.nickname || 'ÏùµÎ™Ö').slice(0, 10);
          const color = i === 0 ? '#ffd700' : i === 1 ? '#e0e0e0' : i === 2 ? '#cc8844' : '#99b4cc';
          this.add.text(16, y, `${medal} ${nick}`, {
            fontFamily: 'Verdana', fontSize: '13px', color, stroke: '#000', strokeThickness: 2
          });
          this.add.text(W - 16, y, `STAGE ${r.best_stage}`, {
            fontFamily: 'Verdana', fontSize: '13px', color: '#5ddcff', stroke: '#000', strokeThickness: 2
          }).setOrigin(1, 0);
        });
      })
      .catch(() => {
        loadingTxt.setText('Îû≠ÌÇπÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§');
      });

    this.add.text(W / 2, H - 18, 'game.cocy.io', {
      fontFamily: 'Verdana', fontSize: '11px', color: '#445566'
    }).setOrigin(0.5);
  }
}

class GameScene extends Phaser.Scene {
  constructor() {
    super('Game');
  }

  create(data) {
    this.stage = data.stage || 1;
    this.score = data.score || 0;
    this.lives = (typeof data.lives === 'number') ? data.lives : 3;
    this.claimedCells = 0;
    this.total = (COLS - 2) * (ROWS - 2);
    this.percent = 0;

    this.grid = [];
    for (let r = 0; r < ROWS; r++) {
      this.grid[r] = [];
      for (let c = 0; c < COLS; c++) {
        this.grid[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
      }
    }

    // Bg selection: stages 1-3 ‚Üí char portraits, stages 4-10 ‚Üí random from bg1-10
    let bgKey;
    if (STAGE_CHAR_MAP[this.stage]) {
      bgKey = STAGE_CHAR_MAP[this.stage];
    } else {
      if (!window._lrBgMap || this.stage === 4) {
        const origPool = Array.from({ length: BG_ORIG_END - BG_ORIG_START + 1 }, (_, i) => i + BG_ORIG_START);
        for (let i = origPool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [origPool[i], origPool[j]] = [origPool[j], origPool[i]];
        }
        window._lrBgMap = origPool; // 10 shuffled picks for stages 4-10
      }
      const mapIdx = Math.min(this.stage - 4, window._lrBgMap.length - 1);
      bgKey = `bg${window._lrBgMap[mapIdx]}`;
    }
    this.bgKey = bgKey;
    const key = this.textures.exists(bgKey) ? bgKey : `bg1`;
    this.bgImage = this.add.image(W / 2, H / 2, key).setDepth(0).setDisplaySize(W, H);


    this.overlayGfx = this.add.graphics().setDepth(1);
    this.claimedGfx = this.add.graphics().setDepth(2);
    this.trailGfx = this.add.graphics().setDepth(3).setBlendMode(Phaser.BlendModes.ADD);
    this.actorGfx = this.add.graphics().setDepth(4);
    this.itemGfx  = this.add.graphics().setDepth(5);

    this.playerRow = 0;
    this.playerCol = Math.floor(COLS / 2);
    this.trail = [];
    this.isDrawing = false;
    this.drawStart = null;
    this.retracting = false;
    this.moveTimer = 0;
    this.moveDelay = 120;
    this.retractSpeedMul = 1.5;
    this.invuln = 0;

    this.fx = { freeze: 0, speed: 0, slow: 0, shield: 0 };
    this.items = [];
    this.itemSpawnTimer = ITEM_SPAWN * 0.5; // first item at 10s

    const enemyCount = Math.min(8, this.stage + 1);
    this.enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      const baseSpeed = CELL * (0.9 + this.stage * 0.32 + i * 0.03);
      const kind = (i % 3 === 0) ? 'hunter' : (i % 3 === 1 ? 'zigzag' : 'bouncer');
      this.enemies.push({
        x: Phaser.Math.FloatBetween(CELL * 2, W - CELL * 2),
        y: Phaser.Math.FloatBetween(CELL * 2, H - CELL * 2),
        vx: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        vy: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        baseSpeed,
        kind,
        radius: kind === 'hunter' ? 6.6 : 6,
        pulse: Math.random() * Math.PI * 2,
        shootCd: Phaser.Math.Between(500, 1200)
      });
    }

    this.enemyBullets = [];

    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.touchAxis = { x: 0, y: 0 };
    this.createTouchControls();

    this.createHUD();
    this.updateClaimStats();
    this.redrawOverlay();
    this.drawGrid();
  }

  createTouchControls() {
    const isTouch = this.sys.game.device.input.touch;
    if (!isTouch) return;

    const joyCenter = { x: W - 72, y: H - 80 };
    const joyRadius = 42;
    const knobRadius = 18;

    this.joyBase = this.add.circle(joyCenter.x, joyCenter.y, joyRadius, 0x001a2e, 0.42)
      .setStrokeStyle(2, 0x63d9ff, 0.9).setDepth(20).setScrollFactor(0);
    this.joyKnob = this.add.circle(joyCenter.x, joyCenter.y, knobRadius, 0x39c6ff, 0.75)
      .setStrokeStyle(2, 0xb8f1ff, 0.95).setDepth(21).setScrollFactor(0);

    const joyZone = this.add.zone(joyCenter.x, joyCenter.y, joyRadius * 2.3, joyRadius * 2.3)
      .setOrigin(0.5).setDepth(22).setScrollFactor(0).setInteractive();

    let joyPointerId = null;

    const resetStick = () => {
      this.touchAxis.x = 0;
      this.touchAxis.y = 0;
      this.joyKnob.setPosition(joyCenter.x, joyCenter.y);
      joyPointerId = null;
    };

    const updateStick = (pointer) => {
      const dx = pointer.x - joyCenter.x;
      const dy = pointer.y - joyCenter.y;
      const dist = Math.hypot(dx, dy) || 1;
      const clamped = Math.min(joyRadius, dist);
      const nx = dx / dist;
      const ny = dy / dist;
      this.joyKnob.setPosition(joyCenter.x + nx * clamped, joyCenter.y + ny * clamped);
      this.touchAxis.x = nx * (clamped / joyRadius);
      this.touchAxis.y = ny * (clamped / joyRadius);
    };

    joyZone.on('pointerdown', (p) => {
      joyPointerId = p.id;
      updateStick(p);
    });

    this.input.on('pointermove', (p) => {
      if (joyPointerId === null || p.id !== joyPointerId || !p.isDown) return;
      updateStick(p);
    });

    this.input.on('pointerup', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });

    joyZone.on('pointerout', (p) => {
      // keep moving even if finger leaves circle; release on pointerup only
      if (joyPointerId === null || p.id !== joyPointerId) return;
    });
    joyZone.on('pointerupoutside', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });
  }

  createHUD() {
    this.hudBg = this.add.rectangle(W / 2, 16, W, 32, 0x000000, 0.45).setDepth(10);
    this.hudLives = this.add.text(12, 8, '', {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffffff'
    }).setDepth(11);
    this.hudStage = this.add.text(W / 2 - 68, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#7de5ff'
    }).setDepth(11);
    this.hudPercent = this.add.text(W / 2 + 14, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#fff176'
    }).setDepth(11);
    this.hudScore = this.add.text(W - 12, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#ffb4d8'
    }).setOrigin(1, 0).setDepth(11);
    this.hudFx = this.add.text(W / 2, H - 18, '', {
      fontSize: '18px'
    }).setOrigin(0.5, 1).setDepth(11);

    this.refreshHUD();
  }

  refreshHUD() {
    this.hudLives.setText('‚ù§Ô∏è'.repeat(Math.max(0, this.lives)));
    this.hudStage.setText(`STAGE ${this.stage}`);
    this.hudPercent.setText(`${this.percent}%`);
    this.hudScore.setText(`SCORE: ${this.score}`);
    if (this.hudFx) {
      const active = [];
      if (this.fx?.freeze > 0) active.push('‚úã');
      if (this.fx?.speed  > 0) active.push('üèÉ');
      if (this.fx?.slow   > 0) active.push('‚åõ');
      if (this.fx?.shield > 0) active.push('üõ°');
      this.hudFx.setText(active.join(' '));
    }
  }

  update(time, delta) {
    this.moveTimer += delta;

    const baseDelay = this.fx.speed > 0 ? this.moveDelay / 5 : this.moveDelay;
    const stepDelay = this.retracting ? baseDelay / this.retractSpeedMul : baseDelay;
    if (this.moveTimer >= stepDelay) {
      if (this.retracting) {
        this.stepRetreat();
      } else {
        this.handleInput();
        this.checkItemPickup();
      }
      this.moveTimer = 0;
    }

    if (this.invuln > 0) this.invuln -= delta;

    // fx timers
    if (this.fx.freeze > 0) this.fx.freeze -= delta;
    if (this.fx.speed  > 0) this.fx.speed  -= delta;
    if (this.fx.slow   > 0) this.fx.slow   -= delta;
    if (this.fx.shield > 0) this.fx.shield -= delta;

    // item spawn + lifetime
    this.itemSpawnTimer -= delta;
    if (this.itemSpawnTimer <= 0 && this.items.length < MAX_ITEMS) {
      this.spawnItem();
      this.itemSpawnTimer = ITEM_SPAWN;
    }
    for (let i = this.items.length - 1; i >= 0; i--) {
      const it = this.items[i];
      it.timeLeft -= delta;
      if (it.timeLeft <= 0) { it.label.destroy(); this.items.splice(i, 1); continue; }
      if (it.timeLeft <= ITEM_BLINK) {
        it.label.setAlpha(Math.floor(this.time.now / 250) % 2 === 0 ? 1 : 0.15);
      }
    }

    this.updateEnemies(delta);
    this.updateBullets(delta);
    if (this.invuln <= 0) {
      this.checkCollisions();
    }
    this.refreshHUD();
    this.drawGrid();
  }

  handleInput() {
    let dr = 0;
    let dc = 0;

    const axisX = this.touchAxis?.x || 0;
    const axisY = this.touchAxis?.y || 0;

    if (this.cursors.left.isDown || this.wasd.A.isDown) dc = -1;
    else if (this.cursors.right.isDown || this.wasd.D.isDown) dc = 1;
    else if (this.cursors.up.isDown || this.wasd.W.isDown) dr = -1;
    else if (this.cursors.down.isDown || this.wasd.S.isDown) dr = 1;
    else {
      if (Math.abs(axisX) > Math.abs(axisY) && Math.abs(axisX) > 0.25) dc = axisX < 0 ? -1 : 1;
      else if (Math.abs(axisY) > 0.25) dr = axisY < 0 ? -1 : 1;
    }

    if (dr === 0 && dc === 0) {
      // No input while drawing ‚Üí retract trail at 1.5x speed
      if (this.isDrawing && !this.retracting && this.trail.length > 0) {
        this.retracting = true;
      }
      return;
    }
    // Directional input: cancel retraction
    this.retracting = false;

    const nr = this.playerRow + dr;
    const nc = this.playerCol + dc;

    if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;

    const next = this.grid[nr][nc];
    if (next === 2) {
      // ÏûêÍ∏∞ Ìä∏Î†àÏùºÏóê ÎßâÌûò ‚Äî Ï£ΩÏßÄ ÏïäÍ≥† Ïù¥ÎèôÎßå Î¨¥Ïãú
      return;
    }

    if (next === 0) {
      if (!this.isDrawing) {
        this.isDrawing = true;
        this.drawStart = { row: this.playerRow, col: this.playerCol };
        this.trail = [];
      }

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }

      this.playerRow = nr;
      this.playerCol = nc;

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }
      return;
    }

    if (next === 1) {
      // Allow movement to any claimed cell (frontier restriction removed ‚Äî caused corner bug)
      this.playerRow = nr;
      this.playerCol = nc;
      if (this.isDrawing) {
        // Ìä∏Î†àÏùºÏù¥ ÎÑàÎ¨¥ ÏßßÏúºÎ©¥ (‚â§2Ïπ∏) Ï∫°Ï≤ò ÎåÄÏã† Í∞ïÏ†ú Ï∑®ÏÜå (Ïô∏Í≥ΩÏÑ† Ïã§Ïàò Î∞©ÏßÄ)
        if (this.trail.length <= 2) {
          for (const cell of this.trail) {
            if (this.grid[cell.row][cell.col] === 2) this.grid[cell.row][cell.col] = 0;
          }
          this.trail = [];
          this.isDrawing = false;
          this.retracting = false;
          this.drawStart = null;
          this.redrawOverlay();
        } else {
          this.captureTerritory();
        }
      }
    }
  }

  isFrontier(r, c) {
    if (this.grid[r][c] !== 1) return false;
    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    for (const [dr, dc] of dirs) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && this.grid[nr][nc] === 0) return true;
    }
    return false;
  }

  stepRetreat() {
    if (!this.trail.length) {
      this.retracting = false;
      this.isDrawing = false;
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.drawStart = null;
      return;
    }

    const removed = this.trail.pop();
    if (this.grid[removed.row][removed.col] === 2) {
      this.grid[removed.row][removed.col] = 0;
    }

    if (this.trail.length) {
      const back = this.trail[this.trail.length - 1];
      this.playerRow = back.row;
      this.playerCol = back.col;
    } else {
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.retracting = false;
      this.isDrawing = false;
      this.drawStart = null;
    }

    this.redrawOverlay();
  }

  captureTerritory() {
    for (const cell of this.trail) {
      this.grid[cell.row][cell.col] = 1;
    }

    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    const regions = [];

    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0 || visited[r][c]) continue;

        const queue = [{ r, c }];
        visited[r][c] = true;
        const cells = [];
        let hasEnemy = false;

        while (queue.length) {
          const cur = queue.shift();
          cells.push(cur);

          for (const e of this.enemies) {
            const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
            const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
            if (er === cur.r && ec === cur.c) {
              hasEnemy = true;
              break;
            }
          }

          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          for (const [dr, dc] of dirs) {
            const nr = cur.r + dr;
            const nc = cur.c + dc;
            if (nr < 1 || nr >= ROWS - 1 || nc < 1 || nc >= COLS - 1) continue;
            if (visited[nr][nc]) continue;
            if (this.grid[nr][nc] !== 0) continue;
            visited[nr][nc] = true;
            queue.push({ r: nr, c: nc });
          }
        }

        regions.push({ cells, hasEnemy });
      }
    }

    // 1Í∞ú Ïù¥Ìïò region = dead-end trail (enclosed area ÏóÜÏùå) ‚Üí Ï∫°Ï≤ò Ï∑®ÏÜå, Ìä∏Î†àÏùº Î≥µÏõê
    if (regions.length <= 1) {
      for (const cell of this.trail) {
        if (this.grid[cell.row][cell.col] === 1) this.grid[cell.row][cell.col] = 0;
      }
      this.isDrawing = false;
      this.retracting = false;
      this.drawStart = null;
      this.trail = [];
      this.redrawOverlay();
      return;
    }

    // 2Í∞ú Ïù¥ÏÉÅ region ‚Üí Í∞ÄÏû• ÏûëÏùÄ region Ï∫°Ï≤ò (Qix Î£∞)
    regions.sort((a, b) => a.cells.length - b.cells.length);
    const claimRegions = [regions[0]];
    const safeRegion   = regions[regions.length - 1];

    // Ìè¨ÏúÑÎêú Î™¨Ïä§ÌÑ∞ Ï†úÍ±∞ (ÏàúÍ∞ÑÏù¥Îèô ÎåÄÏã† ÏÜåÎ©∏)
    const toKill = [];
    for (const e of this.enemies) {
      const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
      const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
      if (claimRegions.some(region => region.cells.some(c => c.r === er && c.c === ec))) {
        toKill.push(e);
      }
    }
    toKill.forEach(e => {
      const burst = this.add.particles(e.x, e.y, 'pixel', {
        speed: { min: 50, max: 200 }, lifespan: 400, quantity: 22,
        scale: { start: 1.5, end: 0 }, tint: [0xff7848, 0xffd4a6, 0xffff66],
        blendMode: 'ADD'
      }).setDepth(9);
      this.time.delayedCall(450, () => burst.destroy());
    });
    this.enemies = this.enemies.filter(e => !toKill.includes(e));
    if (toKill.length > 0) this.score += toKill.length * 500 * this.stage;

    let gained = 0;
    for (const region of claimRegions) {
      for (const cell of region.cells) {
        if (this.grid[cell.r][cell.c] === 0) {
          this.grid[cell.r][cell.c] = 1;
          gained++;
        }
      }
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];

    if (gained > 0) {
      this.score += gained * 50 * this.stage;
      this.cameras.main.flash(300, 255, 255, 200);
      this.captureBurst();
      // 10% Ïù¥ÏÉÅ ÌïúÎ≤àÏóê ÌöçÎìù ‚Üí Ïâ¥Îìú Î∞úÎèô
      if (gained >= Math.ceil(this.total * 0.10)) {
        this.activateShieldArc();
        this.showItemMsg('10%‚Üë Î∞©Ïñ¥Îßâ Î∞úÎèô!', 0x44ff88);
      }
    }

    this.updateClaimStats();
    this.redrawOverlay();

    if (this.percent >= TARGET_PERCENT) {
      this.explodeEnemiesAndClear();
    }
  }

  explodeEnemiesAndClear() {
    if (!this.enemies.length) {
      this.time.delayedCall(380, () => {
        this.scene.start('Clear', {
          stage: this.stage,
          score: this.score,
          lives: this.lives,
          percent: this.percent,
          bgKey: this.bgKey
        });
      });
      return;
    }

    const enemyCount = this.enemies.length;
    this.enemies.forEach((e, idx) => {
      this.time.delayedCall(idx * 85, () => {
        const burst = this.add.particles(e.x, e.y, 'pixel', {
          speed: { min: 70, max: 240 },
          lifespan: 420,
          quantity: 26,
          scale: { start: 1.4, end: 0 },
          tint: [0xffd36e, 0xff7f6e, 0xffffff],
          blendMode: 'ADD'
        }).setDepth(9);
        this.time.delayedCall(430, () => burst.destroy());
      });
    });
    this.enemies = [];
    this.enemyBullets = [];

    this.time.delayedCall(enemyCount * 85 + 460, () => {
      this.scene.start('Clear', {
        stage: this.stage,
        score: this.score,
        lives: this.lives,
        percent: this.percent,
        bgKey: this.bgKey
      });
    });
  }

  updateClaimStats() {
    let claimed = 0;
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] === 1) claimed++;
      }
    }
    this.claimedCells = claimed;
    this.percent = Math.floor((claimed / this.total) * 100);
    this.refreshHUD();
  }

  redrawOverlay() {
    this.overlayGfx.clear();

    // 1) dark mask for unrevealed area (very hidden before capture)
    this.overlayGfx.fillStyle(0x02030a, 0.965);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 0 || this.grid[r][c] === 2) {
          this.overlayGfx.fillRect(c * CELL, r * CELL, CELL, CELL);
        }
      }
    }

    // 2) silhouette-like contour glow on unrevealed area boundary
    this.overlayGfx.lineStyle(1.2, 0xbec6ff, 0.22);
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0) continue;
        const nearClaimed = this.grid[r-1][c] === 1 || this.grid[r+1][c] === 1 || this.grid[r][c-1] === 1 || this.grid[r][c+1] === 1;
        if (nearClaimed) {
          this.overlayGfx.strokeRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        }
      }
    }
  }

  updateEnemies(delta) {
    if (this.fx.freeze > 0) return; // frozen
    const slowMul = this.fx.slow > 0 ? 0.5 : 1;
    const dt = (delta / 1000) * slowMul;
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    for (const e of this.enemies) {
      e.pulse += dt * 6;

      // behavior patterns
      if (e.kind === 'hunter' && this.isDrawing) {
        const dx = px - e.x;
        const dy = py - e.y;
        const d = Math.hypot(dx, dy) || 1;
        const aim = e.baseSpeed * 1.06;
        e.vx = (e.vx * 0.9) + (dx / d) * aim * 0.1;
        e.vy = (e.vy * 0.9) + (dy / d) * aim * 0.1;
      } else if (e.kind === 'zigzag') {
        const w = Math.sin(this.time.now * 0.006 + e.pulse) * 0.22;
        const vx = e.vx;
        e.vx = vx * Math.cos(w) - e.vy * Math.sin(w);
        e.vy = vx * Math.sin(w) + e.vy * Math.cos(w);
      }

      let nx = e.x + e.vx * dt;
      let ny = e.y + e.vy * dt;

      if (nx < CELL || nx > W - CELL) {
        e.vx *= -1;
        nx = Phaser.Math.Clamp(nx, CELL, W - CELL);
      }
      if (ny < CELL || ny > H - CELL) {
        e.vy *= -1;
        ny = Phaser.Math.Clamp(ny, CELL, H - CELL);
      }

      const testCell = (x, y) => {
        const rr = Phaser.Math.Clamp(Math.floor(y / CELL), 0, ROWS - 1);
        const cc = Phaser.Math.Clamp(Math.floor(x / CELL), 0, COLS - 1);
        return this.grid[rr][cc];
      };

      const hitX = testCell(nx + Math.sign(e.vx || 1) * e.radius, e.y) === 1;
      const hitY = testCell(e.x, ny + Math.sign(e.vy || 1) * e.radius) === 1;

      if (hitX) e.vx *= -1;
      if (hitY) e.vy *= -1;

      e.x += e.vx * dt;
      e.y += e.vy * dt;

      // stage-scaled shooting
      e.shootCd -= delta;
      if (e.shootCd <= 0) {
        const intervalBase = Math.max(320, 1600 - this.stage * 105);
        const bulletSpeed = CELL * (2.1 + this.stage * 0.22);
        this.fireEnemyBullet(e, bulletSpeed);
        e.shootCd = intervalBase + Phaser.Math.Between(-180, 180);
      }
    }
  }

  fireEnemyBullet(enemy, speed) {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const dx = px - enemy.x;
    const dy = py - enemy.y;
    const d = Math.hypot(dx, dy) || 1;
    this.enemyBullets.push({
      x: enemy.x,
      y: enemy.y,
      vx: (dx / d) * speed,
      vy: (dy / d) * speed,
      r: Math.min(4.5, 2.2 + this.stage * 0.14),
      life: 99999
    });
  }

  updateBullets(delta) {
    if (this.fx.freeze > 0) return; // frozen
    const slowMul = this.fx.slow > 0 ? 0.5 : 1;
    const dt = (delta / 1000) * slowMul;
    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= delta;

      if (b.life <= 0 || b.x < -12 || b.x > W + 12 || b.y < -12 || b.y > H + 12) {
        this.enemyBullets.splice(i, 1);
      }
    }
  }

  checkCollisions() {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    for (const e of this.enemies) {
      const dist = Phaser.Math.Distance.Between(px, py, e.x, e.y);
      if (dist < e.radius + 5) {
        if (this.isDrawing) {
          this.playerDie();
          return;
        }
        // Shield: safe when not rushing
        continue;
      }

      if (this.isDrawing) {
        const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
        const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
        for (let rr = er - 1; rr <= er + 1; rr++) {
          for (let cc = ec - 1; cc <= ec + 1; cc++) {
            if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
            if (this.grid[rr][cc] === 2) {
              this.playerDie();
              return;
            }
          }
        }
      }
    }

    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      const dist = Phaser.Math.Distance.Between(px, py, b.x, b.y);
      if (dist < b.r + 6) {
        this.enemyBullets.splice(i, 1);
        if (this.isDrawing) {
          this.playerDie();
          return;
        }
        // Shield: bullet absorbed, no death
        continue;
      }
      if (this.isDrawing) {
        const br = Phaser.Math.Clamp(Math.floor(b.y / CELL), 0, ROWS - 1);
        const bc = Phaser.Math.Clamp(Math.floor(b.x / CELL), 0, COLS - 1);
        if (this.grid[br][bc] === 2) {
          this.enemyBullets.splice(i, 1);
          this.playerDie();
          return;
        }
      }
    }
  }

  findNearestClaimed(row, col) {
    let best = { row: 0, col: 0, d: Infinity };
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] !== 1) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (d < best.d) best = { row: r, col: c, d };
      }
    }
    return { row: best.row, col: best.col };
  }

  findNearestFrontier(row, col) {
    // Find nearest frontier cell (claimed + adjacent to unclaimed)
    let best = null;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!this.isFrontier(r, c)) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (!best || d < best.d) best = { row: r, col: c, d };
      }
    }
    // Fallback to any claimed cell if no frontier found
    return best || this.findNearestClaimed(row, col);
  }

  playerDie() {
    if (this.invuln > 0) return;

    this.lives--;
    this.cameras.main.shake(500, 0.02);
    this.cameras.main.flash(300, 255, 0, 0);

    for (const cell of this.trail) {
      if (this.grid[cell.row][cell.col] === 2) this.grid[cell.row][cell.col] = 0;
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];
    this.enemyBullets = [];
    this.redrawOverlay();

    // Ï£ΩÏùÑ Îïå ÎûúÎç§ ÏïÑÏù¥ÌÖú 2Í∞ú ÎìúÎ°≠
    this.spawnItem(); this.spawnItem();

    if (this.lives <= 0) {
      const gold = window.SharedWallet?.gold || 0;
      if (gold >= 100) {
        this.showContinuePrompt();
      } else {
        this.scene.start('GameOver', { score: this.score, stage: this.stage });
      }
      return;
    }

    const respawn = this.findNearestFrontier(this.playerRow, this.playerCol);
    this.playerRow = respawn.row;
    this.playerCol = respawn.col;
    this.invuln = 900;
    this.refreshHUD();
  }

  spawnItem(forcedType = null) {
    const free = [];
    for (let r = 2; r < ROWS - 2; r++)
      for (let c = 2; c < COLS - 2; c++)
        if (this.grid[r][c] === 0) free.push({ r, c });
    if (!free.length) return;
    const cell = free[Phaser.Math.Between(0, free.length - 1)];
    const type = forcedType || ITEM_TYPES[Phaser.Math.Between(0, ITEM_TYPES.length - 1)];
    const cx = cell.c * CELL + CELL / 2;
    const cy = cell.r * CELL + CELL / 2;
    const label = this.add.text(cx, cy, ITEM_EMOJI[type], {
      fontSize: '16px', stroke: '#000', strokeThickness: 2
    }).setOrigin(0.5).setDepth(6);
    this.items.push({ type, row: cell.r, col: cell.c, timeLeft: ITEM_LIFE, label });
  }

  checkItemPickup() {
    for (let i = this.items.length - 1; i >= 0; i--) {
      const it = this.items[i];
      if (it.row === this.playerRow && it.col === this.playerCol) {
        this.collectItem(it.type);
        it.label.destroy();
        this.items.splice(i, 1);
      }
    }
  }

  collectItem(type) {
    const dur = ITEM_DUR[type];
    const colors = { freeze: '#88ddff', speed: '#ffff88', shield: '#88ff88', slow: '#ffbb88' };
    const msgs   = { freeze: '‚úã Î™¨Ïä§ÌÑ∞ Ï†ïÏßÄ!', speed: 'üèÉ 5Î∞∞ Ïä§ÌîºÎìú!', shield: 'üõ° Î∞©Ïñ¥Îßâ!', slow: '‚åõ Í∞êÏÜç!' };
    this.showItemMsg(msgs[type], colors[type]);
    if (type === 'shield') {
      this.activateShieldArc();
      this.fx.shield = dur;
    } else {
      this.fx[type] = Math.max(this.fx[type], dur);
    }
  }

  showItemMsg(msg, color) {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const t = this.add.text(px, py - 18, msg, {
      fontSize: '13px', color, stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setDepth(15);
    this.tweens.add({ targets: t, y: py - 56, alpha: 0, duration: 1600,
      onComplete: () => t.destroy() });
  }

  activateShieldArc() {
    this.enemyBullets = [];
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const g = this.add.graphics().setDepth(12);
    let step = 0;
    const ev = this.time.addEvent({ delay: 18, repeat: 35, callback: () => {
      g.clear();
      const r = 14 + step * 6;
      g.lineStyle(3, 0x44ff88, Math.max(0, 0.9 - step * 0.025));
      g.strokeCircle(px, py, r);
      g.lineStyle(1.5, 0xaaffcc, Math.max(0, 0.5 - step * 0.012));
      g.strokeCircle(px, py, r + 5);
      if (step % 5 === 0) this.enemyBullets = [];
      step++;
    }});
    this.time.delayedCall(700, () => { g.destroy(); ev.remove(); });
    this.invuln = Math.max(this.invuln, 2000);
  }

  showContinuePrompt() {
    const gold = window.SharedWallet?.gold || 0;
    const overlay = this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.78).setDepth(20);
    const box = this.add.rectangle(W / 2, H / 2, W * 0.84, 200, 0x0a0a1a, 0.96)
      .setStrokeStyle(2, 0xffd700).setDepth(21);
    this.add.text(W / 2, H / 2 - 72, 'üíÄ Í≤åÏûÑ Ïò§Î≤Ñ', {
      fontSize: '22px', color: '#ff6666', fontStyle: 'bold', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setDepth(22);
    this.add.text(W / 2, H / 2 - 28, `100GÎ°ú Ïù¥Ïñ¥Í∞ÄÏãúÍ≤†ÏäµÎãàÍπå?\nÌòÑÏû¨ Î≥¥Ïú†: ${gold.toLocaleString()}G`, {
      fontSize: '13px', color: '#ffffff', align: 'center'
    }).setOrigin(0.5).setDepth(22);
    const contBtn = this.add.text(W / 2 - 54, H / 2 + 42, 'Í≥ÑÏÜç (100G)', {
      fontSize: '14px', color: '#000', backgroundColor: '#ffd700',
      padding: { x: 10, y: 8 }
    }).setOrigin(0.5).setInteractive({ useHandCursor: true }).setDepth(22);
    const quitBtn = this.add.text(W / 2 + 60, H / 2 + 42, 'Ìè¨Í∏∞', {
      fontSize: '14px', color: '#fff', backgroundColor: '#cc3333',
      padding: { x: 18, y: 8 }
    }).setOrigin(0.5).setInteractive({ useHandCursor: true }).setDepth(22);
    contBtn.on('pointerdown', () => {
      if (window.SharedWallet) SharedWallet.spendGold(100);
      overlay.destroy(); box.destroy();
      [contBtn, quitBtn].forEach(b => b.destroy());
      this.children.list.filter(c => c.depth === 22).forEach(c => c.destroy());
      this.lives = 1;
      this.fx = { freeze: 0, speed: 0, slow: 0, shield: 0 };
      const respawn = this.findNearestFrontier(this.playerRow, this.playerCol);
      this.playerRow = respawn.row; this.playerCol = respawn.col;
      this.invuln = 2500;
      this.refreshHUD();
    });
    quitBtn.on('pointerdown', () => {
      this.scene.start('GameOver', { score: this.score, stage: this.stage });
    });
  }

  captureBurst() {
    if (!this.trail.length) return;
    let sr = 0;
    let sc = 0;
    for (const t of this.trail) {
      sr += t.row;
      sc += t.col;
    }
    const cx = (sc / this.trail.length) * CELL + CELL / 2;
    const cy = (sr / this.trail.length) * CELL + CELL / 2;

    const p = this.add.particles(cx, cy, 'pixel', {
      speed: { min: 40, max: 180 },
      lifespan: 380,
      quantity: 24,
      scale: { start: 1.5, end: 0 },
      tint: [0x9cfbff, 0xfff799, 0xff9fd6],
      blendMode: 'ADD'
    }).setDepth(9);

    this.time.delayedCall(420, () => p.destroy());
  }

  drawGrid() {
    this.claimedGfx.clear();
    this.trailGfx.clear();
    this.actorGfx.clear();

    this.claimedGfx.lineStyle(1, 0x3e9eff, 0.65);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 1 && (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1)) {
          this.claimedGfx.strokeRect(c * CELL + 0.5, r * CELL + 0.5, CELL - 1, CELL - 1);
        }
      }
    }

    // visually smoothed trail (curve-like feel over grid movement)
    this.trailGfx.lineStyle(4, 0x00ffff, 0.92);
    this.trailGfx.fillStyle(0x8affff, 0.38);
    let prev = null;
    for (const t of this.trail) {
      const cx = t.col * CELL + CELL / 2;
      const cy = t.row * CELL + CELL / 2;
      this.trailGfx.fillCircle(cx, cy, 4.5);
      if (prev) {
        this.trailGfx.beginPath();
        this.trailGfx.moveTo(prev.x, prev.y);
        this.trailGfx.lineTo(cx, cy);
        this.trailGfx.strokePath();
      }
      prev = { x: cx, y: cy };
    }

    for (const e of this.enemies) {
      const glow = 10 + Math.sin(e.pulse) * 3;
      this.actorGfx.fillStyle(0xff4f32, 0.18);
      this.actorGfx.fillCircle(e.x, e.y, glow);
      this.actorGfx.fillStyle(0xff7848, 0.85);
      this.actorGfx.fillCircle(e.x, e.y, e.radius);
      this.actorGfx.fillStyle(0xffd4a6, 0.65);
      this.actorGfx.fillCircle(e.x - 1.5, e.y - 1.5, 2);
      if (e.kind === 'hunter') {
        this.actorGfx.lineStyle(1.6, 0xffd7d7, 0.9);
        this.actorGfx.strokeCircle(e.x, e.y, e.radius + 2.5);
      } else if (e.kind === 'zigzag') {
        this.actorGfx.lineStyle(1.2, 0xffe4a8, 0.85);
        this.actorGfx.strokeTriangle(e.x, e.y - (e.radius + 2), e.x - (e.radius + 2), e.y + (e.radius + 2), e.x + (e.radius + 2), e.y + (e.radius + 2));
      } else {
        this.actorGfx.lineStyle(1.2, 0xffc9a2, 0.85);
        this.actorGfx.strokeRect(e.x - (e.radius + 2), e.y - (e.radius + 2), (e.radius + 2) * 2, (e.radius + 2) * 2);
      }
    }

    // enemy bullets
    this.actorGfx.fillStyle(0xfff47c, 0.95);
    for (const b of this.enemyBullets) {
      this.actorGfx.fillCircle(b.x, b.y, b.r);
    }

    // items glow
    this.itemGfx.clear();
    const glowColors = { freeze: 0x88ddff, speed: 0xffff88, shield: 0x88ff88, slow: 0xffbb88 };
    for (const it of this.items) {
      const cx = it.col * CELL + CELL / 2;
      const cy = it.row * CELL + CELL / 2;
      const pulse = 0.5 + 0.35 * Math.sin(this.time.now * 0.005 + it.col);
      const alpha = it.timeLeft <= ITEM_BLINK ? (Math.floor(this.time.now / 250) % 2 === 0 ? pulse : 0.1) : pulse;
      this.itemGfx.fillStyle(glowColors[it.type], alpha * 0.5);
      this.itemGfx.fillCircle(cx, cy, CELL * 0.72);
      this.itemGfx.lineStyle(1.5, glowColors[it.type], alpha * 0.8);
      this.itemGfx.strokeCircle(cx, cy, CELL * 0.72);
    }

    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const blink = this.invuln > 0 ? (Math.floor(this.time.now / 80) % 2 === 0 ? 0.45 : 1) : 1;

    // high-contrast player marker
    this.actorGfx.lineStyle(2, 0x000000, 0.9 * blink);
    this.actorGfx.strokeCircle(px, py, 9);
    this.actorGfx.fillStyle(0x00ffff, 0.35 * blink);
    this.actorGfx.fillCircle(px, py, 9);
    this.actorGfx.fillStyle(0xffffff, 1 * blink);
    this.actorGfx.fillCircle(px, py, 5.2);
    this.actorGfx.fillStyle(0x0a0f1a, 0.95 * blink);
    this.actorGfx.fillCircle(px, py, 2.2);

    // Shield ring: visible when safe (not rushing)
    if (!this.isDrawing && this.invuln <= 0) {
      const sp = Math.sin(this.time.now * 0.006);
      const shieldR = 13 + sp * 2;
      this.actorGfx.lineStyle(2.4, 0x44ffdd, (0.55 + sp * 0.2) * blink);
      this.actorGfx.strokeCircle(px, py, shieldR);
      this.actorGfx.lineStyle(1, 0x88ffee, (0.2 + sp * 0.1) * blink);
      this.actorGfx.strokeCircle(px, py, shieldR + 4.5);
    }
  }
}

class ClearScene extends Phaser.Scene {
  constructor() { super('Clear'); }

  create(data) {
    const { stage = 1, score = 0, lives = 3, percent = 0, bgKey = null } = data;
    setUnlockedStage(stage + 1);

    // Í≥®Îìú Î≥¥ÏÉÅ ÏßÄÍ∏â + ÏµúÍ≥† Í∏∞Î°ù Í∞±Ïã†
    const goldReward = stage * STAGE_REWARD;
    if (window.SharedWallet) SharedWallet.addGold(goldReward);
    setLRBestStage(stage);

    const clearBonus = 2000 * stage;
    const totalScore = score + clearBonus;

    // ‚îÄ‚îÄ Background: show the stage image in full glory ‚îÄ‚îÄ
    if (bgKey && this.textures.exists(bgKey)) {
      this.add.image(W / 2, H / 2, bgKey).setDisplaySize(W, H).setDepth(0);
    } else {
      this.add.rectangle(W / 2, H / 2, W, H, 0x0a0f1a).setDepth(0);
    }
    // subtle dark overlay so text is readable but bg still visible
    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.48).setDepth(1);

    // ‚îÄ‚îÄ Camera flash ‚îÄ‚îÄ
    this.cameras.main.flash(600, 255, 220, 80);

    // ‚îÄ‚îÄ STAGE CLEAR! title ‚îÄ‚îÄ
    const titleTxt = this.add.text(W / 2, 110, 'STAGE CLEAR!', {
      fontFamily: 'Verdana',
      fontSize: '46px',
      color: '#ffd56b',
      stroke: '#7a3800',
      strokeThickness: 7
    }).setOrigin(0.5).setAlpha(0).setScale(0.4).setDepth(2);

    this.tweens.add({
      targets: titleTxt,
      alpha: 1,
      scale: 1,
      duration: 420,
      ease: 'Back.Out',
      delay: 150
    });

    // ‚îÄ‚îÄ Confetti burst ‚îÄ‚îÄ
    this.time.delayedCall(180, () => {
      const conf = this.add.particles(W / 2, 80, 'pixel', {
        speed: { min: 60, max: 240 },
        angle: { min: 190, max: 350 },
        gravityY: 260,
        lifespan: 1400,
        quantity: 5,
        scale: { start: 1.8, end: 0.1 },
        tint: [0xffd56b, 0xff7aa2, 0x7ce8ff, 0xa8ff78],
        blendMode: 'ADD'
      }).setDepth(10);
      this.time.delayedCall(2200, () => { if (conf.active) conf.stop(); });
    });

    // ‚îÄ‚îÄ CAPTURE % ‚Äî big bounce animation ‚îÄ‚îÄ
    const pctTxt = this.add.text(W / 2, 230, `${percent}%`, {
      fontFamily: 'Verdana',
      fontSize: '82px',
      color: '#ffffff',
      stroke: '#003366',
      strokeThickness: 10
    }).setOrigin(0.5).setAlpha(0).setScale(2.4).setDepth(2);

    this.tweens.add({
      targets: pctTxt,
      alpha: 1,
      scale: 1,
      duration: 500,
      ease: 'Back.Out',
      delay: 520,
      onComplete: () => {
        // pulse: big ‚Üí normal √ó 2
        this.tweens.add({
          targets: pctTxt,
          scale: { from: 1, to: 1.22 },
          duration: 200,
          ease: 'Quad.InOut',
          yoyo: true,
          repeat: 1,
          delay: 100
        });
      }
    });

    const capLabel = this.add.text(W / 2, 285, 'CAPTURED', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#c8e8ff',
      stroke: '#001a33',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);
    this.tweens.add({ targets: capLabel, alpha: 1, duration: 300, delay: 700 });

    // ‚îÄ‚îÄ Star rating ‚îÄ‚îÄ
    const stars = percent >= 95 ? 3 : percent >= 90 ? 2 : 1;
    const starSpacing = 58;
    const starY = 360;
    const starObjs = [];

    for (let i = 0; i < 3; i++) {
      const sx = W / 2 + (i - 1) * starSpacing;
      const starTxt = this.add.text(sx, starY, '‚òÖ', {
        fontFamily: 'Verdana',
        fontSize: '48px',
        color: i < stars ? '#ffd700' : '#444466',
        stroke: i < stars ? '#a06000' : '#222233',
        strokeThickness: 5
      }).setOrigin(0.5).setAlpha(0).setScale(0).setDepth(2);
      starObjs.push(starTxt);
    }

    for (let i = 0; i < stars; i++) {
      const delay = 1100 + i * 340;
      ((idx, d) => {
        this.time.delayedCall(d, () => {
          // pop in with overshoot
          this.tweens.add({
            targets: starObjs[idx],
            alpha: 1,
            scale: { from: 0, to: 1 },
            duration: 320,
            ease: 'Back.Out'
          });
          // burst particles at star position
          const sx = W / 2 + (idx - 1) * starSpacing;
          const burst = this.add.particles(sx, starY, 'pixel', {
            speed: { min: 50, max: 160 },
            lifespan: 500,
            quantity: 16,
            scale: { start: 1.4, end: 0 },
            tint: [0xffd700, 0xfff0a0, 0xffaa00],
            blendMode: 'ADD'
          }).setDepth(9);
          this.time.delayedCall(520, () => { if (burst.active) burst.destroy(); });
        });
      })(i, delay);
    }

    // unearned stars fade in dim
    for (let i = stars; i < 3; i++) {
      this.time.delayedCall(1100 + i * 340, () => {
        this.tweens.add({ targets: starObjs[i], alpha: 0.55, scale: 1, duration: 280, ease: 'Back.Out' });
      });
    }

    // ‚îÄ‚îÄ Score row ‚îÄ‚îÄ
    const scoreTxt = this.add.text(W / 2, 435, `SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffb4d8',
      stroke: '#330011',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const bonusTxt = this.add.text(W / 2, 462, `CLEAR BONUS: +${clearBonus}`, {
      fontFamily: 'Verdana',
      fontSize: '17px',
      color: '#9cfbff',
      stroke: '#001133',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const totalTxt = this.add.text(W / 2, 491, `TOTAL: ${totalScore}`, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff',
      stroke: '#002244',
      strokeThickness: 5
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const goldTxt = this.add.text(W / 2, 516, `üí∞ +${goldReward.toLocaleString()} G ÌöçÎìù!`, {
      fontFamily: 'Verdana',
      fontSize: '17px',
      color: '#ffd700',
      stroke: '#332200',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    this.tweens.add({ targets: [scoreTxt, bonusTxt, totalTxt, goldTxt], alpha: 1, duration: 360, delay: 2100 });

    // ‚îÄ‚îÄ Next button ‚îÄ‚îÄ
    const nextLabel = (stage < STAGE_COUNT) ? 'NEXT STAGE ‚Üí' : 'üè† BACK TO MENU';
    const btn = this.add.rectangle(W / 2, 568, 210, 48, 0x123966, 0.92)
      .setStrokeStyle(2, 0x7ce8ff, 1)
      .setInteractive({ useHandCursor: true })
      .setAlpha(0).setDepth(2);
    const btnTxt = this.add.text(W / 2, 568, nextLabel, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff'
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    this.tweens.add({ targets: [btn, btnTxt], alpha: 1, duration: 360, delay: 2500 });

    btn.on('pointerover', () => btn.setFillStyle(0x1d588f, 0.95));
    btn.on('pointerout', () => btn.setFillStyle(0x123966, 0.92));
    btn.on('pointerdown', () => {
      if (stage < STAGE_COUNT) {
        this.scene.start('Game', { stage: stage + 1, score: totalScore, lives });
      } else {
        this.scene.start('Menu');
      }
    });
  }
}

class GameOverScene extends Phaser.Scene {
  constructor() { super('GameOver'); }

  create(data) {
    const score = data.score || 0;

    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.86);
    this.add.text(W / 2, 122, 'GAME OVER', {
      fontFamily: 'Verdana',
      fontSize: '56px',
      color: '#ff6666',
      stroke: '#5c0000',
      strokeThickness: 8
    }).setOrigin(0.5);

    this.add.text(W / 2, 190, `FINAL SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '22px',
      color: '#ffffff'
    }).setOrigin(0.5);

    const makeButton = (x, y, label, onClick) => {
      const b = this.add.rectangle(x, y, 150, 42, 0x2a1e48, 0.95)
        .setStrokeStyle(2, 0xff7ab6, 1)
        .setInteractive({ useHandCursor: true });
      this.add.text(x, y, label, {
        fontFamily: 'Verdana',
        fontSize: '20px',
        color: '#ffffff'
      }).setOrigin(0.5);
      b.on('pointerover', () => b.setFillStyle(0x3b2b66, 0.95));
      b.on('pointerout', () => b.setFillStyle(0x2a1e48, 0.95));
      b.on('pointerdown', onClick);
    };

    makeButton(W / 2 - 84, 266, 'RETRY', () => {
      this.scene.start('Game', { stage: 1, score: 0, lives: 3 });
    });

    makeButton(W / 2 + 84, 266, 'MENU', () => {
      this.scene.start('Menu');
    });
  }
}

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  parent: 'game',
  backgroundColor: '#1a0a2e',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: [BootScene, MenuScene, GameScene, ClearScene, GameOverScene]
};

// SharedWallet Ï¥àÍ∏∞Ìôî ÌõÑ Phaser ÏãúÏûë
(async function() {
  if (window.SharedWallet) {
    try { await SharedWallet.init(); } catch (_) {}
  }
  new Phaser.Game(config);
})();

</script>
<script src="/lib/shared-wallet.js?v=20260214"></script>
</body>
</html>
