<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Line Rush</title>
  <script src="./phaser.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; display: flex; justify-content: center; align-items: center; min-height: 100dvh; overflow: hidden; font-family: 'Trebuchet MS', sans-serif; }
    #game { width: 100vw; height: 100dvh; display: flex; justify-content: center; align-items: center; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
<div id="game"></div>
<script>
window.addEventListener('error', (e) => {
  const msg = document.createElement('div');
  msg.style.cssText = 'position:fixed;left:12px;right:12px;top:12px;z-index:99999;background:#300;color:#fff;padding:10px 12px;border-radius:8px;font:12px/1.4 sans-serif';
  msg.textContent = 'Line Rush ë¡œë”© ì˜¤ë¥˜: ' + (e.message || 'unknown');
  document.body.appendChild(msg);
});
const STAGE_COUNT = 10;
const BG_LANDSCAPE_START = 11; // bg11-40: AI landscapes (stages 1-4)
const BG_LANDSCAPE_END   = 40;
const BG_CHAR_START      = 41; // bg41-50: character images (stages 5-10)
const BG_CHAR_END        = 50;
const BG_ORIG_START      = 1;  // bg1-10: original images (stages 5-10)
const BG_ORIG_END        = 10;
const STORAGE_UNLOCK_KEY = 'linerush_unlocked_stage';
const COLS = 26;
const ROWS = 38;
const CELL = 16;
const W = COLS * CELL;
const H = ROWS * CELL;
const TARGET_PERCENT = 80;

function getUnlockedStage() {
  try {
    const v = Number(localStorage.getItem(STORAGE_UNLOCK_KEY) || '1');
    return Math.min(STAGE_COUNT, Math.max(1, Number.isFinite(v) ? v : 1));
  } catch (_) {
    return 1;
  }
}

function setUnlockedStage(stage) {
  try {
    const next = Math.min(STAGE_COUNT, Math.max(getUnlockedStage(), stage));
    localStorage.setItem(STORAGE_UNLOCK_KEY, String(next));
  } catch (_) {}
}

class BootScene extends Phaser.Scene {
  constructor() { super('Boot'); }

  preload() {
    // Load all bg images: originals (1-10), landscapes (11-40), characters (41-50)
    for (let i = BG_ORIG_START; i <= BG_CHAR_END; i++) {
      this.load.image(`bg${i}`, `/linerush/img/bg${i}.jpg`);
    }
  }

  create() {
    const white = this.make.graphics({ x: 0, y: 0, add: false });
    white.fillStyle(0xffffff, 1);
    white.fillRect(0, 0, 2, 2);
    white.generateTexture('pixel', 2, 2);
    white.destroy();

    const palettes = [
      [0xff6b9d, 0xffa8c4],
      [0x7e57c2, 0x5dade2],
      [0xf39c12, 0xffd700],
      [0x2ecc71, 0x27ae60],
      [0x00c2ff, 0x3f5efb],
      [0xff4d6d, 0xff9e00],
      [0x8e44ad, 0xe056fd],
      [0x16a085, 0x48dbfb],
      [0xe67e22, 0xf1c40f],
      [0x34495e, 0x6c5ce7]
    ];

    for (let s = 1; s <= STAGE_COUNT; s++) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      const [c1, c2] = palettes[(s - 1) % palettes.length];
      g.fillGradientStyle(c1, c1, c2, c2, 1);
      g.fillRect(0, 0, W, H);

      g.fillStyle(0x000000, 0.24);
      g.fillCircle(W * 0.5, H * 0.24, 38);
      g.fillRoundedRect(W * 0.5 - 42, H * 0.32, 84, 140, 32);
      g.fillEllipse(W * 0.44, H * 0.77, 42, 84);
      g.fillEllipse(W * 0.56, H * 0.77, 42, 84);

      g.fillStyle(0xffffff, 0.08);
      g.fillCircle(W * 0.66, H * 0.21, 54);
      g.fillCircle(W * 0.31, H * 0.68, 72);

      g.generateTexture(`stage${s}_placeholder`, W, H);
      g.destroy();
    }

    this.scene.start('Menu');
  }
}

class MenuScene extends Phaser.Scene {
  constructor() { super('Menu'); }

  create() {
    const bg = this.add.graphics();
    bg.fillGradientStyle(0x120320, 0x120320, 0x220833, 0x220833, 1);
    bg.fillRect(0, 0, W, H);

    this.add.text(W / 2, 48, 'LINE RUSH', {
      fontFamily: 'Verdana',
      fontSize: '42px',
      color: '#ff79c6',
      stroke: '#ff2ea6',
      strokeThickness: 8
    }).setOrigin(0.5).setShadow(0, 0, '#ff2ea6', 24, true, true);

    this.add.text(W / 2, 96, 'STAGE SELECT', {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#99e9ff',
      stroke: '#133052',
      strokeThickness: 5
    }).setOrigin(0.5);

    const unlockedStage = getUnlockedStage();
    for (let s = 1; s <= STAGE_COUNT; s++) {
      const cols = 2;
      const row = Math.floor((s - 1) / cols);
      const col = (s - 1) % cols;
      const x = 104 + col * 208;
      const y = 178 + row * 82;
      const isLocked = s > unlockedStage;
      const frame = this.add.rectangle(x, y, 188, 72, 0x03030a, isLocked ? 0.45 : 0.7).setStrokeStyle(2, isLocked ? 0x4a4f65 : 0x59e3ff, 0.9);
      const hiddenThumb = this.add.rectangle(x - 52, y, 58, 66, isLocked ? 0x0d0f19 : 0x111425, 0.95)
        .setStrokeStyle(2, isLocked ? 0x3a3f58 : 0x59648a, 0.9);
      this.add.text(x - 52, y, isLocked ? 'ðŸ”’' : '?', {
        fontFamily: 'Verdana',
        fontSize: '30px',
        color: isLocked ? '#9299bd' : '#cfd6ff',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5);
      const label = this.add.text(x + 20, y, `STAGE ${s}`, {
        fontFamily: 'Verdana',
        fontSize: '18px',
        color: isLocked ? '#8a90aa' : '#ffffff',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5);

      const hit = this.add.zone(x, y, 188, 72).setOrigin(0.5).setInteractive({ useHandCursor: !isLocked });
      hit.on('pointerover', () => {
        if (isLocked) return;
        frame.setFillStyle(0x081235, 0.85);
        label.setScale(1.05);
      });
      hit.on('pointerout', () => {
        frame.setFillStyle(0x03030a, isLocked ? 0.45 : 0.7);
        label.setScale(1);
      });
      hit.on('pointerdown', () => {
        if (isLocked) return;
        this.scene.start('Game', { stage: s, score: 0, lives: 3 });
      });

      hiddenThumb.setAlpha(0.95);
    }

    this.add.text(W / 2, H - 24, 'Capture 80% to clear the stage', {
      fontFamily: 'Verdana',
      fontSize: '14px',
      color: '#aacfff'
    }).setOrigin(0.5);
  }
}

class GameScene extends Phaser.Scene {
  constructor() {
    super('Game');
  }

  create(data) {
    this.stage = data.stage || 1;
    this.score = data.score || 0;
    this.lives = (typeof data.lives === 'number') ? data.lives : 3;
    this.claimedCells = 0;
    this.total = (COLS - 2) * (ROWS - 2);
    this.percent = 0;

    this.grid = [];
    for (let r = 0; r < ROWS; r++) {
      this.grid[r] = [];
      for (let c = 0; c < COLS; c++) {
        this.grid[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
      }
    }

    // Bg pools: stages 1-4 = landscapes (bg11-40), stages 5-10 = originals+chars (bg1-10, bg41-50)
    if (!window._lrBgMap || this.stage === 1) {
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      // Landscape pool for stages 1-4
      const landscapes = shuffle(Array.from({ length: BG_LANDSCAPE_END - BG_LANDSCAPE_START + 1 }, (_, i) => BG_LANDSCAPE_START + i));
      // Character/original pool for stages 5-10
      const charOrig = shuffle([
        ...Array.from({ length: BG_ORIG_END - BG_ORIG_START + 1 }, (_, i) => BG_ORIG_START + i),
        ...Array.from({ length: BG_CHAR_END - BG_CHAR_START + 1 }, (_, i) => BG_CHAR_START + i),
      ]);
      // Build map: [stage1, stage2, ..., stage10]
      window._lrBgMap = [
        landscapes[0], landscapes[1], landscapes[2], landscapes[3], // stages 1-4
        charOrig[0], charOrig[1], charOrig[2], charOrig[3], charOrig[4], charOrig[5], // stages 5-10
      ];
    }
    const bgIdx = window._lrBgMap[Math.min(this.stage - 1, window._lrBgMap.length - 1)];
    this.bgIdx = bgIdx;
    const key = this.textures.exists(`bg${bgIdx}`) ? `bg${bgIdx}` : `stage${this.stage}_placeholder`;
    this.bgImage = this.add.image(W / 2, H / 2, key).setDepth(0).setDisplaySize(W, H);

    this.overlayGfx = this.add.graphics().setDepth(1);
    this.claimedGfx = this.add.graphics().setDepth(2);
    this.trailGfx = this.add.graphics().setDepth(3).setBlendMode(Phaser.BlendModes.ADD);
    this.actorGfx = this.add.graphics().setDepth(4);

    this.playerRow = 0;
    this.playerCol = Math.floor(COLS / 2);
    this.trail = [];
    this.isDrawing = false;
    this.drawStart = null;
    this.retracting = false;
    this.moveTimer = 0;
    this.moveDelay = 120;
    this.retractSpeedMul = 1.5;
    this.invuln = 0;

    const enemyCount = Math.min(8, this.stage + 1);
    this.enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      const baseSpeed = CELL * (0.9 + this.stage * 0.32 + i * 0.03);
      const kind = (i % 3 === 0) ? 'hunter' : (i % 3 === 1 ? 'zigzag' : 'bouncer');
      this.enemies.push({
        x: Phaser.Math.FloatBetween(CELL * 2, W - CELL * 2),
        y: Phaser.Math.FloatBetween(CELL * 2, H - CELL * 2),
        vx: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        vy: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        baseSpeed,
        kind,
        radius: kind === 'hunter' ? 6.6 : 6,
        pulse: Math.random() * Math.PI * 2,
        shootCd: Phaser.Math.Between(500, 1200)
      });
    }

    this.enemyBullets = [];

    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.touchAxis = { x: 0, y: 0 };
    this.createTouchControls();

    this.createHUD();
    this.updateClaimStats();
    this.redrawOverlay();
    this.drawGrid();
  }

  createTouchControls() {
    const isTouch = this.sys.game.device.input.touch;
    if (!isTouch) return;

    const joyCenter = { x: 72, y: H - 80 };
    const joyRadius = 42;
    const knobRadius = 18;

    this.joyBase = this.add.circle(joyCenter.x, joyCenter.y, joyRadius, 0x001a2e, 0.42)
      .setStrokeStyle(2, 0x63d9ff, 0.9).setDepth(20).setScrollFactor(0);
    this.joyKnob = this.add.circle(joyCenter.x, joyCenter.y, knobRadius, 0x39c6ff, 0.75)
      .setStrokeStyle(2, 0xb8f1ff, 0.95).setDepth(21).setScrollFactor(0);

    const joyZone = this.add.zone(joyCenter.x, joyCenter.y, joyRadius * 2.3, joyRadius * 2.3)
      .setOrigin(0.5).setDepth(22).setScrollFactor(0).setInteractive();

    let joyPointerId = null;

    const resetStick = () => {
      this.touchAxis.x = 0;
      this.touchAxis.y = 0;
      this.joyKnob.setPosition(joyCenter.x, joyCenter.y);
      joyPointerId = null;
    };

    const updateStick = (pointer) => {
      const dx = pointer.x - joyCenter.x;
      const dy = pointer.y - joyCenter.y;
      const dist = Math.hypot(dx, dy) || 1;
      const clamped = Math.min(joyRadius, dist);
      const nx = dx / dist;
      const ny = dy / dist;
      this.joyKnob.setPosition(joyCenter.x + nx * clamped, joyCenter.y + ny * clamped);
      this.touchAxis.x = nx * (clamped / joyRadius);
      this.touchAxis.y = ny * (clamped / joyRadius);
    };

    joyZone.on('pointerdown', (p) => {
      joyPointerId = p.id;
      updateStick(p);
    });

    this.input.on('pointermove', (p) => {
      if (joyPointerId === null || p.id !== joyPointerId || !p.isDown) return;
      updateStick(p);
    });

    this.input.on('pointerup', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });

    joyZone.on('pointerout', (p) => {
      // keep moving even if finger leaves circle; release on pointerup only
      if (joyPointerId === null || p.id !== joyPointerId) return;
    });
    joyZone.on('pointerupoutside', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });
  }

  createHUD() {
    this.hudBg = this.add.rectangle(W / 2, 16, W, 32, 0x000000, 0.45).setDepth(10);
    this.hudLives = this.add.text(12, 8, '', {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffffff'
    }).setDepth(11);
    this.hudStage = this.add.text(W / 2 - 68, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#7de5ff'
    }).setDepth(11);
    this.hudPercent = this.add.text(W / 2 + 14, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#fff176'
    }).setDepth(11);
    this.hudScore = this.add.text(W - 12, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#ffb4d8'
    }).setOrigin(1, 0).setDepth(11);

    this.refreshHUD();
  }

  refreshHUD() {
    this.hudLives.setText('â¤ï¸'.repeat(this.lives));
    this.hudStage.setText(`STAGE ${this.stage}`);
    this.hudPercent.setText(`${this.percent}%`);
    this.hudScore.setText(`SCORE: ${this.score}`);
  }

  update(time, delta) {
    this.moveTimer += delta;

    const stepDelay = this.retracting ? this.moveDelay / this.retractSpeedMul : this.moveDelay;
    if (this.moveTimer >= stepDelay) {
      if (this.retracting) {
        this.stepRetreat();
      } else {
        this.handleInput();
      }
      this.moveTimer = 0;
    }

    if (this.invuln > 0) {
      this.invuln -= delta;
    }

    this.updateEnemies(delta);
    this.updateBullets(delta);
    if (this.invuln <= 0) {
      this.checkCollisions();
    }

    this.drawGrid();
  }

  handleInput() {
    let dr = 0;
    let dc = 0;

    const axisX = this.touchAxis?.x || 0;
    const axisY = this.touchAxis?.y || 0;

    if (this.cursors.left.isDown || this.wasd.A.isDown) dc = -1;
    else if (this.cursors.right.isDown || this.wasd.D.isDown) dc = 1;
    else if (this.cursors.up.isDown || this.wasd.W.isDown) dr = -1;
    else if (this.cursors.down.isDown || this.wasd.S.isDown) dr = 1;
    else {
      if (Math.abs(axisX) > Math.abs(axisY) && Math.abs(axisX) > 0.25) dc = axisX < 0 ? -1 : 1;
      else if (Math.abs(axisY) > 0.25) dr = axisY < 0 ? -1 : 1;
    }

    if (dr === 0 && dc === 0) {
      // No input while drawing â†’ retract trail at 1.5x speed
      if (this.isDrawing && !this.retracting && this.trail.length > 0) {
        this.retracting = true;
      }
      return;
    }
    // Directional input: cancel retraction
    this.retracting = false;

    const nr = this.playerRow + dr;
    const nc = this.playerCol + dc;

    if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;

    const next = this.grid[nr][nc];
    if (next === 2) {
      this.playerDie();
      return;
    }

    if (next === 0) {
      if (!this.isDrawing) {
        this.isDrawing = true;
        this.drawStart = { row: this.playerRow, col: this.playerCol };
        this.trail = [];
      }

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }

      this.playerRow = nr;
      this.playerCol = nc;

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }
      return;
    }

    if (next === 1) {
      // When safe (not drawing), only allow moving to frontier cells
      // (claimed cells adjacent to at least one unclaimed cell)
      if (!this.isDrawing && !this.isFrontier(nr, nc)) return;
      this.playerRow = nr;
      this.playerCol = nc;
      if (this.isDrawing) {
        this.captureTerritory();
      }
    }
  }

  isFrontier(r, c) {
    if (this.grid[r][c] !== 1) return false;
    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    for (const [dr, dc] of dirs) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && this.grid[nr][nc] === 0) return true;
    }
    return false;
  }

  stepRetreat() {
    if (!this.trail.length) {
      this.retracting = false;
      this.isDrawing = false;
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.drawStart = null;
      return;
    }

    const removed = this.trail.pop();
    if (this.grid[removed.row][removed.col] === 2) {
      this.grid[removed.row][removed.col] = 0;
    }

    if (this.trail.length) {
      const back = this.trail[this.trail.length - 1];
      this.playerRow = back.row;
      this.playerCol = back.col;
    } else {
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.retracting = false;
      this.isDrawing = false;
      this.drawStart = null;
    }

    this.redrawOverlay();
  }

  captureTerritory() {
    for (const cell of this.trail) {
      this.grid[cell.row][cell.col] = 1;
    }

    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    const regions = [];

    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0 || visited[r][c]) continue;

        const queue = [{ r, c }];
        visited[r][c] = true;
        const cells = [];
        let hasEnemy = false;

        while (queue.length) {
          const cur = queue.shift();
          cells.push(cur);

          for (const e of this.enemies) {
            const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
            const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
            if (er === cur.r && ec === cur.c) {
              hasEnemy = true;
              break;
            }
          }

          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          for (const [dr, dc] of dirs) {
            const nr = cur.r + dr;
            const nc = cur.c + dc;
            if (nr < 1 || nr >= ROWS - 1 || nc < 1 || nc >= COLS - 1) continue;
            if (visited[nr][nc]) continue;
            if (this.grid[nr][nc] !== 0) continue;
            visited[nr][nc] = true;
            queue.push({ r: nr, c: nc });
          }
        }

        regions.push({ cells, hasEnemy });
      }
    }

    // Capture enemy-free regions; if all have enemies, capture only the smallest
    regions.sort((a, b) => a.cells.length - b.cells.length);
    const noEnemyRegions = regions.filter(r => !r.hasEnemy);
    let claimRegions;
    if (noEnemyRegions.length > 0) {
      // Standard: capture all enemy-free enclosed regions
      claimRegions = noEnemyRegions;
    } else if (regions.length > 1) {
      // All regions have enemies â€” force-capture ONLY the smallest, relocate its enemy
      claimRegions = [regions[0]];
      const safeRegion = regions[regions.length - 1];
      if (safeRegion && safeRegion.cells.length > 0) {
        for (const e of this.enemies) {
          const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
          const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
          if (claimRegions[0].cells.some(c => c.r === er && c.c === ec)) {
            const target = safeRegion.cells[Phaser.Math.Between(0, safeRegion.cells.length - 1)];
            e.x = target.c * CELL + CELL / 2;
            e.y = target.r * CELL + CELL / 2;
          }
        }
      }
    } else {
      claimRegions = regions;
    }

    let gained = 0;
    for (const region of claimRegions) {
      for (const cell of region.cells) {
        if (this.grid[cell.r][cell.c] === 0) {
          this.grid[cell.r][cell.c] = 1;
          gained++;
        }
      }
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];

    if (gained > 0) {
      this.score += gained * 50 * this.stage;
      this.cameras.main.flash(300, 255, 255, 200);
      this.captureBurst();
    }

    this.updateClaimStats();
    this.redrawOverlay();

    if (this.percent >= TARGET_PERCENT) {
      this.explodeEnemiesAndClear();
    }
  }

  explodeEnemiesAndClear() {
    if (!this.enemies.length) {
      this.time.delayedCall(380, () => {
        this.scene.start('Clear', {
          stage: this.stage,
          score: this.score,
          lives: this.lives,
          percent: this.percent,
          bgKey: `bg${this.bgIdx}`
        });
      });
      return;
    }

    const enemyCount = this.enemies.length;
    this.enemies.forEach((e, idx) => {
      this.time.delayedCall(idx * 85, () => {
        const burst = this.add.particles(e.x, e.y, 'pixel', {
          speed: { min: 70, max: 240 },
          lifespan: 420,
          quantity: 26,
          scale: { start: 1.4, end: 0 },
          tint: [0xffd36e, 0xff7f6e, 0xffffff],
          blendMode: 'ADD'
        }).setDepth(9);
        this.time.delayedCall(430, () => burst.destroy());
      });
    });
    this.enemies = [];
    this.enemyBullets = [];

    this.time.delayedCall(enemyCount * 85 + 460, () => {
      this.scene.start('Clear', {
        stage: this.stage,
        score: this.score,
        lives: this.lives,
        percent: this.percent,
        bgKey: `bg${this.bgIdx}`
      });
    });
  }

  updateClaimStats() {
    let claimed = 0;
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] === 1) claimed++;
      }
    }
    this.claimedCells = claimed;
    this.percent = Math.floor((claimed / this.total) * 100);
    this.refreshHUD();
  }

  redrawOverlay() {
    this.overlayGfx.clear();

    // 1) dark mask for unrevealed area (very hidden before capture)
    this.overlayGfx.fillStyle(0x02030a, 0.965);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 0 || this.grid[r][c] === 2) {
          this.overlayGfx.fillRect(c * CELL, r * CELL, CELL, CELL);
        }
      }
    }

    // 2) silhouette-like contour glow on unrevealed area boundary
    this.overlayGfx.lineStyle(1.2, 0xbec6ff, 0.22);
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0) continue;
        const nearClaimed = this.grid[r-1][c] === 1 || this.grid[r+1][c] === 1 || this.grid[r][c-1] === 1 || this.grid[r][c+1] === 1;
        if (nearClaimed) {
          this.overlayGfx.strokeRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        }
      }
    }
  }

  updateEnemies(delta) {
    const dt = delta / 1000;
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    for (const e of this.enemies) {
      e.pulse += dt * 6;

      // behavior patterns
      if (e.kind === 'hunter' && this.isDrawing) {
        const dx = px - e.x;
        const dy = py - e.y;
        const d = Math.hypot(dx, dy) || 1;
        const aim = e.baseSpeed * 1.06;
        e.vx = (e.vx * 0.9) + (dx / d) * aim * 0.1;
        e.vy = (e.vy * 0.9) + (dy / d) * aim * 0.1;
      } else if (e.kind === 'zigzag') {
        const w = Math.sin(this.time.now * 0.006 + e.pulse) * 0.22;
        const vx = e.vx;
        e.vx = vx * Math.cos(w) - e.vy * Math.sin(w);
        e.vy = vx * Math.sin(w) + e.vy * Math.cos(w);
      }

      let nx = e.x + e.vx * dt;
      let ny = e.y + e.vy * dt;

      if (nx < CELL || nx > W - CELL) {
        e.vx *= -1;
        nx = Phaser.Math.Clamp(nx, CELL, W - CELL);
      }
      if (ny < CELL || ny > H - CELL) {
        e.vy *= -1;
        ny = Phaser.Math.Clamp(ny, CELL, H - CELL);
      }

      const testCell = (x, y) => {
        const rr = Phaser.Math.Clamp(Math.floor(y / CELL), 0, ROWS - 1);
        const cc = Phaser.Math.Clamp(Math.floor(x / CELL), 0, COLS - 1);
        return this.grid[rr][cc];
      };

      const hitX = testCell(nx + Math.sign(e.vx || 1) * e.radius, e.y) === 1;
      const hitY = testCell(e.x, ny + Math.sign(e.vy || 1) * e.radius) === 1;

      if (hitX) e.vx *= -1;
      if (hitY) e.vy *= -1;

      e.x += e.vx * dt;
      e.y += e.vy * dt;

      // stage-scaled shooting
      e.shootCd -= delta;
      if (e.shootCd <= 0) {
        const intervalBase = Math.max(320, 1600 - this.stage * 105);
        const bulletSpeed = CELL * (2.1 + this.stage * 0.22);
        this.fireEnemyBullet(e, bulletSpeed);
        e.shootCd = intervalBase + Phaser.Math.Between(-180, 180);
      }
    }
  }

  fireEnemyBullet(enemy, speed) {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const dx = px - enemy.x;
    const dy = py - enemy.y;
    const d = Math.hypot(dx, dy) || 1;
    this.enemyBullets.push({
      x: enemy.x,
      y: enemy.y,
      vx: (dx / d) * speed,
      vy: (dy / d) * speed,
      r: Math.min(4.5, 2.2 + this.stage * 0.14),
      life: 99999
    });
  }

  updateBullets(delta) {
    const dt = delta / 1000;
    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= delta;

      if (b.life <= 0 || b.x < -12 || b.x > W + 12 || b.y < -12 || b.y > H + 12) {
        this.enemyBullets.splice(i, 1);
      }
    }
  }

  checkCollisions() {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    for (const e of this.enemies) {
      const dist = Phaser.Math.Distance.Between(px, py, e.x, e.y);
      if (dist < e.radius + 5) {
        if (this.isDrawing) {
          this.playerDie();
          return;
        }
        // Shield: safe when not rushing
        continue;
      }

      if (this.isDrawing) {
        const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
        const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
        for (let rr = er - 1; rr <= er + 1; rr++) {
          for (let cc = ec - 1; cc <= ec + 1; cc++) {
            if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
            if (this.grid[rr][cc] === 2) {
              this.playerDie();
              return;
            }
          }
        }
      }
    }

    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      const dist = Phaser.Math.Distance.Between(px, py, b.x, b.y);
      if (dist < b.r + 6) {
        this.enemyBullets.splice(i, 1);
        if (this.isDrawing) {
          this.playerDie();
          return;
        }
        // Shield: bullet absorbed, no death
        continue;
      }
      if (this.isDrawing) {
        const br = Phaser.Math.Clamp(Math.floor(b.y / CELL), 0, ROWS - 1);
        const bc = Phaser.Math.Clamp(Math.floor(b.x / CELL), 0, COLS - 1);
        if (this.grid[br][bc] === 2) {
          this.enemyBullets.splice(i, 1);
          this.playerDie();
          return;
        }
      }
    }
  }

  findNearestClaimed(row, col) {
    let best = { row: 0, col: 0, d: Infinity };
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] !== 1) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (d < best.d) best = { row: r, col: c, d };
      }
    }
    return { row: best.row, col: best.col };
  }

  findNearestFrontier(row, col) {
    // Find nearest frontier cell (claimed + adjacent to unclaimed)
    let best = null;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!this.isFrontier(r, c)) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (!best || d < best.d) best = { row: r, col: c, d };
      }
    }
    // Fallback to any claimed cell if no frontier found
    return best || this.findNearestClaimed(row, col);
  }

  playerDie() {
    if (this.invuln > 0) return;

    this.lives--;
    this.cameras.main.shake(500, 0.02);
    this.cameras.main.flash(300, 255, 0, 0);

    for (const cell of this.trail) {
      if (this.grid[cell.row][cell.col] === 2) this.grid[cell.row][cell.col] = 0;
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];
    this.enemyBullets = [];
    this.redrawOverlay();

    if (this.lives <= 0) {
      this.scene.start('GameOver', { score: this.score, stage: this.stage });
      return;
    }

    const respawn = this.findNearestFrontier(this.playerRow, this.playerCol);
    this.playerRow = respawn.row;
    this.playerCol = respawn.col;
    this.invuln = 900;
    this.refreshHUD();
  }

  captureBurst() {
    if (!this.trail.length) return;
    let sr = 0;
    let sc = 0;
    for (const t of this.trail) {
      sr += t.row;
      sc += t.col;
    }
    const cx = (sc / this.trail.length) * CELL + CELL / 2;
    const cy = (sr / this.trail.length) * CELL + CELL / 2;

    const p = this.add.particles(cx, cy, 'pixel', {
      speed: { min: 40, max: 180 },
      lifespan: 380,
      quantity: 24,
      scale: { start: 1.5, end: 0 },
      tint: [0x9cfbff, 0xfff799, 0xff9fd6],
      blendMode: 'ADD'
    }).setDepth(9);

    this.time.delayedCall(420, () => p.destroy());
  }

  drawGrid() {
    this.claimedGfx.clear();
    this.trailGfx.clear();
    this.actorGfx.clear();

    this.claimedGfx.lineStyle(1, 0x3e9eff, 0.65);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 1 && (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1)) {
          this.claimedGfx.strokeRect(c * CELL + 0.5, r * CELL + 0.5, CELL - 1, CELL - 1);
        }
      }
    }

    // visually smoothed trail (curve-like feel over grid movement)
    this.trailGfx.lineStyle(4, 0x00ffff, 0.92);
    this.trailGfx.fillStyle(0x8affff, 0.38);
    let prev = null;
    for (const t of this.trail) {
      const cx = t.col * CELL + CELL / 2;
      const cy = t.row * CELL + CELL / 2;
      this.trailGfx.fillCircle(cx, cy, 4.5);
      if (prev) {
        this.trailGfx.beginPath();
        this.trailGfx.moveTo(prev.x, prev.y);
        this.trailGfx.lineTo(cx, cy);
        this.trailGfx.strokePath();
      }
      prev = { x: cx, y: cy };
    }

    for (const e of this.enemies) {
      const glow = 10 + Math.sin(e.pulse) * 3;
      this.actorGfx.fillStyle(0xff4f32, 0.18);
      this.actorGfx.fillCircle(e.x, e.y, glow);
      this.actorGfx.fillStyle(0xff7848, 0.85);
      this.actorGfx.fillCircle(e.x, e.y, e.radius);
      this.actorGfx.fillStyle(0xffd4a6, 0.65);
      this.actorGfx.fillCircle(e.x - 1.5, e.y - 1.5, 2);
      if (e.kind === 'hunter') {
        this.actorGfx.lineStyle(1.6, 0xffd7d7, 0.9);
        this.actorGfx.strokeCircle(e.x, e.y, e.radius + 2.5);
      } else if (e.kind === 'zigzag') {
        this.actorGfx.lineStyle(1.2, 0xffe4a8, 0.85);
        this.actorGfx.strokeTriangle(e.x, e.y - (e.radius + 2), e.x - (e.radius + 2), e.y + (e.radius + 2), e.x + (e.radius + 2), e.y + (e.radius + 2));
      } else {
        this.actorGfx.lineStyle(1.2, 0xffc9a2, 0.85);
        this.actorGfx.strokeRect(e.x - (e.radius + 2), e.y - (e.radius + 2), (e.radius + 2) * 2, (e.radius + 2) * 2);
      }
    }

    // enemy bullets
    this.actorGfx.fillStyle(0xfff47c, 0.95);
    for (const b of this.enemyBullets) {
      this.actorGfx.fillCircle(b.x, b.y, b.r);
    }

    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const blink = this.invuln > 0 ? (Math.floor(this.time.now / 80) % 2 === 0 ? 0.45 : 1) : 1;

    // high-contrast player marker
    this.actorGfx.lineStyle(2, 0x000000, 0.9 * blink);
    this.actorGfx.strokeCircle(px, py, 9);
    this.actorGfx.fillStyle(0x00ffff, 0.35 * blink);
    this.actorGfx.fillCircle(px, py, 9);
    this.actorGfx.fillStyle(0xffffff, 1 * blink);
    this.actorGfx.fillCircle(px, py, 5.2);
    this.actorGfx.fillStyle(0x0a0f1a, 0.95 * blink);
    this.actorGfx.fillCircle(px, py, 2.2);

    // Shield ring: visible when safe (not rushing)
    if (!this.isDrawing && this.invuln <= 0) {
      const sp = Math.sin(this.time.now * 0.006);
      const shieldR = 13 + sp * 2;
      this.actorGfx.lineStyle(2.4, 0x44ffdd, (0.55 + sp * 0.2) * blink);
      this.actorGfx.strokeCircle(px, py, shieldR);
      this.actorGfx.lineStyle(1, 0x88ffee, (0.2 + sp * 0.1) * blink);
      this.actorGfx.strokeCircle(px, py, shieldR + 4.5);
    }
  }
}

class ClearScene extends Phaser.Scene {
  constructor() { super('Clear'); }

  create(data) {
    const { stage = 1, score = 0, lives = 3, percent = 0, bgKey = null } = data;
    setUnlockedStage(stage + 1);

    const clearBonus = 2000 * stage;
    const totalScore = score + clearBonus;

    // â”€â”€ Background: show the stage image in full glory â”€â”€
    if (bgKey && this.textures.exists(bgKey)) {
      this.add.image(W / 2, H / 2, bgKey).setDisplaySize(W, H).setDepth(0);
    } else {
      this.add.rectangle(W / 2, H / 2, W, H, 0x0a0f1a).setDepth(0);
    }
    // subtle dark overlay so text is readable but bg still visible
    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.48).setDepth(1);

    // â”€â”€ Camera flash â”€â”€
    this.cameras.main.flash(600, 255, 220, 80);

    // â”€â”€ STAGE CLEAR! title â”€â”€
    const titleTxt = this.add.text(W / 2, 110, 'STAGE CLEAR!', {
      fontFamily: 'Verdana',
      fontSize: '46px',
      color: '#ffd56b',
      stroke: '#7a3800',
      strokeThickness: 7
    }).setOrigin(0.5).setAlpha(0).setScale(0.4).setDepth(2);

    this.tweens.add({
      targets: titleTxt,
      alpha: 1,
      scale: 1,
      duration: 420,
      ease: 'Back.Out',
      delay: 150
    });

    // â”€â”€ Confetti burst â”€â”€
    this.time.delayedCall(180, () => {
      const conf = this.add.particles(W / 2, 80, 'pixel', {
        speed: { min: 60, max: 240 },
        angle: { min: 190, max: 350 },
        gravityY: 260,
        lifespan: 1400,
        quantity: 5,
        scale: { start: 1.8, end: 0.1 },
        tint: [0xffd56b, 0xff7aa2, 0x7ce8ff, 0xa8ff78],
        blendMode: 'ADD'
      }).setDepth(10);
      this.time.delayedCall(2200, () => { if (conf.active) conf.stop(); });
    });

    // â”€â”€ CAPTURE % â€” big bounce animation â”€â”€
    const pctTxt = this.add.text(W / 2, 230, `${percent}%`, {
      fontFamily: 'Verdana',
      fontSize: '82px',
      color: '#ffffff',
      stroke: '#003366',
      strokeThickness: 10
    }).setOrigin(0.5).setAlpha(0).setScale(2.4).setDepth(2);

    this.tweens.add({
      targets: pctTxt,
      alpha: 1,
      scale: 1,
      duration: 500,
      ease: 'Back.Out',
      delay: 520,
      onComplete: () => {
        // pulse: big â†’ normal Ã— 2
        this.tweens.add({
          targets: pctTxt,
          scale: { from: 1, to: 1.22 },
          duration: 200,
          ease: 'Quad.InOut',
          yoyo: true,
          repeat: 1,
          delay: 100
        });
      }
    });

    const capLabel = this.add.text(W / 2, 285, 'CAPTURED', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#c8e8ff',
      stroke: '#001a33',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);
    this.tweens.add({ targets: capLabel, alpha: 1, duration: 300, delay: 700 });

    // â”€â”€ Star rating â”€â”€
    const stars = percent >= 95 ? 3 : percent >= 90 ? 2 : 1;
    const starSpacing = 58;
    const starY = 360;
    const starObjs = [];

    for (let i = 0; i < 3; i++) {
      const sx = W / 2 + (i - 1) * starSpacing;
      const starTxt = this.add.text(sx, starY, 'â˜…', {
        fontFamily: 'Verdana',
        fontSize: '48px',
        color: i < stars ? '#ffd700' : '#444466',
        stroke: i < stars ? '#a06000' : '#222233',
        strokeThickness: 5
      }).setOrigin(0.5).setAlpha(0).setScale(0).setDepth(2);
      starObjs.push(starTxt);
    }

    for (let i = 0; i < stars; i++) {
      const delay = 1100 + i * 340;
      ((idx, d) => {
        this.time.delayedCall(d, () => {
          // pop in with overshoot
          this.tweens.add({
            targets: starObjs[idx],
            alpha: 1,
            scale: { from: 0, to: 1 },
            duration: 320,
            ease: 'Back.Out'
          });
          // burst particles at star position
          const sx = W / 2 + (idx - 1) * starSpacing;
          const burst = this.add.particles(sx, starY, 'pixel', {
            speed: { min: 50, max: 160 },
            lifespan: 500,
            quantity: 16,
            scale: { start: 1.4, end: 0 },
            tint: [0xffd700, 0xfff0a0, 0xffaa00],
            blendMode: 'ADD'
          }).setDepth(9);
          this.time.delayedCall(520, () => { if (burst.active) burst.destroy(); });
        });
      })(i, delay);
    }

    // unearned stars fade in dim
    for (let i = stars; i < 3; i++) {
      this.time.delayedCall(1100 + i * 340, () => {
        this.tweens.add({ targets: starObjs[i], alpha: 0.55, scale: 1, duration: 280, ease: 'Back.Out' });
      });
    }

    // â”€â”€ Score row â”€â”€
    const scoreTxt = this.add.text(W / 2, 435, `SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffb4d8',
      stroke: '#330011',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const bonusTxt = this.add.text(W / 2, 462, `CLEAR BONUS: +${clearBonus}`, {
      fontFamily: 'Verdana',
      fontSize: '17px',
      color: '#9cfbff',
      stroke: '#001133',
      strokeThickness: 4
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    const totalTxt = this.add.text(W / 2, 491, `TOTAL: ${totalScore}`, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff',
      stroke: '#002244',
      strokeThickness: 5
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    this.tweens.add({ targets: [scoreTxt, bonusTxt, totalTxt], alpha: 1, duration: 360, delay: 2100 });

    // â”€â”€ Next button â”€â”€
    const nextLabel = (stage < STAGE_COUNT) ? 'NEXT STAGE' : 'BACK TO MENU';
    const btn = this.add.rectangle(W / 2, 548, 210, 48, 0x123966, 0.92)
      .setStrokeStyle(2, 0x7ce8ff, 1)
      .setInteractive({ useHandCursor: true })
      .setAlpha(0).setDepth(2);
    const btnTxt = this.add.text(W / 2, 548, nextLabel, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff'
    }).setOrigin(0.5).setAlpha(0).setDepth(2);

    this.tweens.add({ targets: [btn, btnTxt], alpha: 1, duration: 360, delay: 2500 });

    btn.on('pointerover', () => btn.setFillStyle(0x1d588f, 0.95));
    btn.on('pointerout', () => btn.setFillStyle(0x123966, 0.92));
    btn.on('pointerdown', () => {
      if (stage < STAGE_COUNT) {
        this.scene.start('Game', { stage: stage + 1, score: totalScore, lives });
      } else {
        this.scene.start('Menu');
      }
    });
  }
}

class GameOverScene extends Phaser.Scene {
  constructor() { super('GameOver'); }

  create(data) {
    const score = data.score || 0;

    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.86);
    this.add.text(W / 2, 122, 'GAME OVER', {
      fontFamily: 'Verdana',
      fontSize: '56px',
      color: '#ff6666',
      stroke: '#5c0000',
      strokeThickness: 8
    }).setOrigin(0.5);

    this.add.text(W / 2, 190, `FINAL SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '22px',
      color: '#ffffff'
    }).setOrigin(0.5);

    const makeButton = (x, y, label, onClick) => {
      const b = this.add.rectangle(x, y, 150, 42, 0x2a1e48, 0.95)
        .setStrokeStyle(2, 0xff7ab6, 1)
        .setInteractive({ useHandCursor: true });
      this.add.text(x, y, label, {
        fontFamily: 'Verdana',
        fontSize: '20px',
        color: '#ffffff'
      }).setOrigin(0.5);
      b.on('pointerover', () => b.setFillStyle(0x3b2b66, 0.95));
      b.on('pointerout', () => b.setFillStyle(0x2a1e48, 0.95));
      b.on('pointerdown', onClick);
    };

    makeButton(W / 2 - 84, 266, 'RETRY', () => {
      this.scene.start('Game', { stage: 1, score: 0, lives: 3 });
    });

    makeButton(W / 2 + 84, 266, 'MENU', () => {
      this.scene.start('Menu');
    });
  }
}

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  parent: 'game',
  backgroundColor: '#1a0a2e',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: [BootScene, MenuScene, GameScene, ClearScene, GameOverScene]
};

new Phaser.Game(config);

// â”€â”€ ìºë¦­í„° ë§ˆìŠ¤ì½”íŠ¸ ì˜¤ë²„ë ˆì´ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ì„¸ì…˜ë§ˆë‹¤ ëžœë¤ ë™ë¬¼ ìºë¦­í„° 1ìž¥ ì„ íƒ, ì¢Œì¸¡ í•˜ë‹¨ ì´ˆìƒí™”ë¡œ í‘œì‹œ
(function () {
  const CHAR_COUNT = 10;
  const idx = Math.floor(Math.random() * CHAR_COUNT) + 1;

  const wrap = document.createElement('div');
  wrap.id = 'lr-char';
  wrap.style.cssText = [
    'position:fixed', 'bottom:18px', 'left:14px', 'z-index:200',
    'pointer-events:none', 'filter:drop-shadow(0 0 8px rgba(80,220,255,0.7))',
    'transition:opacity .4s', 'opacity:0',
  ].join(';');

  const img = document.createElement('img');
  img.src = `img/char${idx}.jpg`;
  img.style.cssText = [
    'width:68px', 'height:68px', 'border-radius:50%',
    'border:3px solid rgba(100,230,255,0.75)',
    'display:block', 'object-fit:cover',
  ].join(';');
  img.onload  = () => { wrap.style.opacity = '1'; };
  img.onerror = () => { wrap.style.display = 'none'; };

  wrap.appendChild(img);
  document.body.appendChild(wrap);
})();
</script>
</body>
</html>
