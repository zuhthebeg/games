<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Line Rush</title>
  <script src="./phaser.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; display: flex; justify-content: center; align-items: center; min-height: 100dvh; overflow: hidden; font-family: 'Trebuchet MS', sans-serif; }
    #game { width: 100vw; height: 100dvh; display: flex; justify-content: center; align-items: center; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
<div id="game"></div>
<script>
window.addEventListener('error', (e) => {
  const msg = document.createElement('div');
  msg.style.cssText = 'position:fixed;left:12px;right:12px;top:12px;z-index:99999;background:#300;color:#fff;padding:10px 12px;border-radius:8px;font:12px/1.4 sans-serif';
  msg.textContent = 'Line Rush ë¡œë”© ì˜¤ë¥˜: ' + (e.message || 'unknown');
  document.body.appendChild(msg);
});
const STAGE_COUNT = 10;
const STORAGE_UNLOCK_KEY = 'linerush_unlocked_stage';
const COLS = 26;
const ROWS = 38;
const CELL = 16;
const W = COLS * CELL;
const H = ROWS * CELL;
const TARGET_PERCENT = 80;

function getUnlockedStage() {
  try {
    const v = Number(localStorage.getItem(STORAGE_UNLOCK_KEY) || '1');
    return Math.min(STAGE_COUNT, Math.max(1, Number.isFinite(v) ? v : 1));
  } catch (_) {
    return 1;
  }
}

function setUnlockedStage(stage) {
  try {
    const next = Math.min(STAGE_COUNT, Math.max(getUnlockedStage(), stage));
    localStorage.setItem(STORAGE_UNLOCK_KEY, String(next));
  } catch (_) {}
}

class BootScene extends Phaser.Scene {
  constructor() { super('Boot'); }

  preload() {
    for (let s = 1; s <= STAGE_COUNT; s++) {
      this.load.image(`stage${s}_real`, `/linerush/img/stage${s}.jpg`);
    }
  }

  create() {
    const white = this.make.graphics({ x: 0, y: 0, add: false });
    white.fillStyle(0xffffff, 1);
    white.fillRect(0, 0, 2, 2);
    white.generateTexture('pixel', 2, 2);
    white.destroy();

    const palettes = [
      [0xff6b9d, 0xffa8c4],
      [0x7e57c2, 0x5dade2],
      [0xf39c12, 0xffd700],
      [0x2ecc71, 0x27ae60],
      [0x00c2ff, 0x3f5efb],
      [0xff4d6d, 0xff9e00],
      [0x8e44ad, 0xe056fd],
      [0x16a085, 0x48dbfb],
      [0xe67e22, 0xf1c40f],
      [0x34495e, 0x6c5ce7]
    ];

    for (let s = 1; s <= STAGE_COUNT; s++) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      const [c1, c2] = palettes[(s - 1) % palettes.length];
      g.fillGradientStyle(c1, c1, c2, c2, 1);
      g.fillRect(0, 0, W, H);

      g.fillStyle(0x000000, 0.24);
      g.fillCircle(W * 0.5, H * 0.24, 38);
      g.fillRoundedRect(W * 0.5 - 42, H * 0.32, 84, 140, 32);
      g.fillEllipse(W * 0.44, H * 0.77, 42, 84);
      g.fillEllipse(W * 0.56, H * 0.77, 42, 84);

      g.fillStyle(0xffffff, 0.08);
      g.fillCircle(W * 0.66, H * 0.21, 54);
      g.fillCircle(W * 0.31, H * 0.68, 72);

      g.generateTexture(`stage${s}_placeholder`, W, H);
      g.destroy();
    }

    this.scene.start('Menu');
  }
}

class MenuScene extends Phaser.Scene {
  constructor() { super('Menu'); }

  create() {
    const bg = this.add.graphics();
    bg.fillGradientStyle(0x120320, 0x120320, 0x220833, 0x220833, 1);
    bg.fillRect(0, 0, W, H);

    this.add.text(W / 2, 48, 'LINE RUSH', {
      fontFamily: 'Verdana',
      fontSize: '42px',
      color: '#ff79c6',
      stroke: '#ff2ea6',
      strokeThickness: 8
    }).setOrigin(0.5).setShadow(0, 0, '#ff2ea6', 24, true, true);

    this.add.text(W / 2, 96, 'STAGE SELECT', {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#99e9ff',
      stroke: '#133052',
      strokeThickness: 5
    }).setOrigin(0.5);

    const unlockedStage = getUnlockedStage();
    for (let s = 1; s <= STAGE_COUNT; s++) {
      const cols = 2;
      const row = Math.floor((s - 1) / cols);
      const col = (s - 1) % cols;
      const x = 104 + col * 208;
      const y = 178 + row * 82;
      const isLocked = s > unlockedStage;
      const frame = this.add.rectangle(x, y, 188, 72, 0x03030a, isLocked ? 0.45 : 0.7).setStrokeStyle(2, isLocked ? 0x4a4f65 : 0x59e3ff, 0.9);
      const hiddenThumb = this.add.rectangle(x - 52, y, 58, 66, isLocked ? 0x0d0f19 : 0x111425, 0.95)
        .setStrokeStyle(2, isLocked ? 0x3a3f58 : 0x59648a, 0.9);
      this.add.text(x - 52, y, isLocked ? 'ðŸ”’' : '?', {
        fontFamily: 'Verdana',
        fontSize: '30px',
        color: isLocked ? '#9299bd' : '#cfd6ff',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5);
      const label = this.add.text(x + 20, y, `STAGE ${s}`, {
        fontFamily: 'Verdana',
        fontSize: '18px',
        color: isLocked ? '#8a90aa' : '#ffffff',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5);

      const hit = this.add.zone(x, y, 188, 72).setOrigin(0.5).setInteractive({ useHandCursor: !isLocked });
      hit.on('pointerover', () => {
        if (isLocked) return;
        frame.setFillStyle(0x081235, 0.85);
        label.setScale(1.05);
      });
      hit.on('pointerout', () => {
        frame.setFillStyle(0x03030a, isLocked ? 0.45 : 0.7);
        label.setScale(1);
      });
      hit.on('pointerdown', () => {
        if (isLocked) return;
        this.scene.start('Game', { stage: s, score: 0, lives: 3 });
      });

      hiddenThumb.setAlpha(0.95);
    }

    this.add.text(W / 2, H - 24, 'Capture 80% to clear the stage', {
      fontFamily: 'Verdana',
      fontSize: '14px',
      color: '#aacfff'
    }).setOrigin(0.5);
  }
}

class GameScene extends Phaser.Scene {
  constructor() {
    super('Game');
  }

  create(data) {
    this.stage = data.stage || 1;
    this.score = data.score || 0;
    this.lives = (typeof data.lives === 'number') ? data.lives : 3;
    this.claimedCells = 0;
    this.total = (COLS - 2) * (ROWS - 2);
    this.percent = 0;

    this.grid = [];
    for (let r = 0; r < ROWS; r++) {
      this.grid[r] = [];
      for (let c = 0; c < COLS; c++) {
        this.grid[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
      }
    }

    const key = this.textures.exists(`stage${this.stage}_real`) ? `stage${this.stage}_real` : `stage${this.stage}_placeholder`;
    this.bgImage = this.add.image(W / 2, H / 2, key).setDepth(0).setDisplaySize(W, H);

    this.overlayGfx = this.add.graphics().setDepth(1);
    this.claimedGfx = this.add.graphics().setDepth(2);
    this.trailGfx = this.add.graphics().setDepth(3).setBlendMode(Phaser.BlendModes.ADD);
    this.actorGfx = this.add.graphics().setDepth(4);

    this.playerRow = 0;
    this.playerCol = Math.floor(COLS / 2);
    this.trail = [];
    this.isDrawing = false;
    this.drawStart = null;
    this.retracting = false;
    this.moveTimer = 0;
    this.moveDelay = 120;
    this.retractSpeedMul = 1.5;
    this.invuln = 0;

    const enemyCount = Math.min(8, this.stage + 1);
    this.enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      const baseSpeed = CELL * (0.9 + this.stage * 0.32 + i * 0.03);
      const kind = (i % 3 === 0) ? 'hunter' : (i % 3 === 1 ? 'zigzag' : 'bouncer');
      this.enemies.push({
        x: Phaser.Math.FloatBetween(CELL * 2, W - CELL * 2),
        y: Phaser.Math.FloatBetween(CELL * 2, H - CELL * 2),
        vx: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        vy: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
        baseSpeed,
        kind,
        radius: kind === 'hunter' ? 6.6 : 6,
        pulse: Math.random() * Math.PI * 2
      });
    }

    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.touchAxis = { x: 0, y: 0 };
    this.createTouchControls();

    this.createHUD();
    this.updateClaimStats();
    this.redrawOverlay();
    this.drawGrid();
  }

  createTouchControls() {
    const isTouch = this.sys.game.device.input.touch;
    if (!isTouch) return;

    const joyCenter = { x: W - 64, y: H - 64 };
    const joyRadius = 42;
    const knobRadius = 18;

    this.joyBase = this.add.circle(joyCenter.x, joyCenter.y, joyRadius, 0x001a2e, 0.42)
      .setStrokeStyle(2, 0x63d9ff, 0.9).setDepth(20).setScrollFactor(0);
    this.joyKnob = this.add.circle(joyCenter.x, joyCenter.y, knobRadius, 0x39c6ff, 0.75)
      .setStrokeStyle(2, 0xb8f1ff, 0.95).setDepth(21).setScrollFactor(0);

    const joyZone = this.add.zone(joyCenter.x, joyCenter.y, joyRadius * 2.3, joyRadius * 2.3)
      .setOrigin(0.5).setDepth(22).setScrollFactor(0).setInteractive();

    let joyPointerId = null;

    const resetStick = () => {
      this.touchAxis.x = 0;
      this.touchAxis.y = 0;
      this.joyKnob.setPosition(joyCenter.x, joyCenter.y);
      joyPointerId = null;
    };

    const updateStick = (pointer) => {
      const dx = pointer.x - joyCenter.x;
      const dy = pointer.y - joyCenter.y;
      const dist = Math.hypot(dx, dy) || 1;
      const clamped = Math.min(joyRadius, dist);
      const nx = dx / dist;
      const ny = dy / dist;
      this.joyKnob.setPosition(joyCenter.x + nx * clamped, joyCenter.y + ny * clamped);
      this.touchAxis.x = nx * (clamped / joyRadius);
      this.touchAxis.y = ny * (clamped / joyRadius);
    };

    joyZone.on('pointerdown', (p) => {
      joyPointerId = p.id;
      updateStick(p);
    });

    this.input.on('pointermove', (p) => {
      if (joyPointerId === null || p.id !== joyPointerId || !p.isDown) return;
      updateStick(p);
    });

    this.input.on('pointerup', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });

    joyZone.on('pointerout', (p) => {
      // keep moving even if finger leaves circle; release on pointerup only
      if (joyPointerId === null || p.id !== joyPointerId) return;
    });
    joyZone.on('pointerupoutside', (p) => {
      if (joyPointerId !== null && p.id === joyPointerId) resetStick();
    });
  }

  createHUD() {
    this.hudBg = this.add.rectangle(W / 2, 16, W, 32, 0x000000, 0.45).setDepth(10);
    this.hudLives = this.add.text(12, 8, '', {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#ffffff'
    }).setDepth(11);
    this.hudStage = this.add.text(W / 2 - 68, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#7de5ff'
    }).setDepth(11);
    this.hudPercent = this.add.text(W / 2 + 14, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#fff176'
    }).setDepth(11);
    this.hudScore = this.add.text(W - 12, 9, '', {
      fontFamily: 'Verdana',
      fontSize: '16px',
      color: '#ffb4d8'
    }).setOrigin(1, 0).setDepth(11);

    this.refreshHUD();
  }

  refreshHUD() {
    this.hudLives.setText('â¤ï¸'.repeat(this.lives));
    this.hudStage.setText(`STAGE ${this.stage}`);
    this.hudPercent.setText(`${this.percent}%`);
    this.hudScore.setText(`SCORE: ${this.score}`);
  }

  update(time, delta) {
    this.moveTimer += delta;

    if (this.moveTimer >= this.moveDelay) {
      this.handleInput();
      this.moveTimer = 0;
    }

    if (this.invuln > 0) {
      this.invuln -= delta;
    }

    this.updateEnemies(delta);
    if (this.invuln <= 0) {
      this.checkCollisions();
    }

    this.drawGrid();
  }

  handleInput() {
    let dr = 0;
    let dc = 0;

    const axisX = this.touchAxis?.x || 0;
    const axisY = this.touchAxis?.y || 0;

    if (this.cursors.left.isDown || this.wasd.A.isDown) dc = -1;
    else if (this.cursors.right.isDown || this.wasd.D.isDown) dc = 1;
    else if (this.cursors.up.isDown || this.wasd.W.isDown) dr = -1;
    else if (this.cursors.down.isDown || this.wasd.S.isDown) dr = 1;
    else {
      if (Math.abs(axisX) > Math.abs(axisY) && Math.abs(axisX) > 0.25) dc = axisX < 0 ? -1 : 1;
      else if (Math.abs(axisY) > 0.25) dr = axisY < 0 ? -1 : 1;
    }

    if (dr === 0 && dc === 0) return;

    const nr = this.playerRow + dr;
    const nc = this.playerCol + dc;

    if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;

    const next = this.grid[nr][nc];
    if (next === 2) {
      this.playerDie();
      return;
    }

    if (next === 0) {
      if (!this.isDrawing) {
        this.isDrawing = true;
        this.trail = [];
      }

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }

      this.playerRow = nr;
      this.playerCol = nc;

      if (this.grid[this.playerRow][this.playerCol] === 0) {
        this.grid[this.playerRow][this.playerCol] = 2;
        this.trail.push({ row: this.playerRow, col: this.playerCol });
      }
      return;
    }

    if (next === 1) {
      this.playerRow = nr;
      this.playerCol = nc;
      if (this.isDrawing) {
        this.captureTerritory();
      }
    }
  }

  stepRetreat() {
    if (!this.trail.length) {
      this.retracting = false;
      this.isDrawing = false;
      if (this.drawStart) {
        this.playerRow = this.drawStart.row;
        this.playerCol = this.drawStart.col;
      }
      this.drawStart = null;
      return;
    }

    const removed = this.trail.pop();
    if (this.grid[removed.row][removed.col] === 2) {
      this.grid[removed.row][removed.col] = 0;
    }

    if (this.trail.length) {
      const back = this.trail[this.trail.length - 1];
      this.playerRow = back.row;
      this.playerCol = back.col;
    } else if (this.drawStart) {
      this.playerRow = this.drawStart.row;
      this.playerCol = this.drawStart.col;
      this.retracting = false;
      this.isDrawing = false;
      this.drawStart = null;
    }

    this.redrawOverlay();
  }

  captureTerritory() {
    for (const cell of this.trail) {
      this.grid[cell.row][cell.col] = 1;
    }

    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    const regions = [];

    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0 || visited[r][c]) continue;

        const queue = [{ r, c }];
        visited[r][c] = true;
        const cells = [];
        let hasEnemy = false;

        while (queue.length) {
          const cur = queue.shift();
          cells.push(cur);

          for (const e of this.enemies) {
            const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
            const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
            if (er === cur.r && ec === cur.c) {
              hasEnemy = true;
              break;
            }
          }

          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          for (const [dr, dc] of dirs) {
            const nr = cur.r + dr;
            const nc = cur.c + dc;
            if (nr < 1 || nr >= ROWS - 1 || nc < 1 || nc >= COLS - 1) continue;
            if (visited[nr][nc]) continue;
            if (this.grid[nr][nc] !== 0) continue;
            visited[nr][nc] = true;
            queue.push({ r: nr, c: nc });
          }
        }

        regions.push({ cells, hasEnemy });
      }
    }

    const claimRegions = regions.filter((r) => !r.hasEnemy);

    let gained = 0;
    for (const region of claimRegions) {
      for (const cell of region.cells) {
        if (this.grid[cell.r][cell.c] === 0) {
          this.grid[cell.r][cell.c] = 1;
          gained++;
        }
      }
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];

    if (gained > 0) {
      this.score += gained * 50 * this.stage;
      this.cameras.main.flash(300, 255, 255, 200);
      this.captureBurst();
    }

    this.updateClaimStats();
    this.redrawOverlay();

    if (this.percent >= TARGET_PERCENT) {
      this.time.delayedCall(450, () => {
        this.scene.start('Clear', {
          stage: this.stage,
          score: this.score,
          lives: this.lives,
          percent: this.percent
        });
      });
    }
  }

  updateClaimStats() {
    let claimed = 0;
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] === 1) claimed++;
      }
    }
    this.claimedCells = claimed;
    this.percent = Math.floor((claimed / this.total) * 100);
    this.refreshHUD();
  }

  redrawOverlay() {
    this.overlayGfx.clear();

    // 1) dark mask for unrevealed area (almost hidden before capture)
    this.overlayGfx.fillStyle(0x05060b, 0.9);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 0 || this.grid[r][c] === 2) {
          this.overlayGfx.fillRect(c * CELL, r * CELL, CELL, CELL);
        }
      }
    }

    // 2) silhouette-like contour glow on unrevealed area boundary
    this.overlayGfx.lineStyle(1.2, 0xbec6ff, 0.22);
    for (let r = 1; r < ROWS - 1; r++) {
      for (let c = 1; c < COLS - 1; c++) {
        if (this.grid[r][c] !== 0) continue;
        const nearClaimed = this.grid[r-1][c] === 1 || this.grid[r+1][c] === 1 || this.grid[r][c-1] === 1 || this.grid[r][c+1] === 1;
        if (nearClaimed) {
          this.overlayGfx.strokeRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        }
      }
    }
  }

  updateEnemies(delta) {
    const dt = delta / 1000;
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    for (const e of this.enemies) {
      e.pulse += dt * 6;

      // behavior patterns
      if (e.kind === 'hunter' && (this.isDrawing || this.retracting)) {
        const dx = px - e.x;
        const dy = py - e.y;
        const d = Math.hypot(dx, dy) || 1;
        const aim = e.baseSpeed * 1.06;
        e.vx = (e.vx * 0.9) + (dx / d) * aim * 0.1;
        e.vy = (e.vy * 0.9) + (dy / d) * aim * 0.1;
      } else if (e.kind === 'zigzag') {
        const w = Math.sin(this.time.now * 0.006 + e.pulse) * 0.22;
        const vx = e.vx;
        e.vx = vx * Math.cos(w) - e.vy * Math.sin(w);
        e.vy = vx * Math.sin(w) + e.vy * Math.cos(w);
      }

      let nx = e.x + e.vx * dt;
      let ny = e.y + e.vy * dt;

      if (nx < CELL || nx > W - CELL) {
        e.vx *= -1;
        nx = Phaser.Math.Clamp(nx, CELL, W - CELL);
      }
      if (ny < CELL || ny > H - CELL) {
        e.vy *= -1;
        ny = Phaser.Math.Clamp(ny, CELL, H - CELL);
      }

      const testCell = (x, y) => {
        const rr = Phaser.Math.Clamp(Math.floor(y / CELL), 0, ROWS - 1);
        const cc = Phaser.Math.Clamp(Math.floor(x / CELL), 0, COLS - 1);
        return this.grid[rr][cc];
      };

      const hitX = testCell(nx + Math.sign(e.vx || 1) * e.radius, e.y) === 1;
      const hitY = testCell(e.x, ny + Math.sign(e.vy || 1) * e.radius) === 1;

      if (hitX) e.vx *= -1;
      if (hitY) e.vy *= -1;

      e.x += e.vx * dt;
      e.y += e.vy * dt;
    }
  }

  checkCollisions() {
    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;

    for (const e of this.enemies) {
      const dist = Phaser.Math.Distance.Between(px, py, e.x, e.y);
      if (dist < e.radius + 5) {
        this.playerDie();
        return;
      }

      if (this.isDrawing) {
        const er = Phaser.Math.Clamp(Math.floor(e.y / CELL), 0, ROWS - 1);
        const ec = Phaser.Math.Clamp(Math.floor(e.x / CELL), 0, COLS - 1);
        for (let rr = er - 1; rr <= er + 1; rr++) {
          for (let cc = ec - 1; cc <= ec + 1; cc++) {
            if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
            if (this.grid[rr][cc] === 2) {
              this.playerDie();
              return;
            }
          }
        }
      }
    }
  }

  findNearestClaimed(row, col) {
    let best = { row: 0, col: 0, d: Infinity };
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] !== 1) continue;
        const d = Math.abs(r - row) + Math.abs(c - col);
        if (d < best.d) best = { row: r, col: c, d };
      }
    }
    return { row: best.row, col: best.col };
  }

  playerDie() {
    if (this.invuln > 0) return;

    this.lives--;
    this.cameras.main.shake(500, 0.02);
    this.cameras.main.flash(300, 255, 0, 0);

    for (const cell of this.trail) {
      if (this.grid[cell.row][cell.col] === 2) this.grid[cell.row][cell.col] = 0;
    }

    this.isDrawing = false;
    this.retracting = false;
    this.drawStart = null;
    this.trail = [];
    this.redrawOverlay();

    if (this.lives <= 0) {
      this.scene.start('GameOver', { score: this.score, stage: this.stage });
      return;
    }

    const respawn = this.findNearestClaimed(this.playerRow, this.playerCol);
    this.playerRow = respawn.row;
    this.playerCol = respawn.col;
    this.invuln = 900;
    this.refreshHUD();
  }

  captureBurst() {
    if (!this.trail.length) return;
    let sr = 0;
    let sc = 0;
    for (const t of this.trail) {
      sr += t.row;
      sc += t.col;
    }
    const cx = (sc / this.trail.length) * CELL + CELL / 2;
    const cy = (sr / this.trail.length) * CELL + CELL / 2;

    const p = this.add.particles(cx, cy, 'pixel', {
      speed: { min: 40, max: 180 },
      lifespan: 380,
      quantity: 24,
      scale: { start: 1.5, end: 0 },
      tint: [0x9cfbff, 0xfff799, 0xff9fd6],
      blendMode: 'ADD'
    }).setDepth(9);

    this.time.delayedCall(420, () => p.destroy());
  }

  drawGrid() {
    this.claimedGfx.clear();
    this.trailGfx.clear();
    this.actorGfx.clear();

    this.claimedGfx.lineStyle(1, 0x3e9eff, 0.65);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.grid[r][c] === 1 && (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1)) {
          this.claimedGfx.strokeRect(c * CELL + 0.5, r * CELL + 0.5, CELL - 1, CELL - 1);
        }
      }
    }

    this.trailGfx.fillStyle(0x00ffff, 0.35);
    this.trailGfx.lineStyle(2, 0x00ffff, 1);
    for (const t of this.trail) {
      this.trailGfx.fillRect(t.col * CELL + 2, t.row * CELL + 2, CELL - 4, CELL - 4);
      this.trailGfx.strokeRect(t.col * CELL + 2, t.row * CELL + 2, CELL - 4, CELL - 4);
    }

    for (const e of this.enemies) {
      const glow = 10 + Math.sin(e.pulse) * 3;
      this.actorGfx.fillStyle(0xff4f32, 0.18);
      this.actorGfx.fillCircle(e.x, e.y, glow);
      this.actorGfx.fillStyle(0xff7848, 0.85);
      this.actorGfx.fillCircle(e.x, e.y, e.radius);
      this.actorGfx.fillStyle(0xffd4a6, 0.65);
      this.actorGfx.fillCircle(e.x - 1.5, e.y - 1.5, 2);
    }

    const px = this.playerCol * CELL + CELL / 2;
    const py = this.playerRow * CELL + CELL / 2;
    const blink = this.invuln > 0 ? (Math.floor(this.time.now / 80) % 2 === 0 ? 0.45 : 1) : 1;

    // high-contrast player marker
    this.actorGfx.lineStyle(2, 0x000000, 0.9 * blink);
    this.actorGfx.strokeCircle(px, py, 9);
    this.actorGfx.fillStyle(0x00ffff, 0.35 * blink);
    this.actorGfx.fillCircle(px, py, 9);
    this.actorGfx.fillStyle(0xffffff, 1 * blink);
    this.actorGfx.fillCircle(px, py, 5.2);
    this.actorGfx.fillStyle(0x0a0f1a, 0.95 * blink);
    this.actorGfx.fillCircle(px, py, 2.2);
  }
}

class ClearScene extends Phaser.Scene {
  constructor() { super('Clear'); }

  create(data) {
    const { stage = 1, score = 0, lives = 3, percent = 0 } = data;
    setUnlockedStage(stage + 1);
    this.cameras.main.flash(500, 255, 200, 0);

    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.72);
    this.add.text(W / 2, 104, 'STAGE CLEAR!', {
      fontFamily: 'Verdana',
      fontSize: '52px',
      color: '#ffd56b',
      stroke: '#9c4d00',
      strokeThickness: 8
    }).setOrigin(0.5);

    this.add.text(W / 2, 180, `STAGE ${stage}  |  CAPTURE ${percent}%`, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff'
    }).setOrigin(0.5);

    this.add.text(W / 2, 214, `SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffb4d8'
    }).setOrigin(0.5);

    const clearBonus = 2000 * stage;
    this.add.text(W / 2, 244, `CLEAR BONUS: +${clearBonus}`, {
      fontFamily: 'Verdana',
      fontSize: '18px',
      color: '#9cfbff'
    }).setOrigin(0.5);

    const totalScore = score + clearBonus;

    const p = this.add.particles(W / 2, 82, 'pixel', {
      speed: { min: 40, max: 190 },
      angle: { min: 200, max: 340 },
      gravityY: 180,
      lifespan: 1100,
      quantity: 3,
      scale: { start: 1.4, end: 0.1 },
      tint: [0xffd56b, 0xff7aa2, 0x7ce8ff],
      blendMode: 'ADD'
    });

    const nextLabel = (stage < STAGE_COUNT) ? 'NEXT STAGE' : 'BACK TO MENU';
    const btn = this.add.rectangle(W / 2, 300, 200, 44, 0x123966, 0.92)
      .setStrokeStyle(2, 0x7ce8ff, 1)
      .setInteractive({ useHandCursor: true });
    const txt = this.add.text(W / 2, 300, nextLabel, {
      fontFamily: 'Verdana',
      fontSize: '20px',
      color: '#ffffff'
    }).setOrigin(0.5);

    btn.on('pointerover', () => btn.setFillStyle(0x1d588f, 0.95));
    btn.on('pointerout', () => btn.setFillStyle(0x123966, 0.92));
    btn.on('pointerdown', () => {
      p.destroy();
      if (stage < STAGE_COUNT) {
        this.scene.start('Game', { stage: stage + 1, score: totalScore, lives });
      } else {
        this.scene.start('Menu');
      }
    });

    this.time.delayedCall(3000, () => {
      if (p.active) p.stop();
    });
  }
}

class GameOverScene extends Phaser.Scene {
  constructor() { super('GameOver'); }

  create(data) {
    const score = data.score || 0;

    this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.86);
    this.add.text(W / 2, 122, 'GAME OVER', {
      fontFamily: 'Verdana',
      fontSize: '56px',
      color: '#ff6666',
      stroke: '#5c0000',
      strokeThickness: 8
    }).setOrigin(0.5);

    this.add.text(W / 2, 190, `FINAL SCORE: ${score}`, {
      fontFamily: 'Verdana',
      fontSize: '22px',
      color: '#ffffff'
    }).setOrigin(0.5);

    const makeButton = (x, y, label, onClick) => {
      const b = this.add.rectangle(x, y, 150, 42, 0x2a1e48, 0.95)
        .setStrokeStyle(2, 0xff7ab6, 1)
        .setInteractive({ useHandCursor: true });
      this.add.text(x, y, label, {
        fontFamily: 'Verdana',
        fontSize: '20px',
        color: '#ffffff'
      }).setOrigin(0.5);
      b.on('pointerover', () => b.setFillStyle(0x3b2b66, 0.95));
      b.on('pointerout', () => b.setFillStyle(0x2a1e48, 0.95));
      b.on('pointerdown', onClick);
    };

    makeButton(W / 2 - 84, 266, 'RETRY', () => {
      this.scene.start('Game', { stage: 1, score: 0, lives: 3 });
    });

    makeButton(W / 2 + 84, 266, 'MENU', () => {
      this.scene.start('Menu');
    });
  }
}

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  parent: 'game',
  backgroundColor: '#1a0a2e',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: [BootScene, MenuScene, GameScene, ClearScene, GameOverScene]
};

new Phaser.Game(config);
</script>
</body>
</html>
