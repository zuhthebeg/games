<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MV8KQGJF');</script>
<!-- End Google Tag Manager -->

    <title>삼인 사목 - Connect 4</title>
    <link rel="icon" href="icon.svg">
    <script src="/lib/shared-wallet.js?v=20260214"></script>
    <style>
        :root {
            --bg: #1e1e2e;
            --board: #1e40af;
            --board-dark: #1e3a8a;
            --text: #eee;
            --accent: #4ecca3;
            --red: #ef4444;
            --yellow: #eab308;
            --blue: #3b82f6;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding-top: calc(48px + env(safe-area-inset-top)); /* SharedWallet bar */
        }

        #app { min-height: 100vh; }

        .game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            min-height: 100vh;
        }

        .players-bar {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 16px;
            width: 100%;
            max-width: 500px;
        }

        .player-tag {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(255,255,255,0.05);
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .player-tag.active {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        .player-tag.red.active { background: var(--red); color: #fff; }
        .player-tag.yellow.active { background: var(--yellow); color: #000; }
        .player-tag.blue.active { background: var(--blue); color: #fff; }

        .player-tag .disc {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .disc.red { background: var(--red); }
        .disc.yellow { background: var(--yellow); }
        .disc.blue { background: var(--blue); }

        .board-container {
            position: relative;
            width: 100%;
            max-width: 520px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            background: linear-gradient(145deg, var(--board), var(--board-dark));
            padding: 12px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .cell {
            aspect-ratio: 1;
            background: var(--bg);
            border-radius: 50%;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
        }

        .cell.clickable {
            cursor: pointer;
            transition: background 0.2s;
        }

        .cell.clickable:hover {
            background: rgba(255,255,255,0.15);
        }

        .cell .piece {
            position: absolute;
            inset: 8%;
            border-radius: 50%;

            animation: pop 0.2s ease-out;
        }

        @keyframes pop {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        .piece.red { 
            background: radial-gradient(circle at 30% 30%, #f87171, var(--red)); 
            box-shadow: 0 2px 8px rgba(239,68,68,0.5);
        }
        .piece.yellow { 
            background: radial-gradient(circle at 30% 30%, #fde047, var(--yellow)); 
            box-shadow: 0 2px 8px rgba(234,179,8,0.5);
        }
        .piece.blue { 
            background: radial-gradient(circle at 30% 30%, #60a5fa, var(--blue)); 
            box-shadow: 0 2px 8px rgba(59,130,246,0.5);
        }

        .piece.win {
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            to { transform: scale(1.1); box-shadow: 0 0 20px currentColor; }
        }

        .game-status {
            text-align: center;
            padding: 16px;
            font-size: 1.1rem;
        }

        .game-actions {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            color: var(--text);
            transition: all 0.2s;
        }

        .btn:hover { background: rgba(255,255,255,0.2); }
        .btn.primary { background: var(--accent); color: #000; }

        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 20px;
            border-radius: 20px;
            background: rgba(255,255,255,0.05);
            margin-bottom: 16px;
        }

        .turn-indicator .disc {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            animation: bounce 0.5s ease-in-out infinite alternate;
        }

        @keyframes bounce {
            to { transform: translateY(-4px); }
        }
    </style>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MV8KQGJF" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

    <div id="app"></div>

    <script src="/lib/multiplayer.js?v=20260210v2"></script>
    <script src="/lib/multiplayer-ui.js?v=20260210v2"></script>
    <script>
        // ===== Constants =====
        const COLS = 10;
        const ROWS = 9;
        const COLORS = ['red', 'yellow', 'blue'];

        // ===== Sound Effects =====
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        function getAudioCtx() {
            if (!audioCtx) audioCtx = new AudioCtx();
            return audioCtx;
        }
        function playSound(freq, duration = 0.1, type = 'sine') {
            try {
                const ctx = getAudioCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch(e) {}
        }
        function sfxPlace() { playSound(600, 0.08, 'triangle'); }
        function sfxWin() {
            [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playSound(f, 0.2, 'sine'), i * 120));
        }
        function sfxLose() { playSound(200, 0.4, 'sawtooth'); }

        // ===== State =====
        let board = [];
        let players = [];
        let currentPlayerIndex = 0;
        let gameOver = false;
        let resultShown = false;
        let winner = null;
        let winLine = null;
        let myColor = null;
        let isMultiplayer = false;
        let mpUI = null;

        // ===== Initialize =====
        function init() {
            mpUI = new MultiplayerUI({
                gameType: 'connect4',
                gameName: '?????? 삼인 사목',
                container: document.getElementById('app'),
                maxPlayers: 3,
                supportsLocal: false,  // 멀티플레이어 전용
                onGameStart: handleGameStart,
                onGameEvent: handleGameEvent,
                onLeave: () => { isMultiplayer = false; }
            });

            const roomCode = MultiplayerUI.checkUrlRoom();
            if (roomCode) {
                mpUI._renderLobby();
                setTimeout(() => {
                    document.getElementById('mp-room-code').value = roomCode;
                }, 100);
            } else {
                mpUI.show();
            }
        }

        // ===== Game Start =====
        function handleGameStart(state) {
            if (state.mode === 'local') {
                startLocalGame();
            } else {
                startMultiplayerGame(state);
            }
        }

        function startLocalGame() {
            isMultiplayer = false;
            players = [
                { id: '1', nickname: 'P1', color: 'red' },
                { id: '2', nickname: 'P2', color: 'yellow' },
                { id: '3', nickname: 'P3', color: 'blue' }
            ];
            initBoard();
            renderGame();
        }

        function startMultiplayerGame(state) {
            isMultiplayer = true;
            
            const gs = state.gameState;
            const myId = mpUI.getClient().getMyUserId();
            const me = gs.players.find(p => p.id === myId);
            
            myColor = me?.color;
            players = gs.players;
            currentPlayerIndex = gs.currentPlayerIndex;
            
            // Restore board
            board = gs.board.map(row => row.map(cell => {
                if (!cell) return null;
                const p = gs.players.find(pl => pl.id === cell);
                return p?.color || null;
            }));
            
            gameOver = !!gs.winner;
            winner = gs.winner;
            winLine = gs.winLine;
            
            renderGame(gs);
            
            mpUI.getClient().onStateChange = (newState) => {
                if (newState.status === 'playing' || newState.status === 'finished') {
                    updateFromState(newState);
                }
            };
            
            showToast(`게임 시작! 당신은 ${getColorName(myColor)}입니다`);
        }

        function getColorName(color) {
            return { red: '빨강??', yellow: '노랑??', blue: '파랑??' }[color] || color;
        }

        // ===== Board Logic =====
        function initBoard() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
            currentPlayerIndex = 0;
            gameOver = false;
            resultShown = false;
            winner = null;
            winLine = null;
        }

        function handlePlace(row, col) {
            if (gameOver) return;
            if (board[row][col] !== null) return;
            
            const currentPlayer = players[currentPlayerIndex];
            
            if (isMultiplayer) {
                const myId = mpUI.getClient().getMyUserId();
                if (currentPlayer.id !== myId) {
                    showToast('당신의 차례가 아닙니다');
                    return;
                }
                sendPlace(row, col);
            } else {
                board[row][col] = currentPlayer.color;
                sfxPlace();
                checkGameEnd();
                if (!gameOver) {
                    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                }
                renderGame();
            }
        }

        async function sendPlace(row, col) {
            try {
                await mpUI.sendAction({ type: 'place', payload: { row, col } });
            } catch (e) {
                showToast('실패: ' + e.message);
            }
        }

        function updateFromState(state) {
            const gs = state.gameState;
            
            players = gs.players;
            currentPlayerIndex = gs.currentPlayerIndex ?? 0;
            
            board = gs.board.map(row => row.map(cell => {
                if (!cell) return null;
                const p = gs.players.find(pl => pl.id === cell);
                return p?.color || null;
            }));
            
            const wasOver = gameOver;
            gameOver = !!gs.winner;
            winner = gs.winner;
            winLine = gs.winLine;
            
            if (!wasOver && gs.lastMove) sfxPlace();
            
            renderGame(gs);
            
            if (gameOver && !resultShown) {
                if (winner && winner !== 'draw') {
                    const winnerPlayer = players.find(p => p.id === winner);
                    setTimeout(() => showResult(winnerPlayer, gs.stoneCounts), 300);
                } else if (winner === 'draw') {
                    setTimeout(() => showResult(null, null), 300);
                }
            }
        }

        function checkGameEnd() {
            // Check each cell that was just placed
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        const result = checkWin(row, col, board[row][col]);
                        if (result) {
                            gameOver = true;
                            winLine = result;
                            const winnerPlayer = players.find(p => p.color === board[row][col]);
                            setTimeout(() => showResult(winnerPlayer, null), 300);
                            return;
                        }
                    }
                }
            }
            
            // Check draw
            const allFull = board.every(row => row.every(cell => cell !== null));
            if (allFull) {
                gameOver = true;
                winner = 'draw';
                setTimeout(() => showResult(null, null), 300);
            }
        }

        function checkWin(row, col, color) {
            const directions = [[0,1],[1,0],[1,1],[1,-1]];
            
            for (const [dr, dc] of directions) {
                const line = [{ row, col }];
                
                for (let i = 1; i < 4; i++) {
                    const r = row + dr*i, c = col + dc*i;
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === color) {
                        line.push({ row: r, col: c });
                    } else break;
                }
                
                for (let i = 1; i < 4; i++) {
                    const r = row - dr*i, c = col - dc*i;
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === color) {
                        line.push({ row: r, col: c });
                    } else break;
                }
                
                if (line.length >= 4) return line;
            }
            return null;
        }

        function showResult(winnerPlayer, stoneCounts) {
            if (resultShown) return;
            resultShown = true;
            
            if (isMultiplayer) {
                const myId = mpUI.getClient().getMyUserId();
                const isWin = winnerPlayer?.id === myId;
                
                // Gold: winner gets stones × 100, losers lose 100
                let goldChange = 0;
                let goldText = '';
                if (winnerPlayer) {
                    if (isWin) {
                        const myStones = stoneCounts?.[myId] ?? 0;
                        goldChange = myStones * 100;
                        sfxWin();
                    } else {
                        goldChange = -100;
                        sfxLose();
                    }
                    if (typeof SharedWallet !== 'undefined') {
                        SharedWallet.addGold(goldChange);
                    }
                    goldText = goldChange > 0 
                        ? `<span style="color:#4ecca3">+${goldChange}G</span>` 
                        : `<span style="color:#ff6b6b">${goldChange}G</span>`;
                }
                
                const stoneInfo = winnerPlayer && stoneCounts?.[winnerPlayer.id] 
                    ? ` (돌 ${stoneCounts[winnerPlayer.id]}개)` : '';
                
                mpUI.showResult({
                    title: isWin ? '?? 승리!' : '?? 패배',
                    detail: winnerPlayer 
                        ? `${getColorName(winnerPlayer.color)} ${winnerPlayer.nickname} 승리${stoneInfo} ${goldText}` 
                        : '무승부',
                    isWin,
                    showRematch: true
                });
            } else {
                if (winnerPlayer) sfxWin();
                mpUI.showResult({
                    title: winnerPlayer ? `${getColorName(winnerPlayer.color)} 승리!` : '무승부',
                    isWin: null,
                    showRematch: false
                });
            }
        }

        // ===== Events =====
        function handleGameEvent(type, data) {
            if (type === 'place' && isMultiplayer) {
                // State will be updated via onStateChange
            }
        }

        // ===== Rendering =====
        function renderGame(gs = {}) {
            const myId = mpUI?.getClient()?.getMyUserId();
            const currentPlayer = players[currentPlayerIndex];
            const isMyTurn = isMultiplayer ? currentPlayer?.id === myId : true;
            
            document.getElementById('app').innerHTML = `
                <div class="game-screen">
                    <div class="players-bar">
                        ${players.map((p, i) => `
                            <div class="player-tag ${p.color} ${i === currentPlayerIndex && !gameOver ? 'active' : ''}">
                                <div class="disc ${p.color}"></div>
                                <span>${p.nickname}${p.id === myId ? ' (나)' : ''}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="turn-indicator">
                        ${gameOver ? '게임 종료' : `
                            <div class="disc ${currentPlayer?.color}"></div>
                            <span>${isMultiplayer ? 
                                (isMyTurn ? '내 차례!' : `${currentPlayer?.nickname}의 차례`) : 
                                `${currentPlayer?.nickname}의 차례`}</span>
                        `}
                    </div>
                    
                    <div class="board-container">
                        <div class="board">
                            ${renderBoard(isMyTurn)}
                        </div>
                    </div>
                    
                    <div class="game-actions">
                        ${!isMultiplayer ? '<button class="btn" onclick="restartGame()">새 게임</button>' : ''}
                        <button class="btn" onclick="exitGame()">나가기</button>
                    </div>
                </div>
            `;
        }

        function renderBoard(canClick = true) {
            let html = '';
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const color = board[row][col];
                    const isWinCell = winLine?.some(p => p.row === row && p.col === col);
                    const isEmpty = !color && !gameOver && canClick;
                    
                    html += `
                        <div class="cell ${isEmpty ? 'clickable' : ''}" 
                             ${isEmpty ? `onclick="handlePlace(${row},${col})"` : ''}>
                            ${color ? `<div class="piece ${color} ${isWinCell ? 'win' : ''}"></div>` : ''}
                        </div>
                    `;
                }
            }
            return html;
        }

        function restartGame() {
            initBoard();
            renderGame();
        }

        function exitGame() {
            if (isMultiplayer && mpUI.getClient()) {
                if (confirm('게임을 나가시겠습니까?')) {
                    mpUI.getClient().leaveRoom().catch(() => {});
                    MultiplayerClient.resetInstance();
                    isMultiplayer = false;
                    mpUI.show();
                }
            } else {
                mpUI.show();
            }
        }

        function showToast(msg) {
            const existing = document.querySelector('.mp-toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = 'mp-toast';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        init();
    </script>
</body>
</html>
