<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>조커런</title>
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <style>
    :root {
      color-scheme: dark;
      --felt-1: #062f27;
      --felt-2: #04211b;
      --felt-3: #0b3d31;
      --text: #e6f7f1;
      --muted: #9cc7bb;
      --panel: rgba(9, 30, 24, 0.58);
      --panel-strong: rgba(7, 23, 19, 0.74);
      --border: rgba(118, 255, 225, 0.24);
      --pink: #ff4fc5;
      --cyan: #45f5ff;
      --gold: #ffcf6d;
      --red-start: #ff416c;
      --red-end: #ff4b2b;
      --dark-start: #232526;
      --dark-end: #414345;
      --ok: #7af5b8;
      --danger: #ff7f91;
      --shadow: 0 14px 36px rgba(0, 0, 0, 0.48);
      --blur: blur(12px);
      --ease: 260ms cubic-bezier(0.22, 1, 0.36, 1);
      --phone-w: min(100vw, 460px);
      --header-h: 44px;
      --joker-h: 72px;
      --score-h: 34px;
      --status-h: 32px;
      --actions-h: 56px;
      --gap: 8px;
    }

    :root.light {
      color-scheme: light;
      --felt-1: #145844;
      --felt-2: #0f4536;
      --felt-3: #1f6c56;
      --text: #f7fffc;
      --muted: #d0f0e5;
      --panel: rgba(10, 39, 31, 0.56);
      --panel-strong: rgba(8, 29, 23, 0.66);
      --border: rgba(154, 255, 235, 0.34);
    }

    @media (prefers-color-scheme: light) {
      :root {
        color-scheme: light;
        --felt-1: #145844;
        --felt-2: #0f4536;
        --felt-3: #1f6c56;
        --text: #f7fffc;
        --muted: #d0f0e5;
        --panel: rgba(10, 39, 31, 0.56);
        --panel-strong: rgba(8, 29, 23, 0.66);
        --border: rgba(154, 255, 235, 0.34);
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: "Pretendard", "SUIT", "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
      color: var(--text);
      background:
        radial-gradient(120% 140% at 0% 0%, rgba(69, 245, 255, 0.16), transparent 44%),
        radial-gradient(120% 140% at 100% 0%, rgba(255, 79, 197, 0.2), transparent 42%),
        radial-gradient(120% 140% at 50% 100%, rgba(255, 207, 109, 0.14), transparent 58%),
        repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.015) 0 2px, transparent 2px 10px),
        linear-gradient(165deg, var(--felt-3), var(--felt-1) 45%, var(--felt-2));
      display: grid;
      place-items: center;
      padding: max(8px, env(safe-area-inset-top)) 8px max(8px, env(safe-area-inset-bottom));
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.045), transparent 22%),
        radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.03), transparent 20%),
        repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.06) 0 1px, transparent 1px 3px),
        repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.015) 0 1px, transparent 1px 4px);
      mix-blend-mode: soft-light;
      opacity: 0.75;
      z-index: 0;
    }

    .app {
      width: var(--phone-w);
      height: calc(100dvh - max(8px, env(safe-area-inset-top)) - max(8px, env(safe-area-inset-bottom)) - 8px);
      max-height: 100dvh;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 20px;
      background: linear-gradient(180deg, rgba(4, 23, 18, 0.72), rgba(4, 21, 17, 0.82));
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      display: grid;
      grid-template-rows: var(--header-h) var(--joker-h) var(--score-h) minmax(160px, 1fr) var(--status-h) auto var(--actions-h);
      gap: var(--gap);
      padding: 10px;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }

    .glass {
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border-radius: 12px;
      backdrop-filter: var(--blur);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    .topbar {
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      gap: 8px;
      padding: 0 10px;
    }

    .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 800;
      letter-spacing: 0.01em;
      min-width: 0;
      font-size: 0.92rem;
      text-shadow: 0 0 14px rgba(69, 245, 255, 0.25);
    }

    .gold-badge {
      color: #ffe5a8;
      font-size: 0.78rem;
      font-weight: 800;
      white-space: nowrap;
      text-shadow: 0 0 8px rgba(255, 207, 109, 0.45);
    }

    .meta .sep {
      color: rgba(230, 247, 241, 0.35);
      font-weight: 500;
    }

    .target-pill {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      color: var(--gold);
      font-size: 0.82rem;
      white-space: nowrap;
      text-shadow: 0 0 10px rgba(255, 207, 109, 0.48);
    }

    .target-icon {
      width: 14px;
      height: 14px;
      display: inline-block;
      border-radius: 50%;
      border: 2px solid currentColor;
      position: relative;
    }

    .target-icon::before,
    .target-icon::after {
      content: "";
      position: absolute;
      inset: 2px;
      border-radius: 50%;
      border: 1px solid currentColor;
      opacity: 0.7;
    }

    .target-icon::after {
      inset: 5px;
      background: currentColor;
      border: 0;
    }

    button {
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 10px;
      min-height: 44px;
      min-width: 44px;
      padding: 0 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.08));
      color: var(--text);
      font-weight: 800;
      font-size: 0.84rem;
      cursor: pointer;
      transition: transform var(--ease), box-shadow var(--ease), opacity var(--ease), border-color var(--ease);
    }

    button:hover:enabled,
    button:active:enabled {
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(69, 245, 255, 0.28);
    }

    button:active:enabled {
      transform: translateY(0) scale(0.97);
    }

    button:disabled {
      opacity: 0.46;
      cursor: not-allowed;
    }

    .ctrl-btn {
      width: 44px;
      padding: 0;
      font-size: 0;
      position: relative;
    }

    .ctrl-btn::before,
    .ctrl-btn::after {
      content: "";
      position: absolute;
      inset: 0;
      margin: auto;
      width: 16px;
      height: 16px;
    }

    #themeBtn::before {
      border-radius: 50%;
      box-shadow: inset -6px 0 0 0 var(--cyan);
      border: 1px solid rgba(69, 245, 255, 0.8);
    }

    #restartBtn::before {
      border: 2px solid var(--pink);
      border-right-color: transparent;
      border-radius: 50%;
    }

    #restartBtn::after {
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      border-left: 7px solid var(--pink);
      transform: translate(5px, -3px);
    }

    .joker-strip {
      padding: 7px;
      overflow-x: auto;
      overflow-y: hidden;
      display: flex;
      gap: 8px;
      scrollbar-width: thin;
    }

    .joker-strip::-webkit-scrollbar {
      height: 5px;
    }

    .joker-strip::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.24);
      border-radius: 999px;
    }

    .joker {
      width: 50px;
      height: 70px;
      border-radius: 12px;
      border: 2px solid;
      border-image: linear-gradient(135deg, var(--gold), #ff6b6b, var(--gold)) 1;
      flex: 0 0 auto;
      display: grid;
      grid-template-rows: 24px auto auto;
      align-content: start;
      gap: 2px;
      position: relative;
      overflow: hidden;
      transition: transform var(--ease), box-shadow var(--ease), filter var(--ease);
      cursor: pointer;
      padding: 6px 4px 5px;
      text-align: center;
      color: #f5f8ff;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      box-shadow:
        0 0 20px rgba(255, 215, 0, 0.3),
        inset 0 0 30px rgba(255, 255, 255, 0.05);
    }

    .joker:hover,
    .joker.reveal {
      transform: translateY(-4px) scale(1.06);
      z-index: 6;
      filter: saturate(1.08);
    }

    .joker.reveal {
      width: 84px;
      box-shadow:
        0 0 24px rgba(255, 215, 0, 0.42),
        0 10px 22px rgba(0, 0, 0, 0.44),
        inset 0 0 30px rgba(255, 255, 255, 0.08);
    }

    .joker.reveal .joker-desc-mini {
      -webkit-line-clamp: unset;
    }

    .joker:active {
      transform: translateY(-2px) scale(1.01);
    }

    .joker::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        105deg,
        transparent 40%,
        rgba(255, 255, 255, 0.2) 45%,
        rgba(255, 255, 255, 0.3) 50%,
        rgba(255, 255, 255, 0.2) 55%,
        transparent 60%
      );
      transform: translateX(-100%);
      animation: shimmer 3s infinite;
      pointer-events: none;
    }

    .joker::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.22), transparent 62%);
      pointer-events: none;
    }

    .joker-name-mini {
      display: block;
      font-weight: 800;
      font-size: 10px;
      line-height: 1.15;
      text-shadow: 0 0 8px rgba(0, 0, 0, 0.55);
    }

    .joker-desc-mini {
      display: block;
      font-size: 8px;
      line-height: 1.2;
      color: rgba(239, 245, 255, 0.82);
      opacity: 0.88;
      white-space: normal;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .joker-icon {
      width: 24px;
      height: 24px;
      margin: 0 auto;
      position: relative;
      display: block;
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.32));
    }

    .joker-glyph {
      position: absolute;
      inset: 0;
      margin: auto;
    }

    .joker-bomb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff4d8 0 18%, #ffab3a 20% 58%, #c63711 60% 100%);
      bottom: 1px;
      box-shadow: 0 0 10px rgba(255, 126, 35, 0.8);
    }

    .joker-bomb::before {
      content: "";
      position: absolute;
      width: 8px;
      height: 8px;
      border: 2px solid #f5d799;
      border-left: 0;
      border-bottom: 0;
      border-radius: 0 8px 0 0;
      top: -6px;
      right: -4px;
      transform: rotate(10deg);
    }

    .joker-bomb::after {
      content: "";
      position: absolute;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      top: -8px;
      right: -8px;
      background: #ffd26e;
      box-shadow: 0 0 8px #ff7429, 0 0 14px #ff7429;
      animation: bombSpark 1s ease-in-out infinite;
    }

    .joker-wave {
      width: 20px;
      height: 12px;
      top: 6px;
      background: linear-gradient(180deg, #b6f8ff, #37b8ff 65%, #0064c7);
      clip-path: polygon(0% 60%, 12% 42%, 24% 58%, 36% 40%, 48% 55%, 60% 35%, 72% 56%, 84% 44%, 100% 60%, 100% 100%, 0 100%);
      animation: waveMotion 2.2s ease-in-out infinite;
      box-shadow: 0 0 8px rgba(0, 206, 255, 0.7);
    }

    .joker-wave::after {
      content: "";
      position: absolute;
      inset: auto 0 2px;
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.9), transparent);
      opacity: 0.7;
    }

    .joker-calc {
      width: 18px;
      height: 18px;
      top: 3px;
      border-radius: 3px;
      background:
        repeating-linear-gradient(90deg, rgba(0, 255, 115, 0.32) 0 2px, transparent 2px 6px),
        repeating-linear-gradient(0deg, rgba(0, 255, 115, 0.32) 0 2px, transparent 2px 6px),
        #052e18;
      border: 1px solid rgba(120, 255, 163, 0.65);
      box-shadow: 0 0 10px rgba(0, 255, 110, 0.68), inset 0 0 8px rgba(0, 255, 115, 0.3);
    }

    .joker-calc::after {
      content: "10110";
      position: absolute;
      left: 2px;
      right: 2px;
      top: -8px;
      font-size: 6px;
      letter-spacing: 1px;
      color: #69ff97;
      animation: matrixDrift 1.8s linear infinite;
      text-shadow: 0 0 6px rgba(0, 255, 98, 0.75);
    }

    .joker-heart {
      width: 14px;
      height: 12px;
      top: 6px;
      background: #ff476d;
      transform: rotate(-45deg);
      box-shadow: 0 0 8px rgba(255, 66, 92, 0.85);
      animation: heartBeat 1.2s ease-in-out infinite;
    }

    .joker-heart::before,
    .joker-heart::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 12px;
      border-radius: 50%;
      background: #ff476d;
    }

    .joker-heart::before {
      top: -7px;
      left: 0;
    }

    .joker-heart::after {
      top: 0;
      left: 7px;
    }

    .joker-duo {
      width: 20px;
      height: 16px;
      top: 4px;
    }

    .joker-duo::before,
    .joker-duo::after {
      content: "";
      position: absolute;
      width: 8px;
      height: 14px;
      top: 1px;
      border-radius: 10px 10px 3px 3px;
      background: linear-gradient(180deg, #f8cdff, #cf65ff 60%, #7e2df5);
      box-shadow: 0 0 10px rgba(207, 101, 255, 0.75);
    }

    .joker-duo::before {
      left: 2px;
      transform: skewY(-6deg);
    }

    .joker-duo::after {
      right: 2px;
      transform: scaleX(-1) skewY(-6deg);
      opacity: 0.82;
      animation: mirrorShift 1.9s ease-in-out infinite;
    }

    .joker.empty {
      cursor: default;
      border-style: dashed;
      border-color: rgba(255, 255, 255, 0.25);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.02));
      box-shadow: none;
      display: grid;
      place-items: center;
      padding: 0;
    }

    .joker.empty::before {
      content: "+";
      animation: none;
      transform: none;
      background: none;
      color: rgba(255, 255, 255, 0.5);
      font-size: 1.25rem;
    }

    .joker-tip {
      position: absolute;
      left: 50%;
      bottom: calc(100% + 6px);
      transform: translate(-50%, 6px);
      min-width: 126px;
      max-width: 170px;
      padding: 6px 7px;
      border-radius: 10px;
      background: rgba(5, 16, 14, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--ease), transform var(--ease);
      z-index: 9;
      font-size: 0.64rem;
      line-height: 1.25;
      white-space: normal;
    }

    .joker:hover .joker-tip,
    .joker.reveal .joker-tip {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .joker-name {
      display: block;
      color: var(--gold);
      font-weight: 800;
      margin-bottom: 3px;
      font-size: 0.7rem;
    }

    .joker-flat50 {
      background:
        radial-gradient(circle at 50% 28%, rgba(255, 178, 62, 0.42), transparent 55%),
        linear-gradient(140deg, #2f1a12, #441b14 45%, #7f2a15 100%);
      box-shadow: 0 0 16px rgba(255, 132, 33, 0.56), inset 0 0 20px rgba(255, 194, 122, 0.1);
    }

    .joker-flat50 .joker-icon::after {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle, rgba(255, 174, 66, 0.9) 0 1px, transparent 2px) 1px 4px/8px 8px,
        radial-gradient(circle, rgba(255, 110, 44, 0.75) 0 1px, transparent 2px) 4px 2px/7px 7px;
      animation: emberFloat 2.2s linear infinite;
      opacity: 0.65;
    }

    .joker-flushx2 {
      background:
        radial-gradient(circle at 50% 10%, rgba(137, 240, 255, 0.35), transparent 50%),
        linear-gradient(155deg, #10273f, #0f3f66 45%, #0a608b);
      box-shadow: 0 0 16px rgba(41, 206, 255, 0.58), inset 0 0 20px rgba(178, 246, 255, 0.08);
    }

    .joker-perCardMult {
      background:
        linear-gradient(180deg, rgba(0, 255, 128, 0.08), transparent 32%),
        linear-gradient(155deg, #071f13, #06311e 45%, #09522f);
      box-shadow: 0 0 16px rgba(0, 255, 110, 0.48), inset 0 0 18px rgba(90, 255, 155, 0.1);
    }

    .joker-heartChip {
      background:
        radial-gradient(circle at 52% 24%, rgba(255, 148, 168, 0.3), transparent 48%),
        linear-gradient(155deg, #3e101d, #66182e 55%, #9f1c3f);
      box-shadow: 0 0 16px rgba(255, 73, 110, 0.52), inset 0 0 20px rgba(255, 172, 190, 0.1);
    }

    .joker-pairBoost {
      background:
        radial-gradient(circle at 40% 20%, rgba(232, 153, 255, 0.28), transparent 48%),
        linear-gradient(150deg, #28154f, #41208f 52%, #6f28d9);
      box-shadow: 0 0 16px rgba(203, 97, 255, 0.52), inset 0 0 18px rgba(233, 177, 255, 0.1);
    }

    .score-line {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
      padding: 0 10px;
      font-size: 0.88rem;
      position: relative;
    }

    .score-main {
      display: flex;
      gap: 10px;
      align-items: center;
      color: var(--muted);
      font-weight: 700;
      flex-wrap: wrap;
    }

    .chips-readout b {
      color: #ffd86d;
      text-shadow: 0 0 12px rgba(255, 207, 109, 0.7);
    }

    .mult-readout b {
      color: #ff69ce;
      text-shadow: 0 0 12px rgba(255, 79, 197, 0.72);
    }

    .score-main b {
      color: var(--text);
      font-size: 1.02rem;
      text-shadow: 0 0 10px rgba(69, 245, 255, 0.34);
      min-width: 44px;
      transition: transform var(--ease), text-shadow var(--ease);
    }

    .score-total {
      font-size: 1.2rem;
      color: #c6ffe8;
      font-weight: 800;
      white-space: nowrap;
      letter-spacing: 0.03em;
      text-shadow: 0 0 12px rgba(122, 245, 184, 0.55), 0 0 24px rgba(69, 245, 255, 0.28);
      transition: transform var(--ease), color var(--ease), text-shadow var(--ease);
    }

    .score-total.pulse {
      animation: neonPulse 500ms ease;
    }

    .table {
      position: relative;
      padding: 8px;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr) auto;
      gap: 7px;
      overflow: hidden;
    }

    .info-line {
      min-height: 16px;
      font-size: 0.73rem;
      color: var(--muted);
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 0 4px;
    }

    .hand-tag {
      color: var(--gold);
      font-weight: 900;
    }

    .cards-wrap {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
      align-content: center;
      height: 100%;
      min-height: 0;
    }

    .card {
      border-radius: 8px;
      min-height: clamp(74px, 18vw, 112px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 7px 16px rgba(0, 0, 0, 0.35);
      color: #ffffff;
      display: flex;
      justify-content: space-between;
      flex-direction: column;
      padding: 8px;
      user-select: none;
      cursor: pointer;
      transition: transform var(--ease), box-shadow var(--ease), border-color var(--ease), filter var(--ease);
      animation: cardFlipIn 320ms cubic-bezier(0.2, 0.8, 0.2, 1);
      position: relative;
      overflow: hidden;
      transform-style: preserve-3d;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.06) 0 2px, rgba(255, 255, 255, 0.01) 2px 5px),
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.18), transparent 38%);
      mix-blend-mode: overlay;
      opacity: 0.44;
      pointer-events: none;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(165deg, rgba(255, 255, 255, 0.24), rgba(255, 255, 255, 0));
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .card.s-heart,
    .card.s-diamond {
      background: linear-gradient(150deg, var(--red-start), var(--red-end));
    }

    .card.s-club,
    .card.s-spade {
      background: linear-gradient(150deg, var(--dark-start), var(--dark-end));
    }

    .card:hover,
    .card:active {
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.48);
      filter: brightness(1.04);
    }

    .card:active {
      transform: scale(0.98);
    }

    .card.selected {
      border-color: #ffd76a;
      box-shadow: 0 0 0 1px rgba(255, 215, 106, 0.75), 0 14px 24px rgba(0, 0, 0, 0.46), 0 0 26px rgba(255, 207, 109, 0.72);
      transform: translateY(-8px);
      animation: selectedFloat 1.8s ease-in-out infinite;
      z-index: 2;
    }

    .rank {
      font-size: clamp(1rem, 4vw, 1.2rem);
      font-weight: 900;
      line-height: 1;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
    }

    .suit {
      align-self: flex-end;
      font-size: clamp(1.2rem, 5vw, 1.42rem);
      font-weight: 900;
      line-height: 1;
      text-shadow: 0 3px 8px rgba(0, 0, 0, 0.42);
      color: transparent;
      -webkit-background-clip: text;
      background-clip: text;
    }

    .card.s-heart .suit,
    .card.s-diamond .suit {
      background-image: linear-gradient(180deg, #ffe7ed, #ff7997 45%, #cc2247);
    }

    .card.s-club .suit,
    .card.s-spade .suit {
      background-image: linear-gradient(180deg, #ffffff, #c4ced5 48%, #747d85);
    }

    .status-bar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      align-items: center;
      padding: 0 10px;
      font-size: 0.83rem;
      color: var(--muted);
      font-weight: 700;
    }

    .status-bar b {
      color: var(--text);
      font-weight: 800;
      font-size: 0.92rem;
      text-shadow: 0 0 10px rgba(255, 79, 197, 0.3);
    }

    .pvp-panel {
      display: none;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      font-size: 0.77rem;
      color: var(--muted);
    }

    .pvp-panel.show {
      display: grid;
    }

    .pvp-score {
      color: var(--gold);
      font-weight: 800;
      text-shadow: 0 0 8px rgba(255, 207, 109, 0.4);
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr 44px;
      gap: 8px;
      align-items: stretch;
    }

    .btn-main,
    .btn-warn {
      font-size: 0.83rem;
      letter-spacing: 0.02em;
      border: 0;
      color: #08130f;
      text-transform: uppercase;
    }

    .btn-main {
      background: linear-gradient(120deg, #45f5ff, #8bffe3 55%, #ffd76a);
      box-shadow: 0 0 16px rgba(69, 245, 255, 0.38);
    }

    .btn-warn {
      background: linear-gradient(120deg, #ff80cb, #ffc66f 85%);
      box-shadow: 0 0 16px rgba(255, 128, 203, 0.34);
    }

    #clearBtn {
      font-size: 0;
      padding: 0;
      position: relative;
    }

    #clearBtn::before,
    #clearBtn::after {
      content: "";
      position: absolute;
      width: 18px;
      height: 2px;
      background: #fff;
      inset: 0;
      margin: auto;
    }

    #clearBtn::before { transform: rotate(45deg); }
    #clearBtn::after { transform: rotate(-45deg); }

    .log {
      position: absolute;
      width: 1px;
      height: 1px;
      margin: -1px;
      border: 0;
      padding: 0;
      clip: rect(0 0 0 0);
      overflow: hidden;
    }

    .fx {
      position: absolute;
      left: 12px;
      top: 12px;
      padding: 6px 9px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.26);
      background: rgba(9, 35, 28, 0.78);
      color: var(--gold);
      font-weight: 900;
      font-size: 0.78rem;
      pointer-events: none;
      z-index: 7;
      text-shadow: 0 0 10px rgba(255, 207, 109, 0.48);
      animation: scoreCombine 900ms ease forwards;
    }

    .fx.chips-readout {
      color: #ffd86d;
      text-shadow: 0 0 10px rgba(255, 207, 109, 0.7);
    }

    .fx.mult-readout {
      color: #ff69ce;
      text-shadow: 0 0 10px rgba(255, 79, 197, 0.7);
    }

    .fx.score-total {
      color: #c6ffe8;
      text-shadow: 0 0 10px rgba(122, 245, 184, 0.68);
    }

    .chip {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 30;
      background: radial-gradient(circle at 35% 35%, #fff2cc 0 24%, #ffcf6d 25% 62%, #b77d1f 63%);
      box-shadow: 0 0 8px rgba(255, 207, 109, 0.56);
    }

    .chip.fly {
      animation: chipFly 720ms cubic-bezier(0.25, 0.6, 0.2, 1) forwards;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
      background: rgba(2, 12, 10, 0.68);
      backdrop-filter: blur(8px);
      padding: 12px;
    }

    .modal.show {
      display: flex;
    }

    .shop {
      width: min(92vw, 460px);
      border-radius: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(6, 26, 22, 0.86), rgba(5, 18, 15, 0.93));
      box-shadow: var(--shadow);
      padding: 12px;
      display: grid;
      gap: 10px;
      max-height: min(86dvh, 660px);
      overflow: auto;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .title {
      font-size: 1rem;
      font-weight: 900;
      text-shadow: 0 0 12px rgba(69, 245, 255, 0.33);
    }

    .subtitle,
    .tag {
      color: var(--muted);
      font-size: 0.78rem;
      font-weight: 700;
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .shop-item {
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.03));
      padding: 9px;
      display: grid;
      gap: 7px;
      transition: transform var(--ease), box-shadow var(--ease);
    }

    .shop-item:hover {
      transform: scale(1.02);
      box-shadow: 0 0 16px rgba(69, 245, 255, 0.22);
    }

    .shop-item .name {
      color: var(--gold);
      font-weight: 900;
      font-size: 0.86rem;
    }

    .shop-item .desc {
      color: var(--muted);
      font-size: 0.72rem;
      line-height: 1.24;
      min-height: 44px;
    }

    .price {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: #ffe5a8;
      font-weight: 800;
      font-size: 0.72rem;
    }

    .coin {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff5d8 0 28%, #ffcf6d 29% 68%, #b77d1f 69%);
      box-shadow: 0 0 6px rgba(255, 207, 109, 0.65);
    }

    @keyframes dealIn {
      from { opacity: 0; transform: translateY(10px) scale(0.96); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    @keyframes shimmer {
      100% { transform: translateX(100%); }
    }

    @keyframes neonPulse {
      0% { transform: scale(1); }
      40% { transform: scale(1.1); color: #90ffe4; text-shadow: 0 0 16px rgba(69, 245, 255, 0.9); }
      100% { transform: scale(1); }
    }

    @keyframes floatUp {
      0% { opacity: 0; transform: translateY(8px) scale(0.95); }
      20% { opacity: 1; }
      100% { opacity: 0; transform: translateY(-30px) scale(1.03); }
    }

    @keyframes scoreCombine {
      0% { opacity: 0; transform: translateY(8px) scale(0.92); }
      18% { opacity: 1; }
      72% { opacity: 1; transform: translateY(-10px) scale(1); }
      100% { opacity: 0; transform: translate(150px, -68px) scale(0.78); }
    }

    @keyframes chipFly {
      0% { transform: translate(0, 0) scale(0.7); opacity: 0; }
      18% { opacity: 1; }
      100% {
        transform: translate(var(--dx), var(--dy)) scale(0.25);
        opacity: 0;
      }
    }

    @keyframes cardFlipIn {
      0% { opacity: 0; transform: perspective(460px) rotateY(-82deg) translateY(8px); }
      100% { opacity: 1; transform: perspective(460px) rotateY(0) translateY(0); }
    }

    @keyframes selectedFloat {
      0% { transform: translateY(-8px); }
      50% { transform: translateY(-11px); }
      100% { transform: translateY(-8px); }
    }

    @keyframes bombSpark {
      0%, 100% { transform: scale(0.9); opacity: 0.8; }
      50% { transform: scale(1.3); opacity: 1; }
    }

    @keyframes waveMotion {
      0%, 100% { transform: translateX(0) translateY(0); }
      50% { transform: translateX(1px) translateY(-2px); }
    }

    @keyframes matrixDrift {
      0% { transform: translateY(0); opacity: 0; }
      25% { opacity: 1; }
      100% { transform: translateY(12px); opacity: 0; }
    }

    @keyframes heartBeat {
      0%, 40%, 80%, 100% { transform: rotate(-45deg) scale(1); }
      20%, 60% { transform: rotate(-45deg) scale(1.16); }
    }

    @keyframes mirrorShift {
      0%, 100% { transform: scaleX(-1) skewY(-6deg) translateX(0); opacity: 0.82; }
      50% { transform: scaleX(-1) skewY(-6deg) translateX(-1px); opacity: 1; }
    }

    @keyframes emberFloat {
      0% { transform: translateY(0); opacity: 0.3; }
      50% { transform: translateY(-2px); opacity: 0.72; }
      100% { transform: translateY(-4px); opacity: 0.2; }
    }

    @media (min-width: 700px) {
      .app {
        width: min(100vw, 520px);
        border-radius: 24px;
      }
      .cards-wrap {
        gap: 8px;
      }
      .actions {
        grid-template-columns: 1fr 1fr 52px;
      }
    }

    .mode-sheet {
      width: min(92vw, 420px);
      border-radius: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(6, 26, 22, 0.9), rgba(5, 18, 15, 0.95));
      box-shadow: var(--shadow);
      padding: 14px;
      display: grid;
      gap: 10px;
    }

    .mode-grid {
      display: grid;
      gap: 8px;
    }

    .mode-card {
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      gap: 8px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
    }

    .mode-card h4 {
      font-size: 0.9rem;
      color: var(--gold);
    }

    .mode-card p {
      font-size: 0.74rem;
      color: var(--muted);
      line-height: 1.3;
    }

    .input {
      width: 100%;
      min-height: 40px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      padding: 0 10px;
      font-size: 0.86rem;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="app" id="tablePanel">
    <header class="topbar glass">
      <div class="meta">
        <span id="roundLabel">-</span>
        <span class="sep">|</span>
        <span id="moneyLabel">$0</span>
        <span class="sep">|</span>
        <span class="gold-badge" id="goldLabel">G 0</span>
      </div>
      <div class="target-pill"><span class="target-icon" aria-hidden="true"></span><span id="targetLabel">0</span></div>
      <div style="display:flex;gap:6px;">
        <button id="themeBtn" class="ctrl-btn" aria-label="테마 전환"></button>
        <button id="restartBtn" class="ctrl-btn" aria-label="새 런 시작"></button>
      </div>
    </header>

    <section class="joker-strip glass" id="jokerArea" aria-label="조커 슬롯"></section>

    <section class="score-line glass">
      <div class="score-main">
        <span class="chips-readout">칩 <b id="chipsLabel">0</b></span>
        <span class="mult-readout">배수 <b id="multLabel">x1</b></span>
      </div>
      <div class="score-total" id="scoreLabel">0</div>
    </section>

    <section class="table glass">
      <div class="info-line" id="handResult">핸드를 선택해 플레이하세요.</div>
      <div class="cards-wrap" id="cardsWrap"></div>
      <div class="info-line" id="handGuide">손패 8장 중 최대 5장을 선택</div>
    </section>

    <section class="status-bar glass">
      <div>남은 핸드 <b id="handsLabel">0</b></div>
      <div style="text-align:right;">남은 버리기 <b id="discardsLabel">0</b></div>
    </section>

    <section class="pvp-panel glass" id="pvpPanel">
      <div id="opponentStatus">상대 정보 없음</div>
      <div class="pvp-score" id="opponentScore">상대 점수 0</div>
    </section>

    <section class="actions">
      <button class="btn-main" id="playBtn">핸드 플레이</button>
      <button class="btn-warn" id="discardBtn">카드 버리기</button>
      <button id="clearBtn" aria-label="선택 해제"></button>
    </section>

    <div class="log" id="log" aria-hidden="true"></div>
  </div>

  <div class="modal" id="shopModal">
    <div class="shop">
      <div class="row">
        <div>
          <div class="title">상점</div>
          <div class="subtitle">조커를 사서 다음 블라인드를 대비하세요.</div>
        </div>
        <div class="tag" id="shopMoney">보유 자금: $0</div>
      </div>
      <div class="shop-grid" id="shopGrid"></div>
      <div class="row" style="justify-content:flex-end;">
        <button class="btn-main" id="nextRoundBtn" style="min-width:132px;">다음 라운드</button>
      </div>
    </div>
  </div>

  <div class="modal show" id="modeModal">
    <div class="mode-sheet">
      <div>
        <div class="title">모드 선택</div>
        <div class="subtitle">싱글 플레이 또는 대전 모드를 선택하세요.</div>
      </div>
      <div class="mode-grid">
        <div class="mode-card">
          <h4>싱글 플레이</h4>
          <p>현재 모드 그대로 라운드와 상점을 진행합니다.</p>
          <button class="btn-main" id="singleModeBtn">싱글 플레이 시작</button>
        </div>
        <div class="mode-card">
          <h4>대전 모드 (PvP)</h4>
          <p>배팅 금액을 걸고 2인 대전을 진행합니다.</p>
          <div class="row">
            <select id="betSelect" class="input" style="max-width:130px;">
              <option value="100">100G</option>
              <option value="500">500G</option>
              <option value="1000">1000G</option>
            </select>
            <button class="btn-main" id="createRoomBtn">방 만들기</button>
          </div>
          <div class="row">
            <input id="roomCodeInput" class="input" placeholder="방 코드 입력">
            <button class="btn-warn" id="joinRoomBtn">방 참가</button>
          </div>
          <div class="subtitle" id="roomHint">멀티플레이 연결 대기 중...</div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="pvpResultModal">
    <div class="mode-sheet">
      <div>
        <div class="title">대전 결과</div>
        <div class="subtitle" id="pvpFinalText">결과 정산 중...</div>
      </div>
      <button class="btn-main" id="pvpConfirmBtn">확인</button>
    </div>
  </div>

  <script src="/lib/multiplayer.js"></script>
  <script src="/lib/shared-wallet.js?v=20260211"></script>
  <script>
    const suits = ["heart", "diamond", "club", "spade"];
    const suitSymbol = { heart: "♥", diamond: "♦", club: "♣", spade: "♠" };
    const suitClass = { heart: "s-heart", diamond: "s-diamond", club: "s-club", spade: "s-spade" };
    const rankList = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
    const rankLabel = { 11: "J", 12: "Q", 13: "K", 14: "A" };

    const handBase = {
      HIGH_CARD: { name: "하이카드", chips: 5, mult: 1 },
      PAIR: { name: "원페어", chips: 10, mult: 2 },
      TWO_PAIR: { name: "투페어", chips: 20, mult: 2 },
      THREE: { name: "트리플", chips: 30, mult: 3 },
      STRAIGHT: { name: "스트레이트", chips: 30, mult: 4 },
      FLUSH: { name: "플러시", chips: 35, mult: 4 },
      FULL_HOUSE: { name: "풀하우스", chips: 40, mult: 4 },
      FOUR: { name: "포카드", chips: 60, mult: 7 },
      STRAIGHT_FLUSH: { name: "스트레이트 플러시", chips: 100, mult: 8 }
    };

    const roundDefs = [
      { id: "small", label: "스몰 블라인드", target: 300 },
      { id: "big", label: "빅 블라인드", target: 700 },
      { id: "boss", label: "보스 블라인드", target: 1500 }
    ];

    const jokerPool = [
      { id: "flat50", name: "칩 폭탄", cost: 6, desc: "핸드 점수 계산 시 칩 +50", apply(ctx) { ctx.chips += 50; } },
      { id: "flushx2", name: "물결 조커", cost: 7, desc: "플러시 계열이면 배수 x2", apply(ctx) { if (ctx.handType === "FLUSH" || ctx.handType === "STRAIGHT_FLUSH") ctx.mult *= 2; } },
      { id: "perCardMult", name: "계산기 조커", cost: 5, desc: "플레이한 카드 1장당 배수 +1", apply(ctx) { ctx.mult += ctx.cards.length; } },
      { id: "heartChip", name: "붉은 인장", cost: 5, desc: "하트 카드 1장당 칩 +15", apply(ctx) { ctx.chips += ctx.cards.filter(c => c.suit === "heart").length * 15; } },
      { id: "pairBoost", name: "듀오 증폭기", cost: 8, desc: "원페어 이상이면 배수 +2", apply(ctx) { if (ctx.handType !== "HIGH_CARD") ctx.mult += 2; } }
    ];

    const jokerGlyphClass = {
      flat50: "joker-bomb",
      flushx2: "joker-wave",
      perCardMult: "joker-calc",
      heartChip: "joker-heart",
      pairBoost: "joker-duo"
    };

    const state = {
      mode: "single",
      roundIndex: 0,
      score: 0,
      money: 10,
      handsLeft: 4,
      discardsLeft: 3,
      deck: [],
      hand: [],
      selected: new Set(),
      jokers: [],
      gameEnded: false
    };

    const pvp = {
      active: false,
      mp: null,
      isHost: false,
      roomId: "",
      bet: 100,
      roundTarget: 700,
      currentRound: 0,
      maxRounds: 3,
      myRoundsWon: 0,
      oppRoundsWon: 0,
      myRoundEnded: false,
      oppRoundEnded: false,
      oppRoundScore: 0,
      stakePaid: false,
      opponentNickname: "",
      finalized: false,
      initialized: false
    };

    const $ = sel => document.querySelector(sel);
    const cardsWrap = $("#cardsWrap");
    const handResult = $("#handResult");
    const logEl = $("#log");
    const jokerArea = $("#jokerArea");
    const tablePanel = $("#tablePanel");

    function hashSeed(seedText) {
      let h = 2166136261;
      for (let i = 0; i < seedText.length; i++) {
        h ^= seedText.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function mulberry32(seed) {
      return function () {
        let t = (seed += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function buildDeck(seedText = "") {
      let id = 0;
      const deck = [];
      for (const suit of suits) {
        for (const rank of rankList) deck.push({ id: id++, suit, rank });
      }
      const rng = seedText ? mulberry32(hashSeed(seedText)) : Math.random;
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    function formatRank(rank) {
      return rankLabel[rank] || String(rank);
    }

    function activeRoundLabel() {
      if (state.mode === "pvp") return `대전 ${pvp.currentRound}/${pvp.maxRounds}`;
      return `라운드 ${state.roundIndex + 1}`;
    }

    function activeTarget() {
      if (state.mode === "pvp") return pvp.roundTarget;
      const round = roundDefs[state.roundIndex] || roundDefs[roundDefs.length - 1];
      return round.target;
    }

    function drawToEight() {
      while (state.hand.length < 8 && state.deck.length > 0) state.hand.push(state.deck.pop());
    }

    function setInfo(msg) {
      handResult.innerHTML = msg;
    }

    function addLog(msg) {
      const el = document.createElement("div");
      el.textContent = msg;
      logEl.prepend(el);
      while (logEl.children.length > 40) logEl.removeChild(logEl.lastChild);
    }

    function updateGoldLabel() {
      const gold = window.SharedWallet ? Number(SharedWallet.gold || 0) : 0;
      $("#goldLabel").textContent = `G ${gold.toLocaleString()}`;
    }

    function setOpponentStatus(text) {
      $("#opponentStatus").textContent = text;
    }

    function renderCards() {
      cardsWrap.innerHTML = "";
      state.hand.forEach(card => {
        const d = document.createElement("div");
        d.className = `card ${suitClass[card.suit]} ${state.selected.has(card.id) ? "selected" : ""}`;
        d.innerHTML = `<div class="rank">${formatRank(card.rank)}</div><div class="suit">${suitSymbol[card.suit]}</div>`;
        d.addEventListener("click", () => {
          if (state.gameEnded) return;
          if (state.selected.has(card.id)) state.selected.delete(card.id);
          else {
            if (state.selected.size >= 5) return setInfo("최대 5장까지만 선택 가능합니다.");
            state.selected.add(card.id);
          }
          renderCards();
        });
        cardsWrap.appendChild(d);
      });
    }

    function renderJokers() {
      jokerArea.innerHTML = "";
      for (let i = 0; i < 5; i++) {
        const joker = state.jokers[i];
        const box = document.createElement("button");
        if (!joker) {
          box.className = "joker empty";
          box.type = "button";
          box.disabled = true;
          box.setAttribute("aria-label", "빈 슬롯");
        } else {
          box.className = `joker joker-${joker.id}`;
          box.type = "button";
          box.innerHTML = `
            <span class="joker-icon" aria-hidden="true"><span class="joker-glyph ${jokerGlyphClass[joker.id] || "joker-duo"}"></span></span>
            <span class="joker-name-mini">${joker.name}</span>
            <span class="joker-desc-mini">${joker.desc}</span>
          `;
          box.addEventListener("click", () => box.classList.toggle("reveal"));
        }
        jokerArea.appendChild(box);
      }
    }

    function renderHUD(chips = 0, mult = 1) {
      $("#roundLabel").textContent = activeRoundLabel();
      $("#targetLabel").textContent = activeTarget().toLocaleString();
      $("#scoreLabel").textContent = state.score.toLocaleString();
      $("#moneyLabel").textContent = `$${state.money}`;
      $("#handsLabel").textContent = String(state.handsLeft);
      $("#discardsLabel").textContent = String(state.discardsLeft);
      $("#chipsLabel").textContent = chips.toLocaleString();
      $("#multLabel").textContent = `x${mult}`;
      $("#playBtn").disabled = state.gameEnded;
      $("#discardBtn").disabled = state.gameEnded;
      $("#pvpPanel").classList.toggle("show", state.mode === "pvp");
      renderJokers();
      updateGoldLabel();
    }

    function selectedCards() {
      return state.hand.filter(c => state.selected.has(c.id));
    }

    function scoreHand(cards) {
      if (!cards.length) return { handType: "HIGH_CARD", ...handBase.HIGH_CARD };
      const ranks = cards.map(c => c.rank).sort((a, b) => a - b);
      const suitsOnly = cards.map(c => c.suit);
      const counts = Object.values(ranks.reduce((m, r) => ((m[r] = (m[r] || 0) + 1), m), {})).sort((a, b) => b - a);
      const isFive = cards.length === 5;
      const isFlush = isFive && new Set(suitsOnly).size === 1;
      let isStraight = false;
      if (isFive) {
        const uniq = [...new Set(ranks)];
        if (uniq.length === 5) isStraight = uniq[4] - uniq[0] === 4 || uniq.join(",") === "2,3,4,5,14";
      }
      if (isStraight && isFlush) return { handType: "STRAIGHT_FLUSH", ...handBase.STRAIGHT_FLUSH };
      if (counts[0] === 4) return { handType: "FOUR", ...handBase.FOUR };
      if (counts[0] === 3 && counts[1] === 2) return { handType: "FULL_HOUSE", ...handBase.FULL_HOUSE };
      if (isFlush) return { handType: "FLUSH", ...handBase.FLUSH };
      if (isStraight) return { handType: "STRAIGHT", ...handBase.STRAIGHT };
      if (counts[0] === 3) return { handType: "THREE", ...handBase.THREE };
      if (counts[0] === 2 && counts[1] === 2) return { handType: "TWO_PAIR", ...handBase.TWO_PAIR };
      if (counts[0] === 2) return { handType: "PAIR", ...handBase.PAIR };
      return { handType: "HIGH_CARD", ...handBase.HIGH_CARD };
    }

    function spawnChipParticles(points) {
      const scoreEl = $("#scoreLabel");
      const source = tablePanel.getBoundingClientRect();
      const target = scoreEl.getBoundingClientRect();
      const startX = source.left + source.width * 0.5;
      const startY = source.top + source.height * 0.65;
      const endX = target.left + target.width * 0.5;
      const endY = target.top + target.height * 0.5;
      const count = Math.min(16, Math.max(8, Math.floor(points / 60)));
      for (let i = 0; i < count; i++) {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.style.left = `${startX + (Math.random() * 34 - 17)}px`;
        chip.style.top = `${startY + (Math.random() * 16 - 8)}px`;
        chip.style.setProperty("--dx", `${endX - startX + (Math.random() * 14 - 7)}px`);
        chip.style.setProperty("--dy", `${endY - startY + (Math.random() * 14 - 7)}px`);
        chip.style.animationDelay = `${i * 24}ms`;
        chip.classList.add("fly");
        document.body.appendChild(chip);
        setTimeout(() => chip.remove(), 860 + i * 24);
      }
    }

    function animateScore(chips, points, mult) {
      const pieces = [
        { text: `+${chips}칩`, className: "chips-readout", x: 14, y: 56, delay: 0 },
        { text: `x${mult}배`, className: "mult-readout", x: 56, y: 80, delay: 120 },
        { text: `+${points.toLocaleString()} 점`, className: "score-total", x: 30, y: 68, delay: 280 }
      ];
      pieces.forEach(piece => {
        const fx = document.createElement("div");
        fx.className = `fx ${piece.className}`;
        fx.textContent = piece.text;
        fx.style.left = `${piece.x}px`;
        fx.style.top = `${piece.y}px`;
        fx.style.animationDelay = `${piece.delay}ms`;
        tablePanel.appendChild(fx);
        setTimeout(() => fx.remove(), 980 + piece.delay);
      });
      spawnChipParticles(points);
      const total = $("#scoreLabel");
      total.classList.remove("pulse");
      void total.offsetWidth;
      total.classList.add("pulse");
      $("#multLabel").textContent = `x${mult}`;
    }

    function consumeSelectedCards() {
      state.hand = state.hand.filter(c => !state.selected.has(c.id));
      state.selected.clear();
      drawToEight();
      renderCards();
    }

    async function sendPvpAction(data) {
      if (state.mode !== "pvp" || !pvp.mp) return;
      try { await pvp.mp.sendAction(data); } catch (e) { addLog(`동기화 실패: ${e.message || e}`); }
    }

    function openPvpResult(text) {
      $("#pvpFinalText").textContent = text;
      $("#pvpResultModal").classList.add("show");
    }

    async function settlePvpGold(result) {
      if (!window.SharedWallet || !pvp.stakePaid) return;
      if (result === "win") SharedWallet.addGold(pvp.bet * 2);
      if (result === "draw") SharedWallet.addGold(pvp.bet);
      pvp.stakePaid = false;
      updateGoldLabel();
    }

    async function finalizePvpMatch() {
      if (pvp.finalized) return;
      pvp.finalized = true;
      let result = "draw";
      if (pvp.myRoundsWon > pvp.oppRoundsWon) result = "win";
      if (pvp.myRoundsWon < pvp.oppRoundsWon) result = "lose";
      await settlePvpGold(result);
      await sendPvpAction({ type: "GAME_OVER", finalScore: state.score, result });
      const gainText = result === "win" ? `승리! +${pvp.bet * 2}G` : result === "draw" ? `무승부! +${pvp.bet}G 환불` : "패배...";
      openPvpResult(`${gainText} (라운드 ${pvp.myRoundsWon}:${pvp.oppRoundsWon})`);
      addLog(`대전 종료: ${gainText}`);
    }

    async function resolvePvpRound() {
      if (!pvp.myRoundEnded || !pvp.oppRoundEnded) return;
      if (state.score > pvp.oppRoundScore) {
        pvp.myRoundsWon += 1;
        setInfo(`라운드 승리! (${state.score} vs ${pvp.oppRoundScore})`);
      } else if (state.score < pvp.oppRoundScore) {
        pvp.oppRoundsWon += 1;
        setInfo(`라운드 패배... (${state.score} vs ${pvp.oppRoundScore})`);
      } else {
        setInfo(`라운드 무승부 (${state.score})`);
      }
      if (pvp.myRoundsWon >= 2 || pvp.oppRoundsWon >= 2 || pvp.currentRound >= pvp.maxRounds) return finalizePvpMatch();
      if (pvp.isHost) setTimeout(() => sendRoundStart(pvp.currentRound + 1), 900);
    }

    async function endLocalPvpRound() {
      if (pvp.myRoundEnded) return;
      state.gameEnded = true;
      pvp.myRoundEnded = true;
      renderHUD();
      setOpponentStatus("상대방 대기 중...");
      await sendPvpAction({ type: "ROUND_ENDED", roundScore: state.score, roundsWon: pvp.myRoundsWon });
      resolvePvpRound();
    }

    function canContinue() {
      if (state.score >= activeTarget()) {
        if (state.mode === "pvp") endLocalPvpRound();
        else winRound();
        return false;
      }
      if (state.handsLeft <= 0) {
        if (state.mode === "pvp") endLocalPvpRound();
        else loseRun();
        return false;
      }
      return true;
    }

    async function playSelected() {
      if (state.gameEnded) return;
      const cards = selectedCards();
      if (!cards.length) return setInfo("먼저 카드를 1장 이상 선택하세요.");
      const hand = scoreHand(cards);
      let chips = hand.chips;
      let mult = hand.mult;
      const ctx = { cards, handType: hand.handType, chips, mult };
      for (const joker of state.jokers) joker.apply(ctx);
      chips = Math.max(0, Math.floor(ctx.chips));
      mult = Math.max(1, Math.floor(ctx.mult * 100) / 100);
      const points = Math.floor(chips * mult);
      state.score += points;
      state.handsLeft -= 1;
      animateScore(chips, points, mult);
      setInfo(`<span class="hand-tag">${hand.name}</span> | ${chips}칩 × ${mult}배 = <b>${points.toLocaleString()}</b>점`);
      addLog(`${hand.name} 플레이: +${points}점 (남은 핸드 ${state.handsLeft})`);
      consumeSelectedCards();
      renderHUD(chips, mult);
      if (state.mode === "pvp") {
        await sendPvpAction({ type: "HAND_PLAYED", handType: hand.handType, chips, mult, totalScore: state.score });
        setOpponentStatus("상대방 플레이 중...");
      }
      canContinue();
    }

    function discardSelected() {
      if (state.gameEnded) return;
      if (state.discardsLeft <= 0) return setInfo("버리기 횟수를 모두 사용했습니다.");
      const cards = selectedCards();
      if (!cards.length) return setInfo("버릴 카드를 선택하세요.");
      state.discardsLeft -= 1;
      consumeSelectedCards();
      setInfo(`${cards.length}장 버림 완료. 남은 버리기 ${state.discardsLeft}`);
      addLog(`${cards.length}장 버림. (남은 버리기 ${state.discardsLeft})`);
      renderHUD();
    }

    function openShop() {
      const grid = $("#shopGrid");
      grid.innerHTML = "";
      $("#shopMoney").textContent = `보유 자금: $${state.money}`;
      jokerPool.forEach(joker => {
        const owned = state.jokers.some(j => j.id === joker.id);
        const full = state.jokers.length >= 5;
        const afford = state.money >= joker.cost;
        const card = document.createElement("div");
        card.className = "shop-item";
        card.innerHTML = `<div class="name">${joker.name}</div><div class="desc">${joker.desc}</div><div class="price"><span class="coin" aria-hidden="true"></span>$${joker.cost}</div>`;
        const btn = document.createElement("button");
        btn.textContent = owned ? "보유 중" : full ? "슬롯 가득 참" : afford ? "구매" : "자금 부족";
        btn.disabled = owned || full || !afford;
        btn.addEventListener("click", () => {
          state.money -= joker.cost;
          state.jokers.push(joker);
          addLog(`조커 구매: ${joker.name} (-$${joker.cost})`);
          renderHUD();
          openShop();
        });
        card.appendChild(btn);
        grid.appendChild(card);
      });
      $("#shopModal").classList.add("show");
    }

    function closeShop() {
      $("#shopModal").classList.remove("show");
    }

    function startRound(index, seedText = "") {
      state.roundIndex = index;
      state.score = 0;
      state.handsLeft = 4;
      state.discardsLeft = 3;
      state.deck = buildDeck(seedText);
      state.hand = [];
      state.selected.clear();
      state.gameEnded = false;
      drawToEight();
      renderCards();
      renderHUD();
      setInfo("핸드를 선택해 플레이하세요.");
      addLog(`${activeRoundLabel()} 시작. 목표 ${activeTarget()}점`);
    }

    function winRound() {
      const reward = 7 + state.handsLeft * 2 + state.discardsLeft;
      state.money += reward;
      addLog(`라운드 클리어! 보상 +$${reward}`);
      setInfo(`블라인드 돌파 성공! 보상 +$${reward}`);
      state.gameEnded = true;
      renderHUD();
      if (state.roundIndex >= roundDefs.length - 1) {
        setInfo("보스 블라인드 격파! 런 클리어. 새 런을 시작하세요.");
        addLog("런 클리어 완료.");
        return;
      }
      openShop();
    }

    function loseRun() {
      state.gameEnded = true;
      renderHUD();
      setInfo("핸드를 모두 사용했습니다. 게임 오버! 새 런을 시작하세요.");
      addLog("게임 오버.");
    }

    function newRun() {
      state.mode = "single";
      state.money = 10;
      state.jokers = [];
      logEl.innerHTML = "";
      closeShop();
      startRound(0);
      $("#modeModal").classList.remove("show");
      $("#pvpPanel").classList.remove("show");
    }

    function startSingleMode() {
      $("#modeModal").classList.remove("show");
      state.mode = "single";
      pvp.active = false;
      startRound(0);
    }

    function applyRemoteAction(event) {
      if (!event || !event.data) return;
      const data = event.data;
      if (data.type === "ROUND_START") {
        pvp.currentRound = data.round;
        pvp.roundTarget = data.target || 700;
        pvp.myRoundEnded = false;
        pvp.oppRoundEnded = false;
        pvp.oppRoundScore = 0;
        pvp.finalized = false;
        state.mode = "pvp";
        state.jokers = [];
        $("#opponentScore").textContent = "상대 점수 0";
        setOpponentStatus("상대방 플레이 중...");
        startRound(pvp.currentRound - 1, data.seed || "");
      }
      if (data.type === "HAND_PLAYED") {
        $("#opponentScore").textContent = `상대 점수 ${Number(data.totalScore || 0).toLocaleString()}`;
        setOpponentStatus("상대방 플레이 중...");
      }
      if (data.type === "ROUND_ENDED") {
        pvp.oppRoundEnded = true;
        pvp.oppRoundScore = Number(data.roundScore || 0);
        pvp.oppRoundsWon = Number(data.roundsWon || pvp.oppRoundsWon);
        setOpponentStatus("상대방 대기 중...");
        resolvePvpRound();
      }
      if (data.type === "GAME_OVER" && !pvp.finalized) {
        pvp.finalized = true;
        const text = data.result === "win" ? "패배..." : data.result === "lose" ? `승리! +${pvp.bet * 2}G` : `무승부! +${pvp.bet}G 환불`;
        openPvpResult(`${text} (상대 전송 결과)`);
      }
    }

    function sendRoundStart(roundNo) {
      if (!pvp.isHost || !pvp.mp) return;
      const seed = `${Date.now()}-${Math.random().toString(16).slice(2)}-${roundNo}`;
      const data = { type: "ROUND_START", round: roundNo, seed, target: pvp.roundTarget };
      applyRemoteAction({ data });
      sendPvpAction(data);
    }

    async function ensureStakePaid() {
      if (!window.SharedWallet || pvp.stakePaid) return true;
      const ok = SharedWallet.removeGold(pvp.bet);
      if (!ok) {
        setInfo(`골드 부족: ${pvp.bet}G 필요`);
        updateGoldLabel();
        return false;
      }
      pvp.stakePaid = true;
      updateGoldLabel();
      return true;
    }

    async function initMultiplayer() {
      if (pvp.initialized) return true;
      if (!window.MultiplayerClient) return false;
      pvp.mp = MultiplayerClient.getInstance();
      await pvp.mp.ensureAuth();
      pvp.mp.onEvent = async (event) => {
        if (event.type === "player_joined") {
          pvp.opponentNickname = event.nickname || "상대";
          setOpponentStatus(`${pvp.opponentNickname} 접속`);
        }
        if (event.type === "game_started") {
          const roomBet = Number(event.betting || (event.room && event.room.betting) || 0);
          if (roomBet > 0) pvp.bet = roomBet;
          const paid = await ensureStakePaid();
          if (!paid) return;
          $("#modeModal").classList.remove("show");
          state.mode = "pvp";
          pvp.active = true;
          pvp.myRoundsWon = 0;
          pvp.oppRoundsWon = 0;
          pvp.finalized = false;
          $("#opponentScore").textContent = "상대 점수 0";
          setOpponentStatus("상대방 플레이 중...");
          addLog(`대전 시작! 배팅 ${pvp.bet}G`);
          if (pvp.isHost) sendRoundStart(1);
        }
        if (event.type === "action") applyRemoteAction(event);
      };
      pvp.mp.startListening();
      pvp.initialized = true;
      $("#roomHint").textContent = `로그인 완료: ${pvp.mp.nickname || "익명"}`;
      return true;
    }

    async function createPvpRoom() {
      const ok = await initMultiplayer();
      if (!ok) return setInfo("멀티플레이 클라이언트를 불러오지 못했습니다.");
      pvp.bet = Number($("#betSelect").value || 100);
      pvp.isHost = true;
      const room = await pvp.mp.createRoom("jokerrun", { maxPlayers: 2, betting: pvp.bet });
      pvp.roomId = room.id || room.roomId || room.code || room.roomCode || "";
      await pvp.mp.setReady(true);
      $("#roomHint").textContent = `방 생성 완료. 코드: ${pvp.roomId || "(자동 매칭)"}`;
      setOpponentStatus("상대방 접속 대기 중...");
      addLog(`방 생성: 배팅 ${pvp.bet}G`);
    }

    async function joinPvpRoom() {
      const ok = await initMultiplayer();
      if (!ok) return setInfo("멀티플레이 클라이언트를 불러오지 못했습니다.");
      const code = $("#roomCodeInput").value.trim();
      if (!code) return setInfo("참가할 방 코드를 입력하세요.");
      pvp.bet = Number($("#betSelect").value || 100);
      pvp.isHost = false;
      await pvp.mp.joinRoom(code);
      pvp.roomId = code;
      await pvp.mp.setReady(true);
      $("#roomHint").textContent = `방 참가 완료: ${code}`;
      setOpponentStatus("상대방 준비 중...");
      addLog(`방 참가: ${code}`);
    }

    async function resetFromPvp() {
      if (pvp.mp) {
        try { await pvp.mp.leaveRoom(); } catch (_) {}
      }
      pvp.active = false;
      pvp.stakePaid = false;
      pvp.finalized = false;
      $("#pvpResultModal").classList.remove("show");
      $("#modeModal").classList.add("show");
      setOpponentStatus("상대 정보 없음");
      $("#opponentScore").textContent = "상대 점수 0";
      state.mode = "single";
      startRound(0);
    }

    $("#playBtn").addEventListener("click", playSelected);
    $("#discardBtn").addEventListener("click", discardSelected);
    $("#clearBtn").addEventListener("click", () => {
      state.selected.clear();
      renderCards();
      setInfo("선택을 해제했습니다.");
    });
    $("#nextRoundBtn").addEventListener("click", () => {
      closeShop();
      startRound(state.roundIndex + 1);
    });
    $("#restartBtn").addEventListener("click", () => {
      if (state.mode === "pvp") resetFromPvp();
      else newRun();
    });
    $("#themeBtn").addEventListener("click", () => document.documentElement.classList.toggle("light"));
    $("#singleModeBtn").addEventListener("click", startSingleMode);
    $("#createRoomBtn").addEventListener("click", createPvpRoom);
    $("#joinRoomBtn").addEventListener("click", joinPvpRoom);
    $("#pvpConfirmBtn").addEventListener("click", resetFromPvp);

    if (window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches) document.documentElement.classList.add("light");

    (async () => {
      if (window.SharedWallet) {
        try { await SharedWallet.init(); } catch (_) {}
      }
      updateGoldLabel();
      startRound(0);
      $("#modeModal").classList.add("show");
    })();
  </script>
</body>
</html>
