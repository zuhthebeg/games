<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>큐브 배치 게임</title>
  <style>
    /* 모던하고 반응형 CSS */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #game-container {
      position: relative;
      width: 90vw;
      max-width: 600px;
      background: #fff;
      border: 2px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 1.2rem;
      color: #333;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="score">점수: 0</div>
    <canvas id="gameCanvas"></canvas>
  </div>
  <script>
    // 캔버스 및 컨테이너 크기 설정
    const container = document.getElementById("game-container");
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;

    // 기본 설정
    const cubeSize = 80; // 큐브(및 넷의) 크기 (더 크게)
    let level = 1;
    let score = 0;
    let direction = 1; // 수평 이동 방향 (1: 오른쪽, -1: 왼쪽)
    
    // 넷(펼친 정육면체) 배치 – 좌표는 넷의 내부 기준 (상단, 중단, 하단)
    const netSquares = [
      { name: 'U', x: cubeSize,        y: 0 },              // 위쪽 면
      { name: 'L', x: 0,             y: cubeSize },         // 왼쪽 면
      { name: 'F', x: cubeSize,        y: cubeSize },         // 정면
      { name: 'R', x: cubeSize * 2,    y: cubeSize },         // 오른쪽 면
      { name: 'B', x: cubeSize * 3,    y: cubeSize },         // 뒷면
      { name: 'D', x: cubeSize * 2,    y: cubeSize * 2 }      // 아래쪽 면
    ];
    const netWidth = 4 * cubeSize;  // 넷의 전체 너비 (중간 행 4블럭)
    const netHeight = 3 * cubeSize; // 넷의 전체 높이 (위, 중, 아래)
    // 넷을 캔버스 하단 중앙에 배치 (여백 20px)
    const netOffsetX = (canvas.width - netWidth) / 2;
    const netOffsetY = canvas.height - netHeight - 20;

    // 속도 (레벨에 따라 증가)
    let horizontalSpeed = 4 + level; // 수평 이동 속도
    let verticalSpeed = 5 + level * 1.5; // 수직 낙하/상승 속도

    // 게임 오브젝트 – 현재 이동하는 큐브
    let piece = createPiece();
    // 게임 진행 상태 : "horizontal" (수평 이동), "falling" (낙하), "upward" (튕겨 상승), "stopped" (멈춤)
    let phase = "horizontal";
    let bounceUsed = false;  // 바닥 튕김 사용 여부

    // 큐브(게임 오브젝트) 생성 함수
    function createPiece() {
      return {
        x: 0,         // 좌측 상단 출발
        y: 20,
        size: cubeSize,
        color: randomColor()
      };
    }
    // 랜덤 색상 생성
    function randomColor() {
      return `hsl(${Math.random() * 360}, 70%, 60%)`;
    }

    // 사각형 간 겹치는 면적 계산 함수
    function rectOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      const xOverlap = Math.max(0, Math.min(x1 + w1, x2 + w2) - Math.max(x1, x2));
      const yOverlap = Math.max(0, Math.min(y1 + h1, y2 + h2) - Math.max(y1, y2));
      return xOverlap * yOverlap;
    }

    // 점수 계산 후 다음 레벨로 전환
    function scorePiece() {
      let totalOverlap = 0;
      // 넷의 각 정사각형과 현재 큐브가 겹치는 면적 합산
      netSquares.forEach(square => {
        const rx = netOffsetX + square.x;
        const ry = netOffsetY + square.y;
        totalOverlap += rectOverlap(piece.x, piece.y, piece.size, piece.size, rx, ry, cubeSize, cubeSize);
      });
      // 겹치는 면적 비율 (이상적으로 큐브 하나 크기)
      const ratio = totalOverlap / (piece.size * piece.size);
      const points = Math.floor(ratio * 100 * level);
      score += points;
      document.getElementById("score").textContent = "점수: " + score;
      // 다음 레벨로 (6단계 후에는 1레벨로 순환)
      setTimeout(() => {
        level = (level % 6) + 1;
        horizontalSpeed = 4 + level;
        verticalSpeed = 5 + level * 1.5;
        phase = "horizontal";
        bounceUsed = false;
        piece = createPiece();
      }, 1000);
    }

    // 캔버스 클릭 이벤트 처리
    canvas.addEventListener("click", () => {
      if (phase === "horizontal") {
        // 수평 이동 중 클릭 → 낙하 시작 (x좌표 고정)
        phase = "falling";
      } else if (phase ===