<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Puzzle</title>
    <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-MJPN92FN');</script>
    <!-- End Google Tag Manager -->
    <style>
        /* 이전 스타일 유지 */
        body {
            margin: 0;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Arial', sans-serif;
            background: #6b4f40; /* 어두운 우드톤 */
            color: #fff3e0;     /* 크림색 텍스트 */
            min-height: -webkit-fill-available;
            touch-action: none;
            user-select: none;
        }

        .game-container {
            width: 100%;
            max-width: 100%;
            padding: 10px;
            margin: 5px auto;
            background: #8b6b4d; /* 중간 우드톤 */
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 2px solid #5d432f; /* 우드 테두리 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* 가로 중앙 정렬 추가 */
        }

        .board {
            display: grid;
            grid-template-columns: repeat(9, 40px); /* 고정 크기 */
            grid-template-rows: repeat(9, 40px);
            gap: 1px;
            background-color: #a78b72;
            padding: 1px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #5d432f;
            width: fit-content; /* 내용물에 맞게 너비 고정 */
        }

        .cell {
            aspect-ratio: 1;
            background-color: #d2b48c; /* 밝은 샌색 우드 */
            border: 1px solid #8b6b4d;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            will-change: transform, opacity;
        }

        .cell.filled {
            background-color: #8b4513; /* 나무 색상 */
            border-color: #654321;
            background-image: 
                linear-gradient(to bottom right, 
                    rgba(0,0,0,0.1) 25%, 
                    transparent 25%, 
                    transparent 50%, 
                    rgba(0,0,0,0.1) 50%, 
                    rgba(0,0,0,0.1) 75%, 
                    transparent 75%),
                repeating-linear-gradient(
                    45deg,
                    #654321 0 1px,
                    transparent 1px 4px
                );
            animation: fillCell 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
            opacity: 1; /* 미리보기와 동일한 스타일, 투명도만 다름 */
        }

        .block-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            padding: 10px;
            background: #a78b72;
            border-radius: 5px;
            border: 1px solid #8b6b4d;
            width: fit-content; /* 컨테이너 너비 고정 */
            margin: 0 auto; /* 중앙 정렬 */
        }

        .block-wrapper {
            cursor: grab;
            touch-action: none;
            transition: transform 0.3s ease;
            width: fit-content;
            height: fit-content;
            margin: 8px;
            position: relative; /* 상대 위치 추가 */
        }

        .block-grid {
            display: grid;
            gap: 1px;
            background-color: transparent;
            padding: 1px;
            border-radius: 3px;
            border: none;
            width: max-content !important;
            grid-template-columns: repeat(var(--cols, 1), 36px); /* 고정 크기 */
            grid-auto-rows: 36px; /* 고정 높이 */
        }

        /* 빈 셀 스타일 처리 */
        .block-grid > div:not(.block-cell) {
            background-color: transparent !important;
            border: 1px solid transparent !important;
            box-shadow: none !important;
        }

        .block-cell {
            width: 36px !important;    /* 명시적 크기 지정 */
            height: 36px !important;    /* 36px 고정 */
            background: 
                linear-gradient(145deg, 
                    #8b4513 0%, 
                    #a0522d 20%, 
                    #8b4513 50%, 
                    #654321 100% 
                ) !important;
            border: 1px solid #5d432f !important;
            box-shadow: 
                inset 0 1px 3px rgba(255,255,255,0.1),
                inset 0 -1px 3px rgba(0,0,0,0.3) !important;
        }

        .score {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #ffd54f; /* 골드색 점수표시 */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        @keyframes fillCell {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .cell.preview {
            background-color: #a0522d; /* 블록 컨테이너의 블록 색상과 동일 */
            border: 1px solid #8b4513; /* 블록 컨테이너 테두리 색상 */
            opacity: 0.5; /* 반투명 효과 */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2); /* 블록 셀과 동일 효과 */
            transition: opacity 0.1s linear;
        }

        @media (max-width: 380px) {
            .cell {
                font-size: 0.8em;
            }
            .block-wrapper {
                transform: scale(0.85);
            }
        }

        @media (orientation: portrait) {
            .game-container {
                max-width: 95vw;
            }
        }

        @keyframes lineClear {
            0% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
                background-color: #8b4513;
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.2) rotate(-2deg);
                opacity: 0.8;
                background-color: #6b4f40;
                filter: brightness(1.2);
                box-shadow: inset 0 0 15px rgba(107, 79, 64, 0.5);
            }
            100% { 
                transform: scale(0.8) rotate(2deg);
                opacity: 0;
                background-color: #a78b72;
                filter: brightness(0.8);
            }
        }

        .clearing {
            animation: lineClear 0.8s cubic-bezier(0.33, 1, 0.68, 1) forwards;
            background-image: linear-gradient(45deg, 
                transparent 25%, 
                rgba(0,0,0,0.1) 25%, 
                rgba(0,0,0,0.1) 50%, 
                transparent 50%);
            background-size: 4px 4px;
        }

        /* 나뭇조각 파티클 효과 */
        .clearing::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background: #5d432f;
            animation: woodParticle 1s ease-out forwards;
        }

        @keyframes woodParticle {
            0% { 
                opacity: 1;
                transform: translate(0, 0) rotate(0deg);
            }
            100% { 
                opacity: 0;
                transform: 
                    translate(
                        calc(var(--tx) * 30px), 
                        calc(var(--ty) * 30px)
                    )
                    rotate(720deg);
                background: #8b6b4d;
            }
        }

        /* 대형 블록 대응 */
 

        /* 난이도 선택기 재조정 */
        .difficulty-picker {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }

        .difficulty-btn {
            position: relative;
            padding: 15px; /* 적정 크기로 조정 */
            border: 2px solid #5d432f !important;
            border-radius: 6px;
            cursor: pointer;
            background: 
                linear-gradient(145deg, 
                    #8b4513 0%, 
                    #a0522d 20%, 
                    #8b4513 50%, 
                    #654321 100% 
                ) !important;
            min-width: 50px; /* 원래 크기로 복구 */
            min-height: 50px;
            transition: all 0.3s ease; /* 전환 효과 시간 증가 */
            font-size: 1.8em; /* 적정 크기 조정 */
            aspect-ratio: 1;
            box-shadow: 
                inset 0 1px 3px rgba(255,255,255,0.1),
                inset 0 -1px 3px rgba(0,0,0,0.3) !important; /* 외부 그림자 제거 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 활성화 상태 스타일 */
        .difficulty-btn.active {
            background: 
                linear-gradient(145deg, 
                    #6b4f40 0%, 
                    #8b6b4d 20%, 
                    #6b4f40 50%, 
                    #5d432f 100% 
                ) !important;
            transform: scale(0.95); /* 약간 축소 효과 */
        }

        /* 호버 효과 추가 */
        .difficulty-btn:hover {
            transform: scale(1.05);
            background: 
                linear-gradient(145deg, 
                    #a0522d 0%, 
                    #8b4513 20%, 
                    #a0522d 50%, 
                    #8b6b4d 100% 
                ) !important;
        }

        /* 우측하단 숫자 스타일 */
        .difficulty-btn::after {
            content: attr(data-size);
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 0.6em; /* 상대적 크기 조정 */
            color: #fff3e0;
            opacity: 0.9;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* 기존 레벨별 색상 코드 제거 */
        [data-level="beginner"],
        [data-level="intermediate"],
        [data-level="advanced"],
        [data-level="chaos"] { 
            background: transparent !important; 
        }

        /* 카오스 모드 표시 */
        [data-level="chaos"]::after {
            content: "?" !important;
        }

        /* 게임 오버 오버레이 */
        body.game-over::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }

        .game-over .cell {
            filter: grayscale(80%);
            opacity: 0.5;
        }

        /* 효과 애니메이션 */
        .score-effect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            font-weight: bold;
            color: #ffd54f;
            text-shadow: 0 0 10px rgba(255,213,79,0.8);
            animation: scorePop 3s cubic-bezier(0.33, 1, 0.68, 1) forwards;
            pointer-events: none;
            z-index: 2000;
            text-align: center;
        }

        @keyframes scorePop {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0) rotate(-15deg);
                filter: blur(5px);
            }
            20% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.5) rotate(5deg);
                filter: blur(0);
            }
            40% {
                text-shadow: 0 0 30px rgba(255,213,79,0.9),
                             0 0 20px rgba(231,76,60,0.8);
            }
            60% {
                transform: translate(-50%, -50%) scale(1.2) translateY(-50px) rotate(10deg);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.8) translateY(-150px) rotate(15deg);
                filter: blur(2px);
            }
        }

        /* 콤보별 추가 효과 확장 */
        .score-effect[data-combo="2"] { 
            color: #2ecc71;
            text-shadow: 0 0 20px rgba(46,204,113,0.7);
        }
        .score-effect[data-combo="3"] { 
            color: #e74c3c;
            text-shadow: 0 0 25px rgba(231,76,60,0.8);
        }
        .score-effect[data-combo^="4"] { 
            color: #9b59b6;
            text-shadow: 0 0 30px rgba(155,89,182,0.9);
            animation-duration: 2.2s;
        }

        /* 크로스 효과 강화 */
        .score-effect[data-cross="2"] { 
            text-shadow: 0 0 30px #e67e22,
                         0 0 15px rgba(230,126,34,0.6);
        }
        .score-effect[data-cross="3"] { 
            text-shadow: 0 0 40px #e74c3c,
                         0 0 25px rgba(231,76,60,0.7);
        }

        .test-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9); /* 가시성 향상 */
            padding: 10px;
            border-radius: 8px;
            z-index: 3000;
            display: none; /* 초기 상태 숨김 */
        }
        
        .test-panel button {
            display: block;
            margin: 5px;
            padding: 8px 12px;
            background: #e74c3c;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .test-panel button:hover {
            opacity: 1;
        }

        /* 힌트 패널 스타일 개선 */
        .hint-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 0;
            padding: 12px;
            background: #8b6b4d;
            border-radius: 10px 10px 0 0;
            border: 2px solid #5d432f;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.3);
            z-index: 2000;
        }

        .hint-panel button {
            padding: 12px;
            border: 2px solid #5d432f;
            border-radius: 6px;
            cursor: pointer;
            background: #a78b72; /* 레벨 버튼 배경과 유사 */
            color: #fff3e0;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .hint-panel button:hover {
            background: #8b6b4d;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* 모바일 대응 */
        @media (max-width: 480px) {
            .hint-panel {
                padding: 10px;
                gap: 6px;
                border-radius: 8px 8px 0 0;
            }
            .hint-panel button {
                padding: 12px;
                font-size: 1.2em;
            }
            .board {
                grid-template-columns: repeat(9, 35px); /* 약간 축소 */
                grid-template-rows: repeat(9, 35px);
            }
            
       
            
            .game-container {
                padding: 5px; /* 패딩 축소 */
            }
            .block-container {
                gap: 6px; /* 모바일에서 간격 축소 */
                padding: 8px;
            }
            
            .block-wrapper {
                margin: 1px; /* 모바일 여백 최소화 */
                transform: scale(0.85);
            }
            .block-grid {
                grid-template-columns: repeat(var(--cols, 1), 30px); /* 모바일 30px */
                grid-auto-rows: 30px;
            }
   
        }

        /* 회전 시 크기 변화 방지 */
        .block-wrapper:hover {
            transform: scale(0.9) !important; /* 호버 시 약간 축소 */
        }

        /* 회전 애니메이션 추가 */
        @keyframes smoothRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(90deg); }
        }

        .score-effect[data-combo] {
            color: #ff4757 !important; /* 빨강 */
            text-shadow: 0 0 30px rgba(255,71,87,0.7);
        }

        .score-effect[data-cross] {
            color: #2d98da !important; /* 파랑 */
            text-shadow: 0 0 30px rgba(45,152,218,0.7);
        }

        .score-effect[data-both] {
            color: #a55eea !important; /* 보라 */
            text-shadow: 
                0 0 30px rgba(165,94,234,0.7),
                0 0 20px rgba(255,71,87,0.4),
                0 0 20px rgba(45,152,218,0.4);
            font-size: 3.2em;
        }

        /* 힌트 미리보기 스타일 추가 */
        .cell.hint-preview {
            background-color: #e67e22 !important;
            opacity: 0.6;
            animation: hintPulse 1.5s ease-in-out infinite;
        }

        @keyframes hintPulse {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        /* 차감 효과 스타일 추가 */
        .score-effect.deduction {
            color: #ff4757 !important; /* 빨간색 */
            text-shadow: 0 0 15px rgba(255, 71, 87, 0.5);
            font-size: 1.8em;
            animation: scoreDeduction 1.5s ease-out forwards;
        }

        @keyframes scoreDeduction {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150%) scale(0.8);
            }
        }

        /* 시간 표시 스타일 수정 */
        .time-display {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: 15px;
            font-size: 1.1em;
        }

        /* 게임 오버 레이어 팝업 스타일 */
        .game-over-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #8b6b4d;
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #5d432f;
            text-align: center;
            z-index: 3000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            animation: popupAppear 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes popupAppear {
            0% { transform: translate(-50%, -50%) scale(0); }
            80% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .game-over-popup h2 {
            color: #ffd54f;
            margin: 0 0 15px 0;
            font-size: 2em;
        }

        .game-over-popup p {
            font-size: 1.2em;
            margin: 10px 0;
        }

        .game-over-popup button {
            background: #a78b72;
            border: 2px solid #5d432f;
            color: white;
            padding: 10px 25px;
            border-radius: 8px;
            margin-top: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-over-popup button:hover {
            background: #8b6b4d;
            transform: scale(1.05);
        }

        /* 효과 애니메이션 조정 */
        .score-effect.combo {
            animation: scorePop 1s ease-out forwards;
        }
        .score-effect.cross {
            animation: crossPop 1s ease-out forwards;
            z-index: 2001; /* 콤보 위에 표시 */
        }

        @keyframes crossPop {
            0% { transform: translateY(0) scale(0); opacity: 0; }
            50% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-40px) scale(1); opacity: 0; }
        }

        @keyframes nopeShake {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            25% { transform: translate(-50%, -50%) translateX(-10px) rotate(-5deg) scale(1.2); }
            50% { transform: translate(-50%, -50%) translateX(10px) rotate(5deg) scale(1.3); }
            75% { transform: translate(-50%, -50%) translateX(-5px) rotate(-3deg) scale(1.1); }
        }
    </style>
    <!-- SEO 최적화 -->
    <meta name="keywords" content="Block Puzzle, 블록 퍼즐, Brain Game, 두뇌 게임, Puzzle Strategy, 퍼즐 전략, Casual Game, 캐주얼 게임, Block Fitting, 블록 맞추기, Time Killer, 시간 떼우기, Logic Game, 논리 게임, Free Puzzle, 무료 퍼즐, Online Puzzle, 온라인 퍼즐">
    <meta name="description" content="전략적인 블록 배치로 고득점을 노려보세요! 2D 블록 퍼즐 게임으로 공간 인지력과 문제 해결 능력을 키울 수 있는 중독성 강한 퍼즐 게임">
    <meta name="author" content="COCY.IO">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Block Puzzle Master - COCY.IO">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://game.cocy.io/blockpuzzle/icons.svg">
    <meta property="og:url" content="https://game.cocy.io/blockpuzzle/">
    <meta property="og:description" content="도전적인 블록 배치 게임! 최고 점수를 달성하고 친구들과 경쟁해보세요">
</head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MHYFCQ35XR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MHYFCQ35XR');
</script>
<body>
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MJPN92FN"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div class="difficulty-picker">
        <button class="difficulty-btn" data-level="beginner" data-size="3">■</button>
        <button class="difficulty-btn active" data-level="intermediate" data-size="4">■</button>
        <button class="difficulty-btn" data-level="advanced" data-size="5">■</button>
        <button class="difficulty-btn" data-level="chaos" data-size="?">■</button>
    </div>
    <div class="game-container">
        <div class="score">
            Score: <span id="score">0</span>
            <div class="time-display">⏰ 0s</div>
        </div>
        <div id="board" class="board"></div>
        <div id="block-container" class="block-container"></div>
    </div>

    <!-- 테스트 패널 (실제 게임에는 노출되지 않음) -->
    <div class="test-panel">
        <button onclick="testCombo()">테스트 콤보</button>
        <button onclick="testCross()">테스트 크로스</button>
        <button onclick="toggleAutoPlay()">자동플레이 ${isAutoPlaying ? '중지' : '시작'}</button>
        <button onclick="testGameOver()">게임오버 테스트</button>
        <button onclick="testGameClear()">게임클리어 테스트</button>
    </div>

    <!-- 힌트 패널 수정 -->
    <div class="hint-panel">
        <button onclick="refreshBlocks()">🔄</button>
        <button onclick="rotateCurrentBlocks()">↻</button>
        <button onclick="showPossiblePlacement()">💡</button>
    </div>

    <!-- 게임 오버 팝업 (초기 숨김) -->
    <div id="gameOverPopup" class="game-over-popup" style="display: none;">
        <h2 id="popupTitle">GAME OVER</h2>
        <p>Score: <span id="popupScore">0</span></p>
        <p>Time: <span id="popupTime">0</span>s</p>
        <button onclick="resetGame()">Play Again</button>
    </div>

    <!-- 푸터 섹션 -->
    <div style="
        text-align: center;
        padding: 20px 0;
        color: #888;
        font-family: 'Arial', sans-serif;
        position: relative;
        z-index: 100;
        background: rgba(255,255,255,0.1);
        margin-top: 30px;
    ">
        <a href="https://cocy.io" 
           target="_blank" 
           style="
               color: #6b4f40;
               text-decoration: none;
               font-weight: bold;
               transition: color 0.3s;
               display: inline-block;
               margin: 0 10px;
           "
           onmouseover="this.style.color='#8b7355'" 
           onmouseout="this.style.color='#6b4f40'">
            COCY.IO
        </a>
        <span style="color: #666;">|</span>
        <span style="font-size: 0.9em;">All rights reserved © 2025</span>
    </div>

    <script>
        // 게임 상수
        const BOARD_SIZE = 9;
        
        // 게임 상태 변수 선언 부분 수정
        let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));
        let score = 0;
        let draggedBlock = null;
        let dragOffset = { x: 0, y: 0 };
        let previewCells = [];
        let currentLevel = 'intermediate'; // 전역 변수로 이동

        // 성능 최적화를 위한 변수 추가
        let lastValidPosition = null;
        const boardCells = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));

        // 점수 관련 전역 변수 추가
        let comboCount = 0;
        let lastClearTurn = 0;
        let currentTurn = 0;

        // 전역 변수 추가
        let isValidDrag = false;
        let hintPreviewCells = [];

        // 전역 변수에 힌트 비용 추가
        const HINT_COSTS = {
            refresh: 10,
            rotate: 5,
            placement: 1
        };

        // 레벨 시스템 구현 (수정 버전)
        const BLOCK_CATEGORIES = {
            beginner: [ 
                [[1]],
                [[1,1]],
                [[1],[1]],
                [[1,1,1]],
                [[1,1],[1,0]],  // L 모양
                [[1,0],[1,1]],  // J 모양
                [[0,1],[1,1]],  // ㄱ 모양
                [[1,1],[0,1]]  // ㄴ 모양
            ],
            intermediate: [
                // 테트리스 블록 + 기타 블록 (문제 패턴 제외)
                [[1,1,1,1]],           // I
                [[1,1],[1,1]],         // O
                [[1,1,1],[0,1,0]],     // T
                [[1,1,0],[0,1,1]],     // S 
                [[0,1,1],[1,1,0]],     // Z
                [[1,1,1],[1,0,0]],     // L
                [[1,1,1],[0,0,1]],     // J
                [[0,1,0],[1,1,1]],     // ㅗ
                [[1,0],[1,1],[1,0]]    // ㅓ
                // [[1,1],[1,0],[0,1]] 패턴 제거됨
            ],
            advanced: [ 
                [[1,1,1,1,1]], 
                [[1,1,1],[1,0,0],[1,0,0]],
                [[1,1,1],[0,1,0],[0,1,0]],
                [[1,1],[1,1],[1,0]],
                [[1,1,1,1],[0,0,0,1]],
                [[1,1,1],[1,1,1]],
                [[1,1,1,1],[1,1,0,0]],
                [[1,1,1],[1,0,1],[1,0,1]],
                [[1,0,1],[1,1,1],[1,0,1]]
            ],
            chaos: [] // 초기 빈 배열
        };

        // 카오스 배열 별도 초기화
        BLOCK_CATEGORIES.chaos = [
            ...BLOCK_CATEGORIES.beginner,
            ...BLOCK_CATEGORIES.intermediate,
            ...BLOCK_CATEGORIES.advanced,
            [[1,1,1,1],[1,1,1,1]],       
            [[1,1],[1,1],[1,1],[1,1]],   
            [[1,1,1],[1,0,1],[1,1,1]]     
        ];

        // 게임 상태 변수에 gameOver 추가
        let gameOver = false;

        // 게임 상태 변수 추가
        let gameStartTime = null;
        let currentTime = 0;
        let timerInterval = null;
        let gameClear = false;
        let isGameRunning = false;

        // 전역 변수 추가
        let isAutoPlaying = false;
        let autoPlayInterval = null;

        // 게임 종료 조건 검사 함수
        function checkGameOver() {
            const availableBlocks = document.querySelectorAll('.block-wrapper');
            let hasPossibleMoves = false;
            
            // 1. 현재 블록의 배치 가능성 확인
            for (const block of availableBlocks) {
                const pattern = JSON.parse(block.dataset.pattern);
                if(hasPlacementForPattern(pattern)) {
                    hasPossibleMoves = true;
                    break;
                }
            }
            if(hasPossibleMoves) return false;

            // 2. 모든 힌트 사용 가능 여부 확인 (실제 사용 가능한지)
            const canUseAnyHint = Object.values(HINT_COSTS).some(cost => score >= cost);
            
            // 3. 최종 판단
            return !canUseAnyHint;
        }

        // 패턴 배치 가능 여부 확인 함수
        function hasPlacementForPattern(pattern) {
            for (let y = -pattern.length + 1; y < BOARD_SIZE; y++) {
                for (let x = -pattern[0].length + 1; x < BOARD_SIZE; x++) {
                    if (isValidPosition(y, x, pattern)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 수정된 setDifficulty 함수
        function setDifficulty(level) {
            currentLevel = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active'); // 모든 버튼에서 active 제거
                if(btn.dataset.level === level) {
                    btn.classList.add('active'); // 선택된 버튼에만 active 추가
                }
            });
            generateNewBlocks();
        }

        // 수정된 이벤트 리스너 (이벤트 위임 방식으로 변경)
        document.querySelector('.difficulty-picker').addEventListener('click', function(e) {
            if(e.target.classList.contains('difficulty-btn')) {
                setDifficulty(e.target.dataset.level);
                // 버튼 애니메이션 효과
                e.target.animate([
                    { transform: 'scale(1.2)', opacity: 0.8 },
                    { transform: 'scale(1)', opacity: 1 }
                ], { duration: 300 });
            }
        });

        // 수정된 initGame 함수
        function initGame() {
            createBoard();
            currentLevel = 'intermediate';
            setDifficulty(currentLevel);
            updateScore();
            createHintPanel();
            updateButtonStates();
            
            // 타이머 초기화
            gameStartTime = Date.now();
            currentTime = 0;
            gameClear = false;
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
        }

        // 보드 생성
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    boardElement.appendChild(cell);
                    boardCells[i][j] = cell; // 캐시 저장
                }
            }
        }

        // 힌트 시스템 변수
        let hintActive = false;

        // 블록 생성 로직 수정
        function generateNewBlocks(force = false) {
            const container = document.getElementById('block-container');
            if(!force && container.children.length > 0) return;
            
            container.innerHTML = '';
            const cellSize = document.querySelector('.cell').offsetWidth;
            const patterns = BLOCK_CATEGORIES[currentLevel];
            
            // 필터링 로직 추가
            const filteredPatterns = patterns.filter(p => 
                JSON.stringify(p) !== JSON.stringify([[1,1],[1,0],[0,1]])
            );

            for (let i = 0; i < 3; i++) {
                let pattern = filteredPatterns[Math.floor(Math.random() * filteredPatterns.length)];
                
                // 기존 회전 로직 유지
                if(Math.random() < 0.25) {
                    pattern = rotatePattern(pattern);
                }
                
                const blockWrapper = createBlockElement(pattern, cellSize);
                initDragEvents(blockWrapper);
                container.appendChild(blockWrapper);
            }
        }

        // 블록 엘리먼트 생성
        function createBlockElement(pattern, cellSize) {
            const blockWrapper = document.createElement('div');
            blockWrapper.className = 'block-wrapper';
            blockWrapper.dataset.pattern = JSON.stringify(pattern);
            
            const container = document.createElement('div');
            container.style.display = 'inline-block';
            container.style.margin = '8px';
            
            const blockGrid = document.createElement('div');
            blockGrid.className = 'block-grid';
            blockGrid.style.setProperty('--cols', pattern[0].length); /* CSS 변수 사용 */
            
            // 패턴에 따라 셀 크기 동적 조정
            const baseSize = Math.min(cellSize * 0.9, 40); // 최대 40px 제한
            pattern.forEach(row => {
                row.forEach(cell => {
                    const blockCell = document.createElement('div');
                    if (cell === 1) {
                        blockCell.className = 'block-cell';
                        blockCell.style.width = `${baseSize}px`;
                        blockCell.style.height = `${baseSize}px`;
                    }
                    // 빈 셀도 동일한 크기 유지
                    blockCell.style.width = `${baseSize}px`; 
                    blockCell.style.height = `${baseSize}px`;
                    blockGrid.appendChild(blockCell);
                });
            });
            
            container.appendChild(blockGrid);
            blockWrapper.appendChild(container);
            return blockWrapper;
        }

        // 드래그 이벤트 초기화
        function initDragEvents(blockWrapper) {
            blockWrapper.addEventListener('mousedown', startDragging);
            blockWrapper.addEventListener('touchstart', startDragging, { passive: false });
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('touchmove', handleDrag, { passive: false });
            
            document.addEventListener('mouseup', endDragging);
            document.addEventListener('touchend', endDragging);
        }

        // 드래그 시작
        function startDragging(e) {
            e.preventDefault();
            draggedBlock = e.currentTarget;
            
            const rect = draggedBlock.getBoundingClientRect();
            const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            
            // 오른쪽 하단 기준 오프셋 계산
            const pattern = JSON.parse(draggedBlock.dataset.pattern);
            dragOffset.x = clientX - (rect.left + rect.width - pattern[0].length * rect.width/pattern[0].length);
            dragOffset.y = clientY - (rect.top + rect.height - pattern.length * rect.height/pattern.length);
            
            draggedBlock.style.position = 'fixed';
            draggedBlock.style.zIndex = '1000';
            
            updateBlockPosition(clientX, clientY);
        }

        // 드래그 중
        function handleDrag(e) {
            if (!draggedBlock) return;
            
            try {
                e.preventDefault();
                const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
                
                updateBlockPosition(clientX, clientY);
                isValidDrag = checkValidDragPosition(clientX, clientY); // 유효 위치 확인
                showPreview(clientX, clientY);
            } catch (error) {
                console.error('Drag error:', error);
                safeResetDraggedBlock();
            }
        }

        function checkValidDragPosition(x, y) {
            const board = document.getElementById('board');
            if (!board) return false;
            
            const rect = board.getBoundingClientRect();
            return x >= rect.left && x <= rect.right &&
                   y >= rect.top && y <= rect.bottom;
        }

        // 블록 위치 업데이트
        function updateBlockPosition(clientX, clientY) {
            draggedBlock.style.left = `${clientX - dragOffset.x}px`;
            draggedBlock.style.top = `${clientY - dragOffset.y}px`;
        }

        function isValidPosition(row, col, pattern) {
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[0].length; j++) {
                    if (pattern[i][j] === 1) {
                        const x = col + j;
                        const y = row + i;
                        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE || board[y][x]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // 미리보기 성능 개선 버전
        function showPreview(x, y) {
            if (!draggedBlock) return;

            const pattern = JSON.parse(draggedBlock.dataset.pattern);
            const boardRect = document.getElementById('board').getBoundingClientRect();
            const cellSize = boardRect.width / BOARD_SIZE;

            const row = Math.round((y - boardRect.top - cellSize/2) / cellSize);
            const col = Math.round((x - boardRect.left - cellSize/2) / cellSize);
            const adjustRow = row - Math.floor(pattern.length/2);
            const adjustCol = col - Math.floor(pattern[0].length/2);

            // 위치 변경 없으면 업데이트 생략
            if (lastValidPosition?.row === adjustRow && lastValidPosition?.col === adjustCol) return;
            lastValidPosition = {row: adjustRow, col: adjustCol};

            clearPreview();

            // 유효성 검사 최적화
            let isValid = true;
            outer: for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[0].length; j++) {
                    if (pattern[i][j] === 1) {
                        const y = adjustRow + i;
                        const x = adjustCol + j;
                        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE || board[y][x]) {
                            isValid = false;
                            break outer;
                        }
                    }
                }
            }

            if (!isValid) return;

            // 일괄 업데이트
            const updates = [];
            pattern.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell === 1) {
                        const y = adjustRow + i;
                        const x = adjustCol + j;
                        if (boardCells[y]?.[x]) {
                            updates.push(boardCells[y][x]);
                        }
                    }
                });
            });

            updates.forEach(cell => cell.classList.add('preview'));
            previewCells = updates;
        }

        function clearPreview() {
            previewCells.forEach(cell => cell.classList.remove('preview'));
            previewCells = [];
            clearHintPreview(); // 힌트도 함께 제거
        }

        // 드래그 종료
        function endDragging(e) {
            if (!draggedBlock) return;
            
            // 안전한 DOM 접근
            const board = document.getElementById('board');
            if (!board) return;

            try {
                clearPreview();
                const boardRect = board.getBoundingClientRect();
                const clientX = e.type === 'mouseup' ? e.clientX : e.changedTouches[0].clientX;
                const clientY = e.type === 'mouseup' ? e.clientY : e.changedTouches[0].clientY;
                
                if (isOverBoard(clientX, clientY, boardRect) && isValidDrag) {
                    const pattern = JSON.parse(draggedBlock.dataset.pattern);
                    const cellSize = boardRect.width / BOARD_SIZE;
                    const row = Math.round((clientY - boardRect.top - cellSize/2) / cellSize);
                    const col = Math.round((clientX - boardRect.left - cellSize/2) / cellSize);
                    const adjustRow = row - Math.floor(pattern.length/2);
                    const adjustCol = col - Math.floor(pattern[0].length/2);
                    
                    tryPlaceBlock(adjustRow, adjustCol);
                }
            } catch (error) {
                console.error('Drag end error:', error);
            } finally {
                safeResetDraggedBlock();
            }
        }

        function safeResetDraggedBlock() {
            if (draggedBlock) {
                // 안전한 스타일 복구
                if (draggedBlock.style) {
                    draggedBlock.style.position = '';
                    draggedBlock.style.left = '';
                    draggedBlock.style.top = '';
                    draggedBlock.style.zIndex = '';
                }
                // 부모 노드가 존재하면 원래 위치로 복구
                if (draggedBlock.parentNode) {
                    const container = document.getElementById('block-container');
                    if (container) container.appendChild(draggedBlock);
                }
                draggedBlock = null;
            }
            isValidDrag = false;
        }

        // 보드 위에 있는지 확인
        function isOverBoard(x, y, boardRect) {
            return x >= boardRect.left && x <= boardRect.right &&
                   y >= boardRect.top && y <= boardRect.bottom;
        }

        // 블록 배치 시도
        function tryPlaceBlock(row, col) {
            const pattern = JSON.parse(draggedBlock.dataset.pattern);
            // 미리보기에서 사용한 canPlaceBlock과 동일한 조건
            if (canPlaceBlock(row, col, pattern)) {  // 음수 체크 제거
                placeBlock(row, col, pattern);
                draggedBlock.remove();
                if (document.querySelectorAll('.block-wrapper').length === 0) {
                    generateNewBlocks();
                }
            }
        }

        // 블록 배치 가능 확인
        function canPlaceBlock(row, col, pattern) {
            // 버퍼 영역 내에서만 체크
            const buffer = 1;
            if (row < -buffer || col < -buffer) return false;
            
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[0].length; j++) {
                    if (pattern[i][j] === 1) {
                        const newRow = row + i;
                        const newCol = col + j;
                        
                        if (newRow >= BOARD_SIZE + buffer || 
                            newCol >= BOARD_SIZE + buffer || 
                            (newRow >= 0 && newCol >= 0 && board[newRow][newCol])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // 블록 배치
        function placeBlock(row, col, pattern) {
            if (!isGameRunning) {
                isGameRunning = true;
                gameStartTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
            }
            currentTurn++;  // 블록 배치 시 무조건 턴 증가
            pattern.forEach((patternRow, i) => {
                patternRow.forEach((cell, j) => {
                    if (cell === 1) {
                        const newRow = row + i;
                        const newCol = col + j;
                        board[newRow][newCol] = true;
                        const cellElement = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                        cellElement.classList.add('filled');
                    }
                });
            });
            score += pattern.flat().filter(cell => cell === 1).length;
            updateScore();
            
            const linesCleared = checkLines();  // 라인 클리어 결과 저장
            
            if (!linesCleared) {
                // 라인 클리어 실패 시 콤보 리셋
                comboCount = 0;
            }
            
            if (checkGameOver()) {
                handleGameOver();
            } else {
                generateNewBlocks();
            }
        }

        // 수정된 checkLines 함수
        function checkLines() {
            let linesCleared = 0;
            const rows = [];
            const cols = [];

            // 가로줄 확인
            for (let row = 0; row < BOARD_SIZE; row++) {
                if (board[row].every(cell => cell)) {
                    rows.push(row);
                    linesCleared++;
                }
            }
            
            // 세로줄 확인
            for (let col = 0; col < BOARD_SIZE; col++) {
                if (board.every(row => row[col])) {
                    cols.push(col);
                    linesCleared++;
                }
            }

            // 크로스 계산 (가로+세로 동시 클리어)
            let crossCount = 0;
            rows.forEach(r => {
                cols.forEach(c => {
                    if (board[r][c]) { // 교차점이 실제 채워져 있었는지 확인
                        crossCount++;
                    }
                });
            });

            // 클리어 애니메이션 처리
            rows.forEach(row => clearLine(row, 'row'));
            cols.forEach(col => clearLine(col, 'column'));

            if (linesCleared > 0) {
                comboCount = linesCleared;
                lastClearTurn = currentTurn;

                const baseScore = 100 * linesCleared;
                const crossBonus = crossCount > 0 ? 2 : 1;
                const totalScore = baseScore * crossBonus;

                score += totalScore;
                updateScore();
                
                // 콤보 효과 표시 (항상 실행)
                showEffect({
                    combo: linesCleared,
                    score: baseScore
                });
                
                // 크로스 추가 효과 표시
                if(crossCount > 0) {
                    showEffect({
                        cross: crossCount,
                        score: totalScore - baseScore
                    });
                }
            }

            return linesCleared > 0;
        }

        // 점수 업데이트
        function updateScore() {
            document.getElementById('score').innerHTML = `
                ${score}
            `;
            updateButtonStates();
            
            // 10000점 달성 시 게임 클리어
            if(score >= 10000 && !gameClear) {
                handleGameOver();
            }
        }

        // 게임 오버 처리
        function handleGameOver() {
            isGameRunning = false;
            clearInterval(timerInterval);
            
            const popup = document.getElementById('gameOverPopup');
            popup.style.display = 'block';
            document.getElementById('popupScore').textContent = score;
            document.getElementById('popupTime').textContent = currentTime;
            
            if(score >= 10000) {
                document.getElementById('popupTitle').textContent = 'CLEAR!!';
                popup.style.background = '#6b4f40';
            } else {
                document.body.classList.add('game-over');
            }
        }

        // 게임 리셋
        function resetGame() {
            document.getElementById('gameOverPopup').style.display = 'none';
            document.body.classList.remove('game-over');
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));
            score = 0;
            gameClear = false;
            initGame();
        }

        // initGame 호출로 게임 시작
        initGame();

        // 수정된 showEffect 함수
        function showEffect(options) {
            const effectDiv = document.createElement('div');
            effectDiv.className = 'score-effect';
            
            // 기존 콤보/크로스 효과
            if(options.combo || options.cross) {
                effectDiv.textContent = `${options.combo ? options.combo+' Combo! ' : ''}${options.cross ? 'X'+options.cross+' Cross! ' : ''}+${options.score}`;
                effectDiv.style.color = options.combo ? '#e74c3c' : '#3498db';
            }
            // 차감 효과
            else if(options.type === 'deduction') {
                effectDiv.className += ' deduction';
                effectDiv.textContent = `-${options.score}`;
                effectDiv.style.color = '#ff4757';
            }
            // Nope!! 효과
            else if(options.text) {
                effectDiv.textContent = options.text;
                effectDiv.style.color = options.color || '#ff4757';
                effectDiv.style.fontSize = '3em';
                effectDiv.style.animation = 'nopeShake 0.8s ease';
            }

            effectDiv.style.left = `calc(50% + ${Math.random()*40-20}px)`;
            document.body.appendChild(effectDiv);
            setTimeout(() => effectDiv.remove(), options.duration || 3000);
        }

        // 테스트용 함수
        function testCombo() {
            const testCases = [
                { lines: 1, combo: 1 },
                { lines: 1, combo: 2 },
                { lines: 1, combo: 3 },
                { lines: 1, combo: 4 }
            ];
            
            testCases.forEach((tc, i) => {
                setTimeout(() => {
                    showEffect({
                        combo: tc.combo,
                        cross: tc.lines,
                        score: 10 * tc.lines * tc.combo
                    });
                }, i * 1000);
            });
        }

        function testCross() {
            const testCases = [
                { lines: 2, combo: 1 },
                { lines: 3, combo: 1 },
                { lines: 2, combo: 2 },
                { lines: 3, combo: 3 }
            ];
            
            testCases.forEach((tc, i) => {
                setTimeout(() => {
                    showEffect({
                        combo: tc.combo,
                        cross: tc.lines,
                        score: 10 * tc.lines * tc.combo
                    });
                }, i * 1000);
            });
        }

        // 테스트 패널 토글 기능 추가
        let testClickCount = 0;
        const testPanelHTML = `
            <button onclick="testCombo()">테스트 콤보</button>
            <button onclick="testCross()">테스트 크로스</button>
            <button onclick="toggleAutoPlay()">자동플레이 ${isAutoPlaying ? '중지' : '시작'}</button>
            <button onclick="testGameOver()">게임오버 테스트</button>
            <button onclick="testGameClear()">게임클리어 테스트</button>
        `;
        document.getElementById('score').addEventListener('click', function() {
            testClickCount++;
            if (testClickCount >= 5) {
                const panel = document.querySelector('.test-panel');
                panel.innerHTML = testPanelHTML; // 새로운 버튼 구성
                panel.style.display = 'block';
                setTimeout(() => {
                    panel.style.display = 'none';
                    testClickCount = 0;
                }, 5000);
            }
        });

        // 자동 배치 함수
        function autoPlaceBlock() {
            const blocks = [...document.querySelectorAll('.block-wrapper')];
            
            // 블록이 없는 경우 새로 생성
            if(blocks.length === 0) {
                generateNewBlocks(true); // 강제 생성
                return true;
            }

            for(const block of blocks) {
                const pattern = JSON.parse(block.dataset.pattern);
                for(let y = -pattern.length+1; y < BOARD_SIZE; y++) {
                    for(let x = -pattern[0].length+1; x < BOARD_SIZE; x++) {
                        if(isValidPosition(y, x, pattern)) {
                            placeBlock(y, x, pattern);
                            block.remove();
                            
                            // 블록 소진 시 새로 생성
                            if(document.querySelectorAll('.block-wrapper').length === 0) {
                                generateNewBlocks(true);
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 자동플레이 토글 함수
        function toggleAutoPlay() {
            isAutoPlaying = !isAutoPlaying;
            const btn = document.querySelector('.test-panel button:nth-child(3)');
            btn.textContent = `자동플레이 ${isAutoPlaying ? '중지' : '시작'}`;
            btn.style.background = isAutoPlaying ? '#27ae60' : '#e74c3c';
            
            if(isAutoPlaying) {
                autoPlayInterval = setInterval(() => {
                    if(!autoPlaceBlock() || checkGameOver()) {
                        toggleAutoPlay(); // 자동 중지
                    }
                }, 1000); // 1초 간격
            } else {
                clearInterval(autoPlayInterval);
            }
        }

        // 힌트 패널 생성
        function createHintPanel() {
            const panel = document.querySelector('.hint-panel');
            if (panel) return; // 이미 존재하면 생성하지 않음
            
            const newPanel = document.createElement('div');
            newPanel.className = 'hint-panel';
            newPanel.innerHTML = `
                <button onclick="refreshBlocks()">🔄</button>
                <button onclick="rotateCurrentBlocks()">↻</button>
                <button onclick="showPossiblePlacement()">💡</button>
            `;
            document.body.appendChild(newPanel);
        }

        // 버튼 상태 업데이트 함수
        function updateButtonStates() {
            const buttons = document.querySelectorAll('.hint-panel button');
            buttons.forEach(btn => {
                const cost = getButtonCost(btn);
                btn.disabled = score < cost;
                btn.style.opacity = score < cost ? 0.5 : 1;
            });
        }

        // 버튼별 비용 확인
        function getButtonCost(button) {
            if(button.onclick.toString().includes('refresh')) return HINT_COSTS.refresh;
            if(button.onclick.toString().includes('rotate')) return HINT_COSTS.rotate;
            if(button.onclick.toString().includes('showPossible')) return HINT_COSTS.placement;
            return 0;
        }

        // 수정된 refreshBlocks 함수
        function refreshBlocks() {
            if(score < HINT_COSTS.refresh) return;
            const cost = HINT_COSTS.refresh;
            score -= cost;
            updateScore();
            showEffect({ score: cost, type: 'deduction' });
            generateNewBlocks(true);
            
            // 힌트 사용 후 게임 오버 확인
            if(checkGameOver()) handleGameOver();
        }

        // 수정된 rotateCurrentBlocks 함수
        function rotateCurrentBlocks() {
            if(score < HINT_COSTS.rotate) return;
            const cost = HINT_COSTS.rotate;
            score -= cost;
            updateScore();
            showEffect({ score: cost, type: 'deduction' });
            
            // 기존 회전 로직 유지
            document.querySelectorAll('.block-wrapper').forEach(block => {
                const pattern = JSON.parse(block.dataset.pattern);
                const rotated = rotatePattern(pattern);
                const blockGrid = block.querySelector('.block-grid');
                
                // 애니메이션 시작
                blockGrid.style.transition = 'transform 0.3s ease';
                blockGrid.style.transform = 'rotate(90deg)';
                
                setTimeout(() => {
                    // 실제 패턴 업데이트
                    blockGrid.style.transition = 'none';
                    blockGrid.style.transform = 'rotate(0deg)';
                    
                    // 그리드 내용 업데이트
                    blockGrid.innerHTML = ''; // 기존 내용 제거
                    rotated.forEach(row => {
                        const rowDiv = document.createElement('div');
                        rowDiv.style.display = 'contents'; // 레이아웃 유지
                        row.forEach(cell => {
                            const cellDiv = document.createElement('div');
                            cellDiv.className = cell === 1 ? 'block-cell' : '';
                            rowDiv.appendChild(cellDiv);
                        });
                        blockGrid.appendChild(rowDiv);
                    });
                    
                    // 데이터 업데이트
                    block.dataset.pattern = JSON.stringify(rotated);
                    blockGrid.style.gridTemplateColumns = `repeat(${rotated[0].length}, 36px)`;
                }, 300);
            });
            
            // 힌트 사용 후 게임 오버 확인
            if(checkGameOver()) handleGameOver();
        }

        // 수정된 showPossiblePlacement 함수
        function showPossiblePlacement() {
            if(score < HINT_COSTS.placement) return;
            const cost = HINT_COSTS.placement;
            score -= cost;
            updateScore();
            showEffect({ score: cost, type: 'deduction' });
            
            let found = false;
            const blocks = document.querySelectorAll('.block-wrapper');
            
            // 모든 블록에 대해 배치 가능 위치 검사
            blocks.forEach(block => {
                const pattern = JSON.parse(block.dataset.pattern);
                for(let y = -pattern.length + 1; y < BOARD_SIZE; y++) {
                    for(let x = -pattern[0].length + 1; x < BOARD_SIZE; x++) {
                        if(isValidPosition(y, x, pattern)) {
                            highlightPossibleArea(y, x, pattern);
                            found = true;
                            return;
                        }
                    }
                }
            });

            if(!found) {
                showEffect({  // 배치 가능 위치 없을 때 Nope!! 효과
                    text: 'Nope!!',
                    color: '#ff4757',
                    duration: 1500
                });
            } else {
                setTimeout(clearHintPreview, 5000);
            }
            
            // 힌트 사용 후 게임 오버 확인
            if(checkGameOver()) handleGameOver();
        }

        // 수정된 highlightPossibleArea 함수
        function highlightPossibleArea(row, col, pattern) {
            clearHintPreview();
            pattern.forEach((r, i) => {
                r.forEach((c, j) => {
                    if(c === 1) {
                        const y = row + i;
                        const x = col + j;
                        if(y >= 0 && y < BOARD_SIZE && x >= 0 && x < BOARD_SIZE) {
                            const cell = boardCells[y][x];
                            cell.classList.add('hint-preview');
                            hintPreviewCells.push(cell);
                        }
                    }
                });
            });
        }

        // 새로운 힌트 초기화 함수
        function clearHintPreview() {
            hintPreviewCells.forEach(cell => {
                cell.classList.remove('hint-preview');
            });
            hintPreviewCells = [];
        }

        // 회전 함수 수정 (4방향 회전 지원)
        function rotatePattern(pattern, times=1) {
            for(let t=0; t<times; t++){
                const N = pattern.length;
                const M = pattern[0].length;
                const rotated = Array(M).fill().map(() => Array(N).fill(0));
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < M; j++) {
                        rotated[j][N-1-i] = pattern[i][j];
                    }
                }
                pattern = rotated;
            }
            return pattern;
        }

        // 추가할 clearLine 함수
        function clearLine(index, type) {
            // 보드 데이터 업데이트
            if (type === 'row') {
                board[index].fill(false);
            } else {
                for (let row = 0; row < BOARD_SIZE; row++) {
                    board[row][index] = false;
                }
            }

            // 애니메이션 처리
            const selector = type === 'row' 
                ? `[data-row="${index}"]` 
                : `[data-col="${index}"]`;
            
            document.querySelectorAll(selector).forEach(cell => {
                cell.classList.add('clearing');
                setTimeout(() => {
                    cell.classList.remove('filled', 'clearing');
                }, 800);
            });
        }

        // 시간 업데이트 함수
        function updateTimer() {
            if (!isGameRunning) return;
            const current = Math.floor((Date.now() - gameStartTime) / 1000);
            currentTime = current;
            document.querySelector('.time-display').textContent = `⏰ ${current}s`;
        }
    </script>
</body>
</html>
