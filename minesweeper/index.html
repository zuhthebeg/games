<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MV8KQGJF');</script>
<!-- End Google Tag Manager -->

  <title>ÏßÄÎ¢∞Ï∞æÍ∏?/title>
  <style>
    :root {
      --bg: #f4f6fb;
      --panel: #ffffff;
      --text: #10203a;
      --muted: #5d6b84;
      --border: #ccd5e4;
      --accent: #0f6cff;
      --accent-soft: #e8f0ff;
      --danger: #e53935;
      --cell: #d8dfeb;
      --cell-open: #f7f9fd;
      --cell-border: #bcc7da;
      --shadow: 0 12px 32px rgba(16, 32, 58, 0.12);
      --cols: 9;
      --cell-size: clamp(10px, calc((100vw - 28px) / var(--cols)), 34px);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f1524;
        --panel: #182235;
        --text: #e9f0ff;
        --muted: #a9b9d8;
        --border: #31415f;
        --accent: #66a3ff;
        --accent-soft: #213453;
        --danger: #ff6a66;
        --cell: #2d3e5e;
        --cell-open: #1f2c45;
        --cell-border: #41557d;
        --shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
      }
    }

    [data-theme="light"] {
      --bg: #f4f6fb;
      --panel: #ffffff;
      --text: #10203a;
      --muted: #5d6b84;
      --border: #ccd5e4;
      --accent: #0f6cff;
      --accent-soft: #e8f0ff;
      --danger: #e53935;
      --cell: #d8dfeb;
      --cell-open: #f7f9fd;
      --cell-border: #bcc7da;
      --shadow: 0 12px 32px rgba(16, 32, 58, 0.12);
    }

    [data-theme="dark"] {
      --bg: #0f1524;
      --panel: #182235;
      --text: #e9f0ff;
      --muted: #a9b9d8;
      --border: #31415f;
      --accent: #66a3ff;
      --accent-soft: #213453;
      --danger: #ff6a66;
      --cell: #2d3e5e;
      --cell-open: #1f2c45;
      --cell-border: #41557d;
      --shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: "Pretendard", "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 14% 12%, rgba(15, 108, 255, 0.14), transparent 34%),
        radial-gradient(circle at 86% 88%, rgba(229, 57, 53, 0.11), transparent 32%),
        var(--bg);
      min-height: 100vh;
      padding: 14px;
      display: grid;
      place-items: center;
    }

    .app {
      width: min(1120px, 100%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 14px;
      display: grid;
      gap: 12px;
    }

    .top {
      display: grid;
      gap: 10px;
      align-items: center;
    }

    .title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.1rem, 2.8vw, 1.7rem);
      letter-spacing: -0.02em;
    }

    .theme-btn,
    .restart,
    .modal button {
      border: 1px solid var(--border);
      background: var(--accent-soft);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 0.92rem;
      cursor: pointer;
      font-weight: 700;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
    }

    .difficulty {
      width: 100%;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      font-size: 0.95rem;
      font-weight: 700;
    }

    .status {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 9px 10px;
      background: color-mix(in srgb, var(--panel), var(--bg) 24%);
    }

    .label {
      font-size: 0.72rem;
      color: var(--muted);
      margin-bottom: 4px;
      font-weight: 600;
    }

    .value {
      font-weight: 800;
      font-variant-numeric: tabular-nums;
    }

    .board-wrap {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px;
      background: color-mix(in srgb, var(--panel), var(--bg) 18%);
      overflow: auto;
      max-width: 100%;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      width: max-content;
      gap: 2px;
      margin: 0 auto;
      touch-action: manipulation;
      user-select: none;
    }

    .cell {
      border: 1px solid var(--cell-border);
      background: var(--cell);
      border-radius: 5px;
      display: grid;
      place-items: center;
      font-weight: 900;
      font-size: calc(var(--cell-size) * 0.58);
      color: var(--text);
      cursor: pointer;
      line-height: 1;
      padding: 0;
      transition: transform 0.06s ease, background 0.12s ease;
    }

    .cell:active { transform: scale(0.96); }

    .cell.revealed {
      background: var(--cell-open);
      cursor: default;
    }

    .cell.mine {
      background: color-mix(in srgb, var(--danger), transparent 72%);
      color: var(--danger);
    }

    .n1 { color: #2473ff; }
    .n2 { color: #2e9f4a; }
    .n3 { color: #db2f2f; }
    .n4 { color: #5b38d9; }
    .n5 { color: #9d2a2a; }
    .n6 { color: #1c8ca5; }
    .n7 { color: #18222f; }
    .n8 { color: #59667f; }

    .hint {
      color: var(--muted);
      font-size: 0.84rem;
      margin: 0;
      text-align: center;
    }

    .modal-bg {
      position: fixed;
      inset: 0;
      background: rgba(5, 9, 17, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 50;
    }

    .modal {
      width: min(420px, 100%);
      border-radius: 16px;
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 18px;
      text-align: center;
    }

    .modal h2 {
      margin: 0 0 8px;
      font-size: 1.26rem;
    }

    .modal p {
      margin: 0 0 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    @media (min-width: 768px) {
      body { padding: 18px; }
      .app { padding: 18px; gap: 14px; }
      .top { grid-template-columns: 1fr auto; }
      .status { min-width: 420px; }
    }

    @media (min-width: 1100px) {
      .app { padding: 22px; }
      .controls { max-width: 420px; }
    }
  </style>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MV8KQGJF" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <main class="app">
    <section class="top">
      <div>
        <div class="title-row">
          <h1>ÏßÄÎ¢∞Ï∞æÍ∏?/h1>
          <button class="theme-btn" id="themeBtn" type="button">?åÎßà: ?êÎèô</button>
        </div>
        <div class="controls">
          <select class="difficulty" id="difficulty" aria-label="?úÏù¥???†ÌÉù">
            <option value="easy">?¨Ï? (9x9, ÏßÄÎ¢?10)</option>
            <option value="medium">Î≥¥ÌÜµ (16x16, ÏßÄÎ¢?40)</option>
            <option value="hard">?¥Î†§?Ä (30x16, ÏßÄÎ¢?99)</option>
          </select>
          <button class="restart" id="restart" type="button">??Í≤åÏûÑ</button>
        </div>
      </div>
      <div class="status">
        <div class="card">
          <div class="label">?®Ï? ÏßÄÎ¢?/div>
          <div class="value" id="mineCounter">0</div>
        </div>
        <div class="card">
          <div class="label">?úÍ∞Ñ</div>
          <div class="value" id="timer">0Ï¥?/div>
        </div>
        <div class="card">
          <div class="label">ÏµúÍ≥† Í∏∞Î°ù</div>
          <div class="value" id="bestTime">-</div>
        </div>
      </div>
    </section>

    <section class="board-wrap">
      <div class="board" id="board" aria-label="ÏßÄÎ¢∞Ï∞æÍ∏?Î≥¥Îìú" role="grid"></div>
    </section>

    <p class="hint">???¥Î¶≠: ?¥Í∏∞ ¬∑ Í∏∏Í≤å ?ÑÎ•¥Í∏??∞ÌÅ¥Î¶? ÍπÉÎ∞ú</p>
  </main>

  <div class="modal-bg" id="modalBg" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 id="modalTitle"></h2>
      <p id="modalText"></p>
      <button id="modalBtn" type="button">?§Ïãú ?òÍ∏∞</button>
    </div>
  </div>

  <script>
    const DIFFICULTIES = {
      easy: { key: "easy", rows: 9, cols: 9, mines: 10, label: "?¨Ï?" },
      medium: { key: "medium", rows: 16, cols: 16, mines: 40, label: "Î≥¥ÌÜµ" },
      hard: { key: "hard", rows: 16, cols: 30, mines: 99, label: "?¥Î†§?Ä" }
    };

    const LONG_PRESS_MS = 360;
    const BEST_KEY = "minesweeper-best-times-v1";
    const THEME_KEY = "minesweeper-theme";

    const boardEl = document.getElementById("board");
    const timerEl = document.getElementById("timer");
    const mineCounterEl = document.getElementById("mineCounter");
    const bestTimeEl = document.getElementById("bestTime");
    const difficultyEl = document.getElementById("difficulty");
    const modalBg = document.getElementById("modalBg");
    const modalTitle = document.getElementById("modalTitle");
    const modalText = document.getElementById("modalText");
    const modalBtn = document.getElementById("modalBtn");
    const restartBtn = document.getElementById("restart");
    const themeBtn = document.getElementById("themeBtn");

    let grid = [];
    let config = DIFFICULTIES.easy;
    let gameOver = false;
    let firstRevealDone = false;
    let revealedCount = 0;
    let flaggedCount = 0;
    let timer = 0;
    let timerId = null;
    let pointerState = null;

    function loadBestTimes() {
      try {
        return JSON.parse(localStorage.getItem(BEST_KEY) || "{}");
      } catch {
        return {};
      }
    }

    function saveBestTime(key, seconds) {
      const current = loadBestTimes();
      if (!current[key] || seconds < current[key]) {
        current[key] = seconds;
        localStorage.setItem(BEST_KEY, JSON.stringify(current));
      }
    }

    function updateBestTimeText() {
      const current = loadBestTimes();
      const value = current[config.key];
      bestTimeEl.textContent = Number.isInteger(value) ? `${value}Ï¥? : "-";
    }

    function applyTheme(theme) {
      if (theme === "light" || theme === "dark") {
        document.documentElement.setAttribute("data-theme", theme);
      } else {
        document.documentElement.removeAttribute("data-theme");
      }
      localStorage.setItem(THEME_KEY, theme);
      themeBtn.textContent = `?åÎßà: ${theme === "light" ? "Î∞ùÍ≤å" : theme === "dark" ? "?¥Îë°Í≤? : "?êÎèô"}`;
    }

    function rotateTheme() {
      const current = localStorage.getItem(THEME_KEY) || "auto";
      const next = current === "auto" ? "light" : current === "light" ? "dark" : "auto";
      applyTheme(next);
    }

    function createEmptyGrid() {
      return Array.from({ length: config.rows }, (_, r) =>
        Array.from({ length: config.cols }, (_, c) => ({
          r,
          c,
          mine: false,
          revealed: false,
          flagged: false,
          adjacent: 0,
          el: null
        }))
      );
    }

    function neighbors(r, c) {
      const result = [];
      for (let dr = -1; dr <= 1; dr += 1) {
        for (let dc = -1; dc <= 1; dc += 1) {
          if (!dr && !dc) continue;
          const nr = r + dr;
          const nc = c + dc;
          if (nr < 0 || nc < 0 || nr >= config.rows || nc >= config.cols) continue;
          result.push(grid[nr][nc]);
        }
      }
      return result;
    }

    function placeMines() {
      let placed = 0;
      const total = config.rows * config.cols;
      while (placed < config.mines) {
        const idx = Math.floor(Math.random() * total);
        const r = Math.floor(idx / config.cols);
        const c = idx % config.cols;
        const cell = grid[r][c];
        if (cell.mine) continue;
        cell.mine = true;
        placed += 1;
      }
    }

    function computeAdjacency() {
      for (let r = 0; r < config.rows; r += 1) {
        for (let c = 0; c < config.cols; c += 1) {
          const cell = grid[r][c];
          if (cell.mine) {
            cell.adjacent = 0;
            continue;
          }
          cell.adjacent = neighbors(r, c).filter((n) => n.mine).length;
        }
      }
    }

    function relocateMine(r, c) {
      const source = grid[r][c];
      if (!source.mine) return;
      for (let rr = 0; rr < config.rows; rr += 1) {
        for (let cc = 0; cc < config.cols; cc += 1) {
          if (rr === r && cc === c) continue;
          const target = grid[rr][cc];
          if (!target.mine) {
            target.mine = true;
            source.mine = false;
            computeAdjacency();
            return;
          }
        }
      }
    }

    function cellText(cell) {
      if (cell.flagged && !cell.revealed) return "?ö©";
      if (!cell.revealed) return "";
      if (cell.mine) return "?í£";
      return cell.adjacent ? String(cell.adjacent) : "";
    }

    function renderCell(cell) {
      const el = cell.el;
      el.textContent = cellText(cell);
      el.className = "cell";
      if (cell.revealed) el.classList.add("revealed");
      if (cell.revealed && cell.mine) el.classList.add("mine");
      if (cell.revealed && !cell.mine && cell.adjacent) el.classList.add(`n${cell.adjacent}`);
      el.setAttribute("aria-label", `??${cell.r + 1}, ??${cell.c + 1}`);
    }

    function renderAll() {
      for (let r = 0; r < config.rows; r += 1) {
        for (let c = 0; c < config.cols; c += 1) {
          renderCell(grid[r][c]);
        }
      }
    }

    function updateCounters() {
      mineCounterEl.textContent = String(config.mines - flaggedCount);
      timerEl.textContent = `${timer}Ï¥?;
    }

    function startTimerIfNeeded() {
      if (timerId || gameOver) return;
      timerId = setInterval(() => {
        timer += 1;
        updateCounters();
      }, 1000);
    }

    function stopTimer() {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    }

    function showModal(title, text) {
      modalTitle.textContent = title;
      modalText.textContent = text;
      modalBg.style.display = "flex";
    }

    function hideModal() {
      modalBg.style.display = "none";
    }

    function revealAllMines() {
      for (let r = 0; r < config.rows; r += 1) {
        for (let c = 0; c < config.cols; c += 1) {
          if (grid[r][c].mine) {
            grid[r][c].revealed = true;
          }
        }
      }
      renderAll();
    }

    function checkWin() {
      const safeCells = config.rows * config.cols - config.mines;
      if (revealedCount !== safeCells) return;
      gameOver = true;
      stopTimer();
      saveBestTime(config.key, timer);
      updateBestTimeText();
      showModal("?πÎ¶¨!", `${config.label} ?úÏù¥???¥Î¶¨?? ${timer}Ï¥?);
    }

    function floodReveal(r, c) {
      const stack = [grid[r][c]];
      while (stack.length) {
        const cell = stack.pop();
        if (cell.revealed || cell.flagged) continue;
        cell.revealed = true;
        revealedCount += 1;
        renderCell(cell);
        if (cell.adjacent !== 0) continue;
        neighbors(cell.r, cell.c).forEach((n) => {
          if (!n.revealed && !n.mine && !n.flagged) stack.push(n);
        });
      }
    }

    function reveal(r, c) {
      if (gameOver) return;
      const cell = grid[r][c];
      if (cell.revealed || cell.flagged) return;

      if (!firstRevealDone) {
        firstRevealDone = true;
        relocateMine(r, c);
      }

      startTimerIfNeeded();

      if (cell.mine) {
        cell.revealed = true;
        renderCell(cell);
        gameOver = true;
        stopTimer();
        revealAllMines();
        showModal("Í≤åÏûÑ ?§Î≤Ñ", "ÏßÄÎ¢∞Î? Î∞üÏïò?µÎãà?? ?§Ïãú ?ÑÏ†Ñ??Î≥¥ÏÑ∏??");
        return;
      }

      floodReveal(r, c);
      checkWin();
    }

    function toggleFlag(r, c) {
      if (gameOver) return;
      const cell = grid[r][c];
      if (cell.revealed) return;
      cell.flagged = !cell.flagged;
      flaggedCount += cell.flagged ? 1 : -1;
      renderCell(cell);
      updateCounters();
    }

    function onPointerDown(event, r, c) {
      if (event.button !== undefined && event.button !== 0) return;
      if (pointerState && pointerState.timer) {
        clearTimeout(pointerState.timer);
      }
      pointerState = { longPressed: false, timer: null };
      pointerState.timer = setTimeout(() => {
        pointerState.longPressed = true;
        toggleFlag(r, c);
      }, LONG_PRESS_MS);
    }

    function onPointerUp(event, r, c) {
      if (!pointerState) return;
      clearTimeout(pointerState.timer);
      const longPressed = pointerState.longPressed;
      pointerState = null;
      if (longPressed) {
        event.preventDefault();
        return;
      }
      reveal(r, c);
      updateCounters();
    }

    function buildBoard() {
      document.documentElement.style.setProperty("--cols", String(config.cols));
      boardEl.innerHTML = "";
      grid = createEmptyGrid();
      placeMines();
      computeAdjacency();

      for (let r = 0; r < config.rows; r += 1) {
        for (let c = 0; c < config.cols; c += 1) {
          const cell = grid[r][c];
          const button = document.createElement("button");
          button.className = "cell";
          button.type = "button";
          button.setAttribute("role", "gridcell");

          button.addEventListener("pointerdown", (e) => onPointerDown(e, r, c));
          button.addEventListener("pointerup", (e) => onPointerUp(e, r, c));
          button.addEventListener("pointerleave", () => {
            if (pointerState?.timer) clearTimeout(pointerState.timer);
          });

          button.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            toggleFlag(r, c);
          });

          cell.el = button;
          boardEl.appendChild(button);
          renderCell(cell);
        }
      }
    }

    function newGame() {
      hideModal();
      stopTimer();
      gameOver = false;
      firstRevealDone = false;
      revealedCount = 0;
      flaggedCount = 0;
      timer = 0;
      pointerState = null;
      buildBoard();
      updateBestTimeText();
      updateCounters();
    }

    difficultyEl.addEventListener("change", () => {
      config = DIFFICULTIES[difficultyEl.value];
      newGame();
    });

    restartBtn.addEventListener("click", newGame);
    modalBtn.addEventListener("click", newGame);
    modalBg.addEventListener("click", (e) => {
      if (e.target === modalBg) hideModal();
    });
    themeBtn.addEventListener("click", rotateTheme);

    window.addEventListener("blur", () => {
      if (pointerState?.timer) clearTimeout(pointerState.timer);
    });

    applyTheme(localStorage.getItem(THEME_KEY) || "auto");
    config = DIFFICULTIES[difficultyEl.value];
    newGame();
  </script>
</body>
</html>
