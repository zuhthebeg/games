<!DOCTYPE html>
<html lang="ko" >
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MV8KQGJF');</script>
<!-- End Google Tag Manager -->

    <title>��Ŀ - �ػ罺 Ȧ��</title>
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <style>
        :root {
            --bg: #0d1117;
            --table: #1a472a;
            --table-border: #2d5a3d;
            --card-bg: #fff;
            --card-back: #1e3a5f;
            --text: #e6edf3;
            --gold: #ffd700;
            --red: #ef4444;
            --chip: #22c55e;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-top: 50px; /* SharedWallet �� ���� */
        }

        h1 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn.primary {
            background: var(--chip);
            border-color: var(--chip);
            color: #000;
        }

        /* ���̺� ���� */
        .poker-table {
            background: linear-gradient(145deg, var(--table), #0f2d1a);
            border: 8px solid var(--table-border);
            border-radius: 120px;
            padding: 20px;
            margin: 10px 0;
            min-height: 400px;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 0 60px rgba(0,0,0,0.3);
        }

        /* �÷��̾� ���� */
        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .opponent-area {
            margin-bottom: 20px;
        }

        .my-area {
            margin-top: 20px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 20px;
        }

        .player-name {
            font-weight: 600;
        }

        .chip-count {
            color: var(--gold);
            font-weight: 700;
        }

        .dealer-btn {
            background: var(--gold);
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
        }

        /* ī�� */
        .cards {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .card {
            width: 60px;
            height: 84px;
            background: var(--card-bg);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 700;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.3s;
            animation: cardDeal 0.3s ease-out;
        }
        
        @keyframes cardDeal {
            from {
                transform: translateY(-100px) rotate(-20deg) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translateY(0) rotate(0) scale(1);
                opacity: 1;
            }
        }
        
        @keyframes cardFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }
        
        @keyframes cardReveal {
            0% { transform: scale(1); }
            30% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes chipBet {
            from {
                transform: translateY(-30px) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        @keyframes potCollect {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); filter: brightness(1.5); }
            100% { transform: scale(1); filter: brightness(1); }
        }
        
        @keyframes winGlow {
            0%, 100% { box-shadow: 0 0 20px var(--gold); }
            50% { box-shadow: 0 0 40px var(--gold), 0 0 60px var(--gold); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .card.flipping { animation: cardFlip 0.4s ease-in-out; }
        .card.revealing { animation: cardReveal 0.5s ease-out; }
        .chip-animate { animation: chipBet 0.3s ease-out; }
        .pot-animate { animation: potCollect 0.5s ease-out; }
        .win-animate { animation: winGlow 1s ease-in-out 3; }
        .shake-animate { animation: shake 0.3s ease-in-out; }
        
        @keyframes confettiFall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        .sound-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .sound-toggle:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
        
        .sound-toggle.muted {
            opacity: 0.5;
        }

        .card.back {
            background: linear-gradient(135deg, var(--card-back), #0f2840);
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255,255,255,0.03) 10px,
                rgba(255,255,255,0.03) 20px
            );
        }

        .card.red { color: var(--red); }
        .card.black { color: #1a1a1a; }

        .card .rank {
            font-size: 1.4rem;
            line-height: 1;
        }

        .card .suit {
            font-size: 1.6rem;
            line-height: 1;
        }

        /* Ŀ�´�Ƽ ī�� */
        .community-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .community-cards {
            display: flex;
            gap: 8px;
        }

        .community-cards .card {
            width: 55px;
            height: 77px;
        }

        .pot-display {
            background: rgba(0,0,0,0.5);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 1.1rem;
        }

        .pot-amount {
            color: var(--gold);
            font-weight: 700;
        }

        /* ���� ��Ʈ�� */
        .betting-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin-top: 10px;
        }

        .bet-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .bet-btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bet-btn.fold {
            background: #6b7280;
            color: white;
        }

        .bet-btn.check, .bet-btn.call {
            background: #3b82f6;
            color: white;
        }

        .bet-btn.raise, .bet-btn.bet {
            background: var(--chip);
            color: #000;
        }

        .bet-btn.allin {
            background: var(--red);
            color: white;
        }

        .bet-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bet-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bet-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--gold);
            border-radius: 50%;
            cursor: pointer;
        }

        .bet-amount-display {
            min-width: 80px;
            text-align: center;
            font-weight: 700;
            color: var(--gold);
        }

        /* �޽��� */
        .game-message {
            text-align: center;
            padding: 10px;
            font-size: 1.1rem;
            min-height: 40px;
        }

        .hand-result {
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* ��� */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1c2128;
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            width: 100%;
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .hand-rank {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .hand-rank-num {
            width: 30px;
            height: 30px;
            background: var(--gold);
            color: #000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .hand-rank-name {
            font-weight: 600;
            flex: 1;
        }

        .hand-rank-desc {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        /* ��� ȭ�� */
        .result-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px 50px;
            border-radius: 16px;
            text-align: center;
            z-index: 100;
        }

        .result-overlay.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .result-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .result-title.win { color: var(--gold); }
        .result-title.lose { color: var(--red); }
        .result-title.tie { color: #9ca3af; }

        .result-detail {
            font-size: 1rem;
            margin-bottom: 20px;
        }

        /* ������ */
        @media (max-width: 480px) {
            .card {
                width: 50px;
                height: 70px;
                font-size: 1rem;
            }

            .card .rank { font-size: 1.2rem; }
            .card .suit { font-size: 1.3rem; }

            .community-cards .card {
                width: 45px;
                height: 63px;
            }

            .poker-table {
                border-radius: 60px;
                padding: 15px;
            }

            .bet-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        .action-indicator {
            position: absolute;
            background: var(--gold);
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .current-bet {
            font-size: 0.9rem;
            color: var(--gold);
        }

        /* ===== Multiplayer UI ===== */
        .mode-select {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            gap: 20px;
            padding-top: 50px; /* SharedWallet �� ���� */
        }

        .mode-select.hidden { display: none; }

        .mode-select h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .mode-select p {
            color: #9ca3af;
            margin-bottom: 30px;
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mode-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 30px 40px;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 200px;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: var(--gold);
            transform: translateY(-4px);
        }

        .mode-btn .icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 10px;
        }

        .mode-btn .label {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .mode-btn .desc {
            font-size: 0.85rem;
            color: #9ca3af;
            margin-top: 5px;
        }

        /* Lobby */
        .lobby {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            padding-top: 60px; /* SharedWallet �� ���� */
            z-index: 200;
            overflow-y: auto;
        }

        .lobby.hidden { display: none; }

        .lobby-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
        }

        .lobby-header h2 {
            flex: 1;
            font-size: 1.5rem;
        }

        .lobby-content {
            width: 100%;
            max-width: 500px;
        }

        .lobby-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .lobby-section h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-group input {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text);
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: #666;
        }

        /* Waiting Room */
        .waiting-room {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 200;
        }

        .waiting-room.hidden { display: none; }

        .room-code {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--gold);
            margin: 20px 0;
        }

        .room-code-label {
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .player-list {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            margin: 20px 0;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .player-item:last-child { border-bottom: none; }

        .player-item .name { flex: 1; }

        .player-item .status {
            font-size: 0.85rem;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
        }

        .player-item .status.ready {
            background: var(--chip);
            color: #000;
        }

        .player-item .status.host {
            background: var(--gold);
            color: #000;
        }

        .waiting-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .copy-btn {
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .copy-btn:hover { background: rgba(255,255,255,0.1); }

        /* Loading States */
        .btn.loading, .mode-btn.loading {
            pointer-events: none;
            opacity: 0.7;
            position: relative;
        }

        .btn.loading::after, .mode-btn.loading::after {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .share-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .share-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text);
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .share-btn:hover { background: rgba(255,255,255,0.2); }
        .share-btn.primary { background: var(--chip); color: #000; border-color: var(--chip); }
    </style>

<meta name="description" content="1:1 텍사스 홀덤 포커">
<link rel="canonical" href="https://game.cocy.io/poker/">
<meta property="og:title" content="포커 | game.cocy.io">
<meta property="og:description" content="1:1 텍사스 홀덤 포커">
<meta property="og:url" content="https://game.cocy.io/poker/">
<meta property="og:type" content="website">
<meta property="og:locale" content="ko_KR">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="포커 | game.cocy.io">
<meta name="twitter:description" content="1:1 텍사스 홀덤 포커">
<!-- SEO-AUTO:GAME START -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "포커",
  "description": "1:1 텍사스 홀덤 포커",
  "url": "https://game.cocy.io/poker/",
  "inLanguage": "ko-KR",
  "applicationCategory": "Game",
  "operatingSystem": "Web Browser"
}
</script>
<!-- SEO-AUTO:GAME END -->
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MV8KQGJF" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

    <!-- Mode Selection -->
    <div class="mode-select" id="modeSelect">
        <h1>?? �ػ罺 Ȧ��</h1>
        <div id="sharedGoldDisplay" style="background:rgba(255,215,0,0.15);border:1px solid rgba(255,215,0,0.3);border-radius:20px;padding:8px 20px;margin:10px auto;width:fit-content;font-weight:600;">?? 0 G</div>
        <p>���� ��带 �����ϼ���</p>
        <div class="mode-buttons">
            <button class="mode-btn" onclick="startSinglePlayer()">
                <span class="icon">??</span>
                <span class="label">�̱��÷���</span>
                <span class="desc">AI�� 1:1 ����</span>
            </button>
            <button class="mode-btn" onclick="showLobby()">
                <span class="icon">??</span>
                <span class="label">��Ƽ�÷���</span>
                <span class="desc">ģ���� ����</span>
            </button>
        </div>
    </div>

    <!-- Multiplayer Lobby -->
    <div class="lobby hidden" id="lobby">
        <div class="lobby-header">
            <button class="btn" onclick="backToModeSelect()">�� �ڷ�</button>
            <h2>?? ��Ƽ�÷���</h2>
        </div>
        <div class="lobby-content">
            <div class="lobby-section">
                <h3>?? �� ���� �����</h3>
                <div class="input-group" style="margin-bottom:10px;">
                    <input type="text" id="nicknameInput" placeholder="�г��� �Է�" maxlength="20">
                </div>
                <label style="display:flex;align-items:center;gap:8px;margin-bottom:12px;cursor:pointer;">
                    <input type="checkbox" id="publicRoomCheck" checked style="width:18px;height:18px;">
                    <span>?? ���� ���� ��� (���� ��)</span>
                </label>
                <button class="btn primary" onclick="createMultiplayerRoom()" style="width:100%;">�� �����</button>
            </div>
            <div class="lobby-section">
                <h3>?? ���� ����</h3>
                <button class="btn primary" onclick="joinRandomRoom()" style="width:100%;margin-bottom:12px;">?? ���� ��Ī</button>
                <div style="text-align:center;color:#666;margin:8px 0;">�Ǵ�</div>
                <div class="input-group">
                    <input type="text" id="roomCodeInput" placeholder="�� �ڵ� (6�ڸ�)" maxlength="6" style="text-transform: uppercase;">
                    <button class="btn" onclick="joinMultiplayerRoom()">����</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Waiting Room -->
    <div class="waiting-room hidden" id="waitingRoom">
        <button class="btn" onclick="leaveWaitingRoom()" style="position:absolute;top:20px;left:20px;">�� ������</button>
        <h2>����</h2>
        <div class="room-code-label">�� �ڵ�</div>
        <div class="room-code" id="displayRoomCode">------</div>
        <div id="qrCode" style="margin:15px 0;"></div>
        <div class="share-buttons">
            <button class="share-btn" onclick="copyRoomCode()">?? �ڵ� ����</button>
            <button class="share-btn primary" onclick="shareRoomLink()">?? ��ũ ����</button>
        </div>
        
        <div class="player-list" id="playerList">
            <!-- Players will be listed here -->
        </div>
        
        <div class="waiting-actions" id="waitingActions">
            <button class="btn" id="readyBtn" onclick="toggleReady()">�غ�</button>
            <button class="btn primary" id="startBtn" onclick="startMultiplayerGame()">���� ����</button>
            <button class="btn" id="leaveBtn" onclick="leaveWaitingRoom()">������</button>
            <button class="btn" id="destroyBtn" onclick="destroyRoom()" style="background:#ef4444;border-color:#ef4444;display:none;">??? �� ����</button>
        </div>
        <p id="waitingMessage" style="color:#9ca3af;margin-top:15px;">�ٸ� �÷��̾ ��ٸ��� ��...</p>
    </div>

    <div class="game-container" id="gameContainer" style="display:none;">
        <header>
            <h1>?? ��Ŀ</h1>
            <div class="header-buttons">
                <button class="btn" onclick="showRules()">?? ��</button>
                <button class="btn primary" onclick="newGame()">�� ����</button>
            </div>
        </header>

        <div class="poker-table">
            <!-- ��� ���� -->
            <div class="player-area opponent-area">
                <div class="player-info">
                    <span class="player-name">?? ��ǻ��</span>
                    <span class="chip-count" id="opponentChips">1000</span>
                    <span class="dealer-btn" id="opponentDealer" style="display:none">D</span>
                </div>
                <div class="cards" id="opponentCards"></div>
                <div class="hand-result" id="opponentHand" style="display:none"></div>
                <div class="current-bet" id="opponentBet"></div>
            </div>

            <!-- Ŀ�´�Ƽ ī�� -->
            <div class="community-area">
                <div class="community-cards" id="communityCards"></div>
                <div class="pot-display">
                    ��: <span class="pot-amount" id="potAmount">0</span>
                </div>
            </div>

            <!-- ��� �������� -->
            <div class="result-overlay" id="resultOverlay">
                <div class="result-title" id="resultTitle">�¸�!</div>
                <div class="result-detail" id="resultDetail"></div>
                <button class="btn primary" onclick="nextHand()">���� �ڵ�</button>
            </div>

            <!-- �� ���� -->
            <div class="player-area my-area">
                <div class="current-bet" id="myBet"></div>
                <div class="cards" id="myCards"></div>
                <div class="hand-result" id="myHand"></div>
                <div class="player-info">
                    <span class="player-name">?? ��</span>
                    <span class="chip-count" id="myChips">1000</span>
                    <span class="dealer-btn" id="myDealer" style="display:none">D</span>
                </div>
            </div>
        </div>

        <div class="game-message" id="gameMessage">�� ������ �����ϼ���!</div>

        <div class="betting-controls" id="bettingControls" style="display:none">
            <div class="bet-slider-container" id="raiseContainer" style="display:none">
                <input type="range" class="bet-slider" id="betSlider" min="0" max="1000" value="20">
                <div class="bet-amount-display" id="betAmountDisplay">20</div>
            </div>
            <div class="bet-buttons" id="betButtons"></div>
        </div>
    </div>

    <!-- �� ��� -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <h2>
                ?? �ػ罺 Ȧ�� ��
                <button class="close-btn" onclick="closeRules()">��</button>
            </h2>

            <h3 style="margin: 16px 0 8px">?? ���� ����</h3>
            <p style="line-height: 1.6; color: #9ca3af; margin-bottom: 16px">
                1. �� �÷��̾�� 2���� ī��(Ȧī��)�� ��е˴ϴ�.<br>
                2. 5���� Ŀ�´�Ƽ ī�尡 ���������� �����˴ϴ�.<br>
                3. Ȧī�� 2�� + Ŀ�´�Ƽ 5�� �� 5������ �ְ� ������ ����ϴ�.<br>
                4. ���� ����: �����ö� �� �ö� �� �� �� ����
            </p>

            <h3 style="margin: 16px 0 8px">?? ���� �׼�</h3>
            <p style="line-height: 1.6; color: #9ca3af; margin-bottom: 16px">
                <b>����</b>: �����ϰ� ���� ��뿡�� �纸<br>
                <b>üũ</b>: ���� ���� ���� �ѱ�� (��밡 ���� ������ ��)<br>
                <b>��</b>: ��� ���ð� ���� �ݾ� ����<br>
                <b>������</b>: ��� ���ú��� �� ���� ����<br>
                <b>����</b>: ��� Ĩ�� ����
            </p>

            <h3 style="margin: 16px 0 8px">?? �ڵ� ���� (���� ��)</h3>
            
            <div class="hand-rank">
                <div class="hand-rank-num">1</div>
                <div>
                    <div class="hand-rank-name">�ξ� �÷���</div>
                    <div class="hand-rank-desc">A K Q J 10 ���� ����</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">2</div>
                <div>
                    <div class="hand-rank-name">��Ʈ����Ʈ �÷���</div>
                    <div class="hand-rank-desc">���� 5�� ���� ����</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">3</div>
                <div>
                    <div class="hand-rank-name">��ī��</div>
                    <div class="hand-rank-desc">���� ���� 4��</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">4</div>
                <div>
                    <div class="hand-rank-name">Ǯ�Ͽ콺</div>
                    <div class="hand-rank-desc">Ʈ���� + ���</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">5</div>
                <div>
                    <div class="hand-rank-name">�÷���</div>
                    <div class="hand-rank-desc">���� ���� 5��</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">6</div>
                <div>
                    <div class="hand-rank-name">��Ʈ����Ʈ</div>
                    <div class="hand-rank-desc">���� ���� 5��</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">7</div>
                <div>
                    <div class="hand-rank-name">Ʈ����</div>
                    <div class="hand-rank-desc">���� ���� 3��</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">8</div>
                <div>
                    <div class="hand-rank-name">�����</div>
                    <div class="hand-rank-desc">��� 2��</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">9</div>
                <div>
                    <div class="hand-rank-name">�����</div>
                    <div class="hand-rank-desc">���� ���� 2��</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">10</div>
                <div>
                    <div class="hand-rank-name">����ī��</div>
                    <div class="hand-rank-desc">���� ���� ī��</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sound Toggle Button -->
    <button class="sound-toggle" id="soundToggle" onclick="toggleSound()">??</button>

    <script>
        // ===== ���� ��ȭ �ý��� =====
        let sharedGold = 0;
        let cloudSyncEnabled = false;
        const BUY_IN_COST = 500;  // ������ ��� (���)
        const CHIP_VALUE = 0.5;    // Ĩ 1�� = 0.5 ���
        
        async function loadSharedGold() {
            // ���� ���� ���丮������ �ε�
            const localData = localStorage.getItem('enhance_game_v3');
            if (localData) {
                const parsed = JSON.parse(localData);
                sharedGold = parsed.gold || 0;
            }
            
            // �α��� ������ Ŭ���忡�� �ε�
            const token = localStorage.getItem('cocy_auth_token');
            if (!token) return;
            
            try {
                const parts = token.split('.');
                if (parts.length !== 3) return;
                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
                
                if (payload.sub) {
                    cloudSyncEnabled = true;
                    const res = await fetch('https://relay.cocy.io/api/user/data', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data.gold !== undefined) {
                            sharedGold = data.gold;
                        }
                    }
                }
            } catch (e) {
                console.log('Cloud sync failed:', e);
            }
            
            updateGoldDisplay();
        }
        
        async function saveSharedGold() {
            // SharedWallet ���
            if (typeof SharedWallet !== 'undefined') {
                SharedWallet.setGold(sharedGold);
            } else {
                // ����: ���� ����
                const localData = localStorage.getItem('enhance_game_v3');
                const parsed = localData ? JSON.parse(localData) : { gold: 0 };
                parsed.gold = sharedGold;
                localStorage.setItem('enhance_game_v3', JSON.stringify(parsed));
            }
            updateGoldDisplay();
        }
        
        function updateGoldDisplay() {
            const el = document.getElementById('sharedGoldDisplay');
            if (el) {
                el.innerHTML = `?? ${sharedGold.toLocaleString()} G ${cloudSyncEnabled ? '<span style="color:#4ecca3;font-size:0.8em;">??</span>' : ''}`;
            }
        }
        
        // ===== ���� �ý��� =====
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = localStorage.getItem('poker_sound') !== 'false';
        
        function playSound(type) {
            if (!soundEnabled) return;
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                const now = audioCtx.currentTime;
                
                switch (type) {
                    case 'deal':
                        // ī�� �� - ª�� �����̵� �Ҹ�
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        osc.start(now);
                        osc.stop(now + 0.08);
                        break;
                        
                    case 'flip':
                        // ī�� ������
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                        gain.gain.setValueAtTime(0.12, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                        osc.start(now);
                        osc.stop(now + 0.12);
                        break;
                        
                    case 'chips':
                        // Ĩ ���� - Ĩ �Ҹ�
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(2000, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.05);
                        gain.gain.setValueAtTime(0.08, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        // �� ��° Ĩ
                        setTimeout(() => {
                            const osc2 = audioCtx.createOscillator();
                            const gain2 = audioCtx.createGain();
                            osc2.connect(gain2);
                            gain2.connect(audioCtx.destination);
                            osc2.type = 'square';
                            osc2.frequency.setValueAtTime(1800, audioCtx.currentTime);
                            osc2.frequency.exponentialRampToValueAtTime(700, audioCtx.currentTime + 0.05);
                            gain2.gain.setValueAtTime(0.06, audioCtx.currentTime);
                            gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
                            osc2.start();
                            osc2.stop(audioCtx.currentTime + 0.08);
                        }, 50);
                        break;
                        
                    case 'check':
                        // üũ - ��ũ �Ҹ�
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(300, now);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;
                        
                    case 'fold':
                        // ���� - ���� ��
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                        gain.gain.setValueAtTime(0.12, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                        osc.start(now);
                        osc.stop(now + 0.25);
                        break;
                        
                    case 'allin':
                        // ���� - ���ƽ
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.linearRampToValueAtTime(0.2, now + 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                        osc.start(now);
                        osc.stop(now + 0.4);
                        break;
                        
                    case 'win':
                        // �¸� ���ķ�
                        [523, 659, 784, 1047].forEach((freq, i) => {
                            setTimeout(() => {
                                const o = audioCtx.createOscillator();
                                const g = audioCtx.createGain();
                                o.connect(g);
                                g.connect(audioCtx.destination);
                                o.type = 'sine';
                                o.frequency.value = freq;
                                g.gain.setValueAtTime(0.15, audioCtx.currentTime);
                                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                                o.start();
                                o.stop(audioCtx.currentTime + 0.3);
                            }, i * 100);
                        });
                        return;
                        
                    case 'lose':
                        // �й� - �ϰ� ��
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(150, now + 0.4);
                        gain.gain.setValueAtTime(0.12, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                        osc.start(now);
                        osc.stop(now + 0.5);
                        break;
                        
                    case 'reveal':
                        // ��ٿ� ī�� ����
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                        
                    case 'turn':
                        // �� �� �˸�
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(660, now);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;
                }
            } catch (e) {
                console.log('Sound error:', e);
            }
        }
        
        function vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('poker_sound', soundEnabled);
            updateSoundButton();
            showMessage(soundEnabled ? '?? ���� ON' : '?? ���� OFF');
        }
        
        function updateSoundButton() {
            const btn = document.getElementById('soundToggle');
            if (btn) {
                btn.textContent = soundEnabled ? '??' : '??';
                btn.classList.toggle('muted', !soundEnabled);
            }
        }
        
        // ������ �ε� �� ���� ��ư �ʱ�ȭ
        document.addEventListener('DOMContentLoaded', updateSoundButton);

        // ===== ���� ���� =====
        const SUITS = ['��', '��', '?', '��'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        const HAND_NAMES = [
            '����ī��', '�����', '�����', 'Ʈ����', 
            '��Ʈ����Ʈ', '�÷���', 'Ǯ�Ͽ콺', '��ī��', 
            '��Ʈ����Ʈ �÷���', '�ξ� �÷���'
        ];

        let game = {
            deck: [],
            myCards: [],
            opponentCards: [],
            communityCards: [],
            myChips: 1000,
            opponentChips: 1000,
            pot: 0,
            myBet: 0,
            opponentBet: 0,
            dealer: 'me', // 'me' or 'opponent'
            phase: 'idle', // idle, preflop, flop, turn, river, showdown
            currentPlayer: null,
            bigBlind: 20,
            smallBlind: 10,
            minRaise: 20,
            lastRaise: 0
        };

        // ===== �� ���� =====
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ suit, rank });
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function drawCards(count) {
            return game.deck.splice(0, count);
        }

        // ===== ī�� ������ =====
        function renderCard(card, faceDown = false) {
            if (faceDown) {
                return '<div class="card back"></div>';
            }
            const isRed = card.suit === '��' || card.suit === '?';
            return `
                <div class="card ${isRed ? 'red' : 'black'}">
                    <span class="rank">${card.rank}</span>
                    <span class="suit">${card.suit}</span>
                </div>
            `;
        }

        function updateDisplay() {
            // ��� ī��
            const opponentCardsEl = document.getElementById('opponentCards');
            const showOpponent = game.phase === 'showdown';
            opponentCardsEl.innerHTML = game.opponentCards.map(c => renderCard(c, !showOpponent)).join('');

            // �� ī��
            document.getElementById('myCards').innerHTML = game.myCards.map(c => renderCard(c)).join('');

            // Ŀ�´�Ƽ ī��
            document.getElementById('communityCards').innerHTML = game.communityCards.map(c => renderCard(c)).join('');

            // Ĩ
            document.getElementById('myChips').textContent = game.myChips;
            document.getElementById('opponentChips').textContent = game.opponentChips;
            document.getElementById('potAmount').textContent = game.pot;

            // ���� ����
            document.getElementById('myBet').textContent = game.myBet > 0 ? `����: ${game.myBet}` : '';
            document.getElementById('opponentBet').textContent = game.opponentBet > 0 ? `����: ${game.opponentBet}` : '';

            // ���� ��ư
            document.getElementById('myDealer').style.display = game.dealer === 'me' ? 'inline' : 'none';
            document.getElementById('opponentDealer').style.display = game.dealer === 'opponent' ? 'inline' : 'none';

            // �ڵ� ���
            if (game.phase === 'showdown' || game.myCards.length > 0) {
                const myHand = evaluateHand([...game.myCards, ...game.communityCards]);
                document.getElementById('myHand').textContent = HAND_NAMES[myHand.rank];
                document.getElementById('myHand').style.display = 'block';
            } else {
                document.getElementById('myHand').style.display = 'none';
            }

            if (game.phase === 'showdown') {
                const oppHand = evaluateHand([...game.opponentCards, ...game.communityCards]);
                document.getElementById('opponentHand').textContent = HAND_NAMES[oppHand.rank];
                document.getElementById('opponentHand').style.display = 'block';
            } else {
                document.getElementById('opponentHand').style.display = 'none';
            }
        }

        // ===== �ڵ� �� =====
        function getRankValue(rank) {
            return RANKS.indexOf(rank);
        }

        function evaluateHand(cards) {
            if (cards.length < 5) return { rank: 0, value: 0, kickers: [] };

            // 5�� ���� �� �ְ� ã��
            const combos = getCombinations(cards, 5);
            let best = { rank: 0, value: 0, kickers: [] };

            for (const combo of combos) {
                const result = evaluateFiveCards(combo);
                if (compareHands(result, best) > 0) {
                    best = result;
                }
            }

            return best;
        }

        function getCombinations(arr, size) {
            if (size === 1) return arr.map(x => [x]);
            const result = [];
            for (let i = 0; i <= arr.length - size; i++) {
                const head = arr[i];
                const tailCombos = getCombinations(arr.slice(i + 1), size - 1);
                for (const tail of tailCombos) {
                    result.push([head, ...tail]);
                }
            }
            return result;
        }

        function evaluateFiveCards(cards) {
            const ranks = cards.map(c => getRankValue(c.rank)).sort((a, b) => b - a);
            const suits = cards.map(c => c.suit);
            
            const isFlush = suits.every(s => s === suits[0]);
            const isStraight = checkStraight(ranks);
            const isWheel = ranks.join(',') === '12,3,2,1,0'; // A-2-3-4-5
            
            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const countedRanks = Object.entries(rankCounts)
                .sort((a, b) => b[1] - a[1] || b[0] - a[0])
                .map(e => parseInt(e[0]));

            // �ξ� �÷���
            if (isFlush && isStraight && ranks[0] === 12) {
                return { rank: 9, value: 12, kickers: [] };
            }

            // ��Ʈ����Ʈ �÷���
            if (isFlush && (isStraight || isWheel)) {
                return { rank: 8, value: isWheel ? 3 : ranks[0], kickers: [] };
            }

            // ��ī��
            if (counts[0] === 4) {
                return { rank: 7, value: countedRanks[0], kickers: [countedRanks[1]] };
            }

            // Ǯ�Ͽ콺
            if (counts[0] === 3 && counts[1] === 2) {
                return { rank: 6, value: countedRanks[0], kickers: [countedRanks[1]] };
            }

            // �÷���
            if (isFlush) {
                return { rank: 5, value: ranks[0], kickers: ranks.slice(1) };
            }

            // ��Ʈ����Ʈ
            if (isStraight || isWheel) {
                return { rank: 4, value: isWheel ? 3 : ranks[0], kickers: [] };
            }

            // Ʈ����
            if (counts[0] === 3) {
                return { rank: 3, value: countedRanks[0], kickers: countedRanks.slice(1) };
            }

            // �����
            if (counts[0] === 2 && counts[1] === 2) {
                return { rank: 2, value: Math.max(countedRanks[0], countedRanks[1]), 
                        kickers: [Math.min(countedRanks[0], countedRanks[1]), countedRanks[2]] };
            }

            // �����
            if (counts[0] === 2) {
                return { rank: 1, value: countedRanks[0], kickers: countedRanks.slice(1) };
            }

            // ����ī��
            return { rank: 0, value: ranks[0], kickers: ranks.slice(1) };
        }

        function checkStraight(ranks) {
            const unique = [...new Set(ranks)].sort((a, b) => b - a);
            if (unique.length < 5) return false;
            for (let i = 0; i < 4; i++) {
                if (unique[i] - unique[i + 1] !== 1) return false;
            }
            return true;
        }

        function compareHands(a, b) {
            if (a.rank !== b.rank) return a.rank - b.rank;
            if (a.value !== b.value) return a.value - b.value;
            for (let i = 0; i < Math.max(a.kickers.length, b.kickers.length); i++) {
                const ak = a.kickers[i] || 0;
                const bk = b.kickers[i] || 0;
                if (ak !== bk) return ak - bk;
            }
            return 0;
        }

        // ===== ���� ���� =====
        function newGame() {
            game.myChips = 1000;
            game.opponentChips = 1000;
            game.dealer = Math.random() < 0.5 ? 'me' : 'opponent';
            document.getElementById('resultOverlay').classList.remove('active');
            startHand();
        }

        function nextHand() {
            document.getElementById('resultOverlay').classList.remove('active');
            
            if (game.myChips <= 0) {
                showMessage('Ĩ�� �����ϴ�! �� ������ �����ϼ���.');
                return;
            }
            if (game.opponentChips <= 0) {
                showMessage('?? �¸�! ��� Ĩ�� �����ϴ�!');
                return;
            }
            
            game.dealer = game.dealer === 'me' ? 'opponent' : 'me';
            startHand();
        }

        function startHand() {
            game.deck = createDeck();
            game.myCards = drawCards(2);
            game.opponentCards = drawCards(2);
            game.communityCards = [];
            game.pot = 0;
            game.myBet = 0;
            game.opponentBet = 0;
            game.phase = 'preflop';
            game.minRaise = game.bigBlind;
            game.lastRaise = game.bigBlind;

            // ī�� �� ���� (������)
            playSound('deal');
            setTimeout(() => playSound('deal'), 100);
            setTimeout(() => playSound('deal'), 200);
            setTimeout(() => playSound('deal'), 300);

            // �����ε� ����
            if (game.dealer === 'me') {
                // ���� ���� = ���� ���������ε�
                placeBet('me', Math.min(game.smallBlind, game.myChips));
                placeBet('opponent', Math.min(game.bigBlind, game.opponentChips));
                game.currentPlayer = 'me'; // ���������ε尡 ����
            } else {
                placeBet('opponent', Math.min(game.smallBlind, game.opponentChips));
                placeBet('me', Math.min(game.bigBlind, game.myChips));
                game.currentPlayer = 'opponent';
            }

            updateDisplay();
            showMessage('�����ö�');

            if (game.currentPlayer === 'opponent') {
                setTimeout(aiTurn, 1000);
            } else {
                playSound('turn');
                showBettingControls();
            }
        }

        function placeBet(player, amount) {
            if (player === 'me') {
                const bet = Math.min(amount, game.myChips);
                game.myChips -= bet;
                game.myBet += bet;
                game.pot += bet;
            } else {
                const bet = Math.min(amount, game.opponentChips);
                game.opponentChips -= bet;
                game.opponentBet += bet;
                game.pot += bet;
            }
        }

        function showBettingControls() {
            const controls = document.getElementById('bettingControls');
            const buttons = document.getElementById('betButtons');
            const raiseContainer = document.getElementById('raiseContainer');
            
            controls.style.display = 'block';
            
            const toCall = game.opponentBet - game.myBet;
            const canRaise = game.myChips > toCall;
            
            let html = '<button class="bet-btn fold" onclick="playerAction(\'fold\')">����</button>';
            
            if (toCall === 0) {
                html += '<button class="bet-btn check" onclick="playerAction(\'check\')">üũ</button>';
            } else if (toCall > 0 && game.myChips >= toCall) {
                html += `<button class="bet-btn call" onclick="playerAction('call')">�� (${toCall})</button>`;
            }
            
            if (canRaise && game.myChips > toCall) {
                html += '<button class="bet-btn raise" onclick="playerAction(\'raise\')">������</button>';
                raiseContainer.style.display = 'flex';
                
                const slider = document.getElementById('betSlider');
                const minRaise = toCall + game.minRaise;
                slider.min = minRaise;
                slider.max = game.myChips;
                slider.value = Math.min(minRaise * 2, game.myChips);
                updateBetDisplay();
            } else {
                raiseContainer.style.display = 'none';
            }
            
            if (game.myChips > 0) {
                html += `<button class="bet-btn allin" onclick="playerAction('allin')">���� (${game.myChips})</button>`;
            }
            
            buttons.innerHTML = html;
        }

        function updateBetDisplay() {
            const slider = document.getElementById('betSlider');
            document.getElementById('betAmountDisplay').textContent = slider.value;
        }

        document.getElementById('betSlider').addEventListener('input', updateBetDisplay);

        function playerAction(action) {
            const toCall = game.opponentBet - game.myBet;
            
            switch (action) {
                case 'fold':
                    playSound('fold');
                    vibrate(50);
                    endHand('opponent');
                    return;
                    
                case 'check':
                    playSound('check');
                    break;
                    
                case 'call':
                    playSound('chips');
                    vibrate(30);
                    placeBet('me', toCall);
                    animateBet('me');
                    break;
                    
                case 'raise':
                    const raiseAmount = parseInt(document.getElementById('betSlider').value);
                    playSound('chips');
                    vibrate([30, 20, 30]);
                    placeBet('me', raiseAmount);
                    animateBet('me');
                    game.lastRaise = raiseAmount - toCall;
                    game.minRaise = game.lastRaise;
                    break;
                    
                case 'allin':
                    playSound('allin');
                    vibrate([50, 30, 100]);
                    placeBet('me', game.myChips);
                    animateBet('me');
                    break;
            }
            
            document.getElementById('bettingControls').style.display = 'none';
            updateDisplay();
            
            // ���� ���� üũ
            if (game.myBet === game.opponentBet || game.opponentChips === 0 || game.myChips === 0) {
                nextPhase();
            } else {
                game.currentPlayer = 'opponent';
                setTimeout(aiTurn, 800);
            }
        }

        // ===== AI =====
        function aiTurn() {
            const toCall = game.myBet - game.opponentBet;
            const hand = evaluateHand([...game.opponentCards, ...game.communityCards]);
            
            // �ڵ� ���� ��� (0-1)
            let handStrength = hand.rank / 9;
            
            // �����ö� �ڵ� ���� ����
            if (game.communityCards.length === 0) {
                handStrength = evaluatePreflopHand(game.opponentCards);
            }
            
            // �� ���� ���
            const potOdds = toCall / (game.pot + toCall);
            
            // ������ Ȯ��
            const bluffChance = Math.random();
            
            let action;
            
            if (toCall === 0) {
                // üũ ����
                if (handStrength > 0.6 || (handStrength > 0.3 && bluffChance > 0.7)) {
                    // ����
                    const betSize = Math.floor(game.pot * (0.5 + handStrength * 0.5));
                    action = { type: 'raise', amount: Math.min(betSize, game.opponentChips) };
                } else {
                    action = { type: 'check' };
                }
            } else {
                // ���ؾ� ��
                if (handStrength > potOdds + 0.1 || (bluffChance > 0.85 && toCall < game.pot * 0.3)) {
                    // �� �Ǵ� ������
                    if (handStrength > 0.7 && game.opponentChips > toCall * 2) {
                        const raiseAmount = toCall + Math.floor(game.pot * handStrength);
                        action = { type: 'raise', amount: Math.min(raiseAmount, game.opponentChips) };
                    } else {
                        action = { type: 'call' };
                    }
                } else if (handStrength > potOdds - 0.1) {
                    action = { type: 'call' };
                } else {
                    action = { type: 'fold' };
                }
            }
            
            // ����
            executeAiAction(action);
        }

        function evaluatePreflopHand(cards) {
            const r1 = getRankValue(cards[0].rank);
            const r2 = getRankValue(cards[1].rank);
            const suited = cards[0].suit === cards[1].suit;
            const pair = r1 === r2;
            
            let strength = (r1 + r2) / 24; // �⺻ ����
            
            if (pair) strength += 0.3;
            if (suited) strength += 0.1;
            if (Math.abs(r1 - r2) <= 2) strength += 0.05; // Ŀ����
            
            // �����̾� �ڵ�
            if (pair && r1 >= 10) strength = 0.9; // QQ+
            if (r1 === 12 && r2 >= 10) strength = 0.85; // AK, AQ, AJ
            
            return Math.min(strength, 1);
        }

        function animateBet(player) {
            const betEl = document.getElementById(player === 'me' ? 'myBet' : 'opponentBet');
            if (betEl) {
                betEl.classList.add('chip-animate');
                setTimeout(() => betEl.classList.remove('chip-animate'), 300);
            }
        }
        
        function executeAiAction(action) {
            const toCall = game.myBet - game.opponentBet;
            
            switch (action.type) {
                case 'fold':
                    playSound('fold');
                    showMessage('?? ����');
                    setTimeout(() => endHand('me'), 500);
                    return;
                    
                case 'check':
                    playSound('check');
                    showMessage('?? üũ');
                    break;
                    
                case 'call':
                    playSound('chips');
                    placeBet('opponent', toCall);
                    animateBet('opponent');
                    showMessage(`?? �� (${toCall})`);
                    break;
                    
                case 'raise':
                    playSound('chips');
                    placeBet('opponent', action.amount);
                    animateBet('opponent');
                    showMessage(`?? ������ (${action.amount})`);
                    break;
            }
            
            updateDisplay();
            
            if (action.type === 'raise' && game.myChips > 0) {
                game.currentPlayer = 'me';
                setTimeout(showBettingControls, 500);
            } else {
                setTimeout(nextPhase, 500);
            }
        }

        function nextPhase() {
            game.myBet = 0;
            game.opponentBet = 0;
            
            switch (game.phase) {
                case 'preflop':
                    game.phase = 'flop';
                    game.communityCards = drawCards(3);
                    // �ö� ī�� �� ����
                    playSound('flip');
                    setTimeout(() => playSound('flip'), 100);
                    setTimeout(() => playSound('flip'), 200);
                    showMessage('�ö�');
                    break;
                    
                case 'flop':
                    game.phase = 'turn';
                    game.communityCards.push(...drawCards(1));
                    playSound('flip');
                    showMessage('��');
                    break;
                    
                case 'turn':
                    game.phase = 'river';
                    game.communityCards.push(...drawCards(1));
                    playSound('flip');
                    showMessage('����');
                    break;
                    
                case 'river':
                    showdown();
                    return;
            }
            
            updateDisplay();
            
            // ���� ���¸� �ڵ� ����
            if (game.myChips === 0 || game.opponentChips === 0) {
                setTimeout(nextPhase, 1000);
                return;
            }
            
            // ���� �ݴ밡 ����
            game.currentPlayer = game.dealer === 'me' ? 'opponent' : 'me';
            
            if (game.currentPlayer === 'opponent') {
                setTimeout(aiTurn, 800);
            } else {
                playSound('turn');
                showBettingControls();
            }
        }

        function showdown() {
            game.phase = 'showdown';
            
            // ��ٿ� ī�� ���� ����
            playSound('reveal');
            vibrate([30, 20, 30]);
            
            // ��� ī�� ���� �ִϸ��̼�
            const oppCards = document.querySelectorAll('#opponentCards .card');
            oppCards.forEach((card, i) => {
                setTimeout(() => {
                    card.classList.add('revealing');
                }, i * 150);
            });
            
            updateDisplay();
            
            const myHand = evaluateHand([...game.myCards, ...game.communityCards]);
            const oppHand = evaluateHand([...game.opponentCards, ...game.communityCards]);
            
            const comparison = compareHands(myHand, oppHand);
            
            // ��� ǥ�ø� �ణ ����
            setTimeout(() => {
                if (comparison > 0) {
                    endHand('me', HAND_NAMES[myHand.rank]);
                } else if (comparison < 0) {
                    endHand('opponent', HAND_NAMES[oppHand.rank]);
                } else {
                    endHand('tie');
                }
            }, 500);
        }

        function endHand(winner, winningHand = '') {
            game.phase = 'showdown';
            document.getElementById('bettingControls').style.display = 'none';
            
            const overlay = document.getElementById('resultOverlay');
            const title = document.getElementById('resultTitle');
            const detail = document.getElementById('resultDetail');
            
            // Ĩ ���� ��� (��� �����)
            const potWon = game.pot;
            let goldChange = 0;
            
            if (winner === 'me') {
                game.myChips += game.pot;
                goldChange = Math.floor(potWon * CHIP_VALUE);
                title.textContent = '?? �¸�!';
                title.className = 'result-title win';
                detail.innerHTML = winningHand 
                    ? `${winningHand}���� +${game.pot} ȹ�� <span style="color:#4ecca3">+${goldChange}G</span>` 
                    : `+${game.pot} ȹ�� <span style="color:#4ecca3">+${goldChange}G</span>`;
                
                // �¸� ���� & �ִϸ��̼�
                playSound('win');
                vibrate([100, 50, 100]);
                
                // �¸� ����Ʈ
                const potEl = document.getElementById('potAmount');
                if (potEl) potEl.classList.add('pot-animate');
                
                // ����Ƽ ȿ��
                createWinConfetti();
                
            } else if (winner === 'opponent') {
                game.opponentChips += game.pot;
                goldChange = -Math.floor(potWon * CHIP_VALUE);
                title.textContent = '?? �й�';
                title.className = 'result-title lose';
                detail.innerHTML = winningHand 
                    ? `���: ${winningHand} <span style="color:#ef4444">${goldChange}G</span>` 
                    : `<span style="color:#ef4444">${goldChange}G</span>`;
                
                // �й� ����
                playSound('lose');
                vibrate([200, 100, 200]);
                
            } else {
                game.myChips += game.pot / 2;
                game.opponentChips += game.pot / 2;
                title.textContent = '?? ���º�';
                title.className = 'result-title tie';
                detail.textContent = '�� �й�';
                playSound('chips');
            }
            
            // ��� ���� ���� (�̱��÷���)
            if (goldChange !== 0) {
                sharedGold = Math.max(0, sharedGold + goldChange);
                saveSharedGold();
            }
            
            game.pot = 0;
            updateDisplay();
            overlay.classList.add('active');
        }
        
        function createWinConfetti() {
            const colors = ['#ffd700', '#ff6b6b', '#4ecca3', '#667eea', '#f093fb'];
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.style.cssText = `
                        position: fixed;
                        width: 10px;
                        height: 10px;
                        background: ${colors[Math.floor(Math.random() * colors.length)]};
                        left: ${Math.random() * 100}vw;
                        top: -10px;
                        border-radius: ${Math.random() > 0.5 ? '50%' : '0'};
                        pointer-events: none;
                        z-index: 9999;
                        animation: confettiFall ${2 + Math.random() * 2}s linear forwards;
                    `;
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 50);
            }
        }

        function showMessage(text) {
            document.getElementById('gameMessage').textContent = text;
        }

        function showRules() {
            document.getElementById('rulesModal').classList.add('active');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('active');
        }

        // ��� �ܺ� Ŭ���� �ݱ�
        document.getElementById('rulesModal').addEventListener('click', (e) => {
            if (e.target.id === 'rulesModal') closeRules();
        });

        // ===== Multiplayer Mode =====
        let multiplayerClient = null;
        let isMultiplayer = false;
        let isHost = false;
        let myReady = false;

        function startSinglePlayer() {
            isMultiplayer = false;
            document.getElementById('modeSelect').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            updateDisplay();
        }

        function showLobby() {
            document.getElementById('modeSelect').classList.add('hidden');
            document.getElementById('lobby').classList.remove('hidden');
            
            // Clean up any previous multiplayer state
            if (multiplayerClient) {
                multiplayerClient.cleanup();
            }
            
            // Restore nickname if saved
            const savedNickname = localStorage.getItem('poker_nickname');
            if (savedNickname) {
                document.getElementById('nicknameInput').value = savedNickname;
            }
        }

        function backToModeSelect() {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('modeSelect').classList.remove('hidden');
        }

        async function createMultiplayerRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            const nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                alert('�г����� 2�� �̻� �Է��ϼ���');
                return;
            }
            
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                const isPublic = document.getElementById('publicRoomCheck').checked;
                
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                const room = await multiplayerClient.createRoom('poker', { 
                    gameConfig: { startingChips: 1000, bigBlind: 20 },
                    maxPlayers: 2,
                    isPublic 
                });
                isHost = true;
                showWaitingRoom(room.roomId);
            } catch (e) {
                alert('�� ���� ����: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function joinRandomRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            let nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                nickname = 'Player_' + Math.random().toString(36).substr(2, 4);
            }
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                const result = await multiplayerClient.joinRandom('poker');
                isHost = false;
                showWaitingRoom(result.roomId);
                
                if (result.alreadyJoined) {
                    showToast('�̹� ������ ���Դϴ�');
                }
            } catch (e) {
                if (e.message.includes('���� ���� ��')) {
                    alert('���� ���� ������ ���� ���� �����ϴ�.\n�� ���� ��������!');
                } else {
                    alert('���� ��Ī ����: ' + e.message);
                }
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function joinMultiplayerRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode || roomCode.length !== 6) {
                alert('6�ڸ� �� �ڵ带 �Է��ϼ���');
                return;
            }
            
            let nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                nickname = 'Player_' + Math.random().toString(36).substr(2, 4);
            }
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                await multiplayerClient.joinRoom(roomCode);
                isHost = false;
                showWaitingRoom(roomCode);
            } catch (e) {
                alert('���� ����: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        function showWaitingRoom(roomCode) {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('waitingRoom').classList.remove('hidden');
            document.getElementById('displayRoomCode').textContent = roomCode;
            
            // Reset button states
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');
            startBtn.classList.remove('loading');
            readyBtn.classList.remove('loading');
            
            // Host: show start button & destroy button, hide ready button
            // Non-host: show ready button, hide start & destroy buttons
            startBtn.style.display = isHost ? 'inline-block' : 'none';
            readyBtn.style.display = isHost ? 'none' : 'inline-block';
            document.getElementById('destroyBtn').style.display = isHost ? 'inline-block' : 'none';
            
            // Generate QR code with room code
            const baseUrl = window.location.origin + window.location.pathname.replace(/\/$/, '');
            const joinUrl = `${baseUrl}/?room=${roomCode}`;
            console.log('QR URL:', joinUrl); // debug
            const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(joinUrl)}`;
            document.getElementById('qrCode').innerHTML = `
                <img src="${qrUrl}" alt="QR Code" style="border-radius:8px;background:#fff;padding:8px;">
                <div style="font-size:0.7rem;color:#666;margin-top:4px;">${joinUrl}</div>
            `;
            
            // Start listening for updates
            multiplayerClient.onStateChange = updateWaitingRoom;
            multiplayerClient.onEvent = handleMultiplayerEvent;
            multiplayerClient.startListening();
            
            // Initial state load
            refreshWaitingRoom();
        }

        async function refreshWaitingRoom() {
            try {
                const state = await multiplayerClient.getRoomState();
                updateWaitingRoom(state);
            } catch (e) {
                console.error('Failed to refresh:', e);
            }
        }

        function updateWaitingRoom(state) {
            if (!state || !state.players) return;
            
            const playerList = document.getElementById('playerList');
            const myId = multiplayerClient.getMyUserId();
            
            // Update isHost and myReady based on server state
            const me = state.players.find(p => p.id === myId);
            if (me) {
                isHost = me.isHost;
                myReady = me.isReady;
            }
            
            // Update button visibility based on host status
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');
            const destroyBtn = document.getElementById('destroyBtn');
            startBtn.style.display = isHost ? 'inline-block' : 'none';
            readyBtn.style.display = isHost ? 'none' : 'inline-block';
            destroyBtn.style.display = isHost ? 'inline-block' : 'none';
            
            // Sync ready button text with server state
            readyBtn.textContent = myReady ? '�غ����' : '�غ�';
            readyBtn.classList.toggle('primary', myReady);
            
            playerList.innerHTML = state.players.map(p => `
                <div class="player-item">
                    <span class="name">${p.isHost ? '?? ' : ''}${p.nickname || 'Player'} ${p.id === myId ? '(��)' : ''}</span>
                    <span class="status ${p.isReady ? 'ready' : ''} ${p.isHost ? 'host' : ''}">${p.isHost ? '����' : (p.isReady ? '�غ�Ϸ�' : '�����')}</span>
                </div>
            `).join('');
            
            // Update start button for host
            if (isHost) {
                const others = state.players.filter(p => !p.isHost);
                const allReady = others.length > 0 && others.every(p => p.isReady);
                const canStart = state.players.length >= 2 && allReady;
                startBtn.disabled = !canStart;
                startBtn.classList.remove('loading'); // Clear loading state
                document.getElementById('waitingMessage').textContent = canStart ? '������ ������ �� �ֽ��ϴ�!' : '�ٸ� �÷��̾ ��ٸ��� ��...';
            } else {
                document.getElementById('waitingMessage').textContent = myReady ? '������ �����ϱ⸦ ��ٸ��� ��...' : '�غ� ��ư�� �����ּ���';
            }
            
            // Check if game started
            if (state.status === 'playing') {
                startMultiplayerGameFromState(state);
            }
        }

        function handleMultiplayerEvent(type, data) {
            console.log('MP Event:', type, data);
            
            if (type === 'game_started') {
                refreshWaitingRoom();
            } else if (type === 'room_destroyed') {
                // Room was destroyed by host
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                alert('���� ���ĵǾ����ϴ�.');
            }
        }

        async function toggleReady() {
            const btn = document.getElementById('readyBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                const newReady = !myReady;
                await multiplayerClient.setReady(newReady);
                // Server confirmed, now update local state
                myReady = newReady;
                btn.textContent = myReady ? '�غ����' : '�غ�';
                btn.classList.toggle('primary', myReady);
            } catch (e) {
                alert('�غ� ���� ���� ����: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function leaveWaitingRoom() {
            const btn = document.getElementById('leaveBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.leaveRoom();
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
            } catch (e) {
                console.error('Leave error:', e);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function destroyRoom() {
            if (!confirm('���� ���� �����Ͻðڽ��ϱ�?\n��� �÷��̾ ����˴ϴ�.')) return;
            
            const btn = document.getElementById('destroyBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.destroyRoom();
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                showToast('���� ���ĵǾ����ϴ�');
            } catch (e) {
                alert('�� ���� ����: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function startMultiplayerGame() {
            const btn = document.getElementById('startBtn');
            if (btn.classList.contains('loading') || btn.disabled) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.startGame();
                // Game will start via event
            } catch (e) {
                alert('���� ���� ����: ' + e.message);
                btn.classList.remove('loading');
            }
        }

        let mpState = null; // Multiplayer game state

        function startMultiplayerGameFromState(state) {
            isMultiplayer = true;
            mpState = state;
            
            document.getElementById('waitingRoom').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            
            // Update header for multiplayer
            const header = document.querySelector('.header-buttons');
            header.innerHTML = '<button class="btn" onclick="showRules()">?? ��</button><button class="btn" onclick="leaveMultiplayerGame()">������</button>';
            
            // Change opponent name
            const myId = multiplayerClient.getMyUserId();
            const opponent = state.players.find(p => p.id !== myId);
            if (opponent) {
                document.querySelector('.opponent-area .player-name').textContent = '?? ' + (opponent.nickname || 'Player');
            }
            document.querySelector('.my-area .player-name').textContent = '?? ��';
            
            // Setup event handlers
            multiplayerClient.onStateChange = updateMultiplayerDisplay;
            multiplayerClient.onEvent = handleGameEvent;
            
            updateMultiplayerDisplay(state);
            showMessage('���� ����!');
        }

        function updateMultiplayerDisplay(state) {
            if (!state || !state.gameState) return;
            mpState = state;
            
            const gs = state.gameState;
            const myView = state.myView || gs;
            const myId = multiplayerClient.getMyUserId();
            
            // Find me and opponent
            const me = gs.players.find(p => p.id === myId);
            const opponent = gs.players.find(p => p.id !== myId);
            
            if (!me || !opponent) return;
            
            // Update chips
            document.getElementById('myChips').textContent = me.chips;
            document.getElementById('opponentChips').textContent = opponent.chips;
            document.getElementById('potAmount').textContent = gs.pot;
            
            // Update bets
            document.getElementById('myBet').textContent = me.bet > 0 ? `����: ${me.bet}` : '';
            document.getElementById('opponentBet').textContent = opponent.bet > 0 ? `����: ${opponent.bet}` : '';
            
            // My cards
            const myHand = myView.myHand || [];
            document.getElementById('myCards').innerHTML = myHand.map(c => renderCard(c)).join('');
            
            // Opponent cards (hidden unless showdown)
            const showOpponent = gs.phase === 'showdown' || gs.phase === 'finished';
            const oppHand = myView.showdownHands?.[opponent.id] || [];
            if (showOpponent && oppHand.length > 0) {
                document.getElementById('opponentCards').innerHTML = oppHand.map(c => renderCard(c)).join('');
            } else {
                document.getElementById('opponentCards').innerHTML = opponent.folded ? '' : 
                    '<div class="card back"></div><div class="card back"></div>';
            }
            
            // Community cards
            document.getElementById('communityCards').innerHTML = gs.communityCards.map(c => renderCard(c)).join('');
            
            // Dealer button
            const imDealer = gs.dealerSeat === me.seat;
            document.getElementById('myDealer').style.display = imDealer ? 'inline' : 'none';
            document.getElementById('opponentDealer').style.display = !imDealer ? 'inline' : 'none';
            
            // Hand evaluation display
            if (myHand.length > 0 && gs.communityCards.length >= 3) {
                const hand = evaluateHand([...myHand, ...gs.communityCards]);
                document.getElementById('myHand').textContent = HAND_NAMES[hand.rank];
                document.getElementById('myHand').style.display = 'block';
            } else {
                document.getElementById('myHand').style.display = 'none';
            }
            
            if (showOpponent && oppHand.length > 0 && gs.communityCards.length >= 3) {
                const hand = evaluateHand([...oppHand, ...gs.communityCards]);
                document.getElementById('opponentHand').textContent = HAND_NAMES[hand.rank];
                document.getElementById('opponentHand').style.display = 'block';
            } else {
                document.getElementById('opponentHand').style.display = 'none';
            }
            
            // Show phase
            const phaseNames = { preflop: '�����ö�', flop: '�ö�', turn: '��', river: '����', showdown: '��ٿ�', finished: '����' };
            if (gs.phase !== 'finished') {
                showMessage(phaseNames[gs.phase] || gs.phase);
            }
            
            // Betting controls - only if it's my turn and game is active
            const isMyTurn = myView.isMyTurn && !me.folded && !me.isAllIn && gs.phase !== 'showdown' && gs.phase !== 'finished';
            if (isMyTurn) {
                showMultiplayerBettingControls(me, gs.currentBet, gs.bigBlind);
            } else {
                document.getElementById('bettingControls').style.display = 'none';
            }
            
            // Game over
            if (gs.phase === 'finished') {
                handleMultiplayerGameEnd(state);
            }
        }

        function showMultiplayerBettingControls(me, currentBet, minRaise) {
            const controls = document.getElementById('bettingControls');
            const buttons = document.getElementById('betButtons');
            const raiseContainer = document.getElementById('raiseContainer');
            
            controls.style.display = 'block';
            
            const toCall = currentBet - me.bet;
            const canRaise = me.chips > toCall;
            
            let html = '<button class="bet-btn fold" onclick="mpAction(\'fold\')">����</button>';
            
            if (toCall === 0) {
                html += '<button class="bet-btn check" onclick="mpAction(\'check\')">üũ</button>';
            } else if (toCall > 0 && me.chips >= toCall) {
                html += `<button class="bet-btn call" onclick="mpAction('call')">�� (${Math.min(toCall, me.chips)})</button>`;
            }
            
            if (canRaise && me.chips > toCall) {
                html += '<button class="bet-btn raise" onclick="mpAction(\'raise\')">������</button>';
                raiseContainer.style.display = 'flex';
                
                const slider = document.getElementById('betSlider');
                const minTotal = currentBet + minRaise;
                slider.min = minTotal;
                slider.max = me.chips + me.bet;
                slider.value = Math.min(minTotal * 2, me.chips + me.bet);
                updateBetDisplay();
            } else {
                raiseContainer.style.display = 'none';
            }
            
            if (me.chips > 0) {
                html += `<button class="bet-btn allin" onclick="mpAction('allin')">���� (${me.chips})</button>`;
            }
            
            buttons.innerHTML = html;
        }

        async function mpAction(action) {
            // Disable controls while sending
            document.getElementById('bettingControls').style.display = 'none';
            
            try {
                let actionData = { type: action };
                
                if (action === 'raise') {
                    const amount = parseInt(document.getElementById('betSlider').value);
                    actionData.payload = { amount };
                }
                
                const result = await multiplayerClient.sendAction(actionData);
                
                // State will update via onStateChange
                if (result && result.gameState) {
                    updateMultiplayerDisplay({ ...mpState, gameState: result.gameState, myView: result.myView });
                }
            } catch (e) {
                alert('�׼� ����: ' + e.message);
                // Re-fetch state to show controls if still my turn
                const state = await multiplayerClient.getRoomState();
                updateMultiplayerDisplay(state);
            }
        }

        function handleGameEvent(type, data) {
            console.log('Game Event:', type, data);
            
            // Show action messages
            const actionMsgs = {
                fold: '����',
                check: 'üũ',
                call: '��',
                raise: '������',
                allin: '����',
                flop: '�ö�',
                turn: '��',
                river: '����'
            };
            
            if (actionMsgs[type]) {
                const myId = multiplayerClient.getMyUserId();
                const isMe = data.userId === myId;
                if (!isMe && ['fold', 'check', 'call', 'raise', 'allin'].includes(type)) {
                    const amount = data.payload?.amount ? ` (${data.payload.amount})` : '';
                    showToast(`���: ${actionMsgs[type]}${amount}`);
                }
            }
            
            if (type === 'win') {
                const myId = multiplayerClient.getMyUserId();
                const isMe = data.playerId === myId;
                setTimeout(() => {
                    const hand = data.payload?.hand || '';
                    if (isMe) {
                        showToast(`?? �¸�! ${hand ? hand + '���� ' : ''}+${data.payload?.amount}`);
                    } else {
                        showToast(`?? �й� ${hand ? '(���: ' + hand + ')' : ''}`);
                    }
                }, 500);
            }
            
            // Handle rematch - other player requested rematch, go to waiting room
            if (type === 'rematch_ready') {
                const myId = multiplayerClient.getMyUserId();
                if (data.userId !== myId) {
                    showToast('��밡 ����ġ�� ��û�߽��ϴ�!');
                    setTimeout(() => goToWaitingRoom(), 1000);
                }
            }
        }

        let gameEndHandled = false;

        function handleMultiplayerGameEnd(state) {
            if (gameEndHandled) return;
            gameEndHandled = true;
            
            const overlay = document.getElementById('resultOverlay');
            const title = document.getElementById('resultTitle');
            const detail = document.getElementById('resultDetail');
            
            const gs = state.gameState;
            const myId = multiplayerClient.getMyUserId();
            const me = gs.players.find(p => p.id === myId);
            const opponent = gs.players.find(p => p.id !== myId);
            
            // Determine winner by chip count change
            // Ĩ ���̸� ���� ��ȯ (1Ĩ = 0.5���)
            const chipDiff = me.chips - opponent.chips;
            const goldChange = Math.floor(chipDiff * CHIP_VALUE);
            
            if (me.chips > opponent.chips) {
                title.textContent = '?? �̹� �ڵ� �¸�!';
                title.className = 'result-title win';
                // �¸� �� ��� ȹ��
                sharedGold += goldChange;
                saveSharedGold();
            } else if (me.chips < opponent.chips) {
                title.textContent = '?? �̹� �ڵ� �й�';
                title.className = 'result-title lose';
                // �й� �� ��� �ս� (�ּ� 0)
                sharedGold = Math.max(0, sharedGold + goldChange);
                saveSharedGold();
            } else {
                title.textContent = '?? ���º�';
                title.className = 'result-title tie';
            }
            
            const goldText = goldChange > 0 ? `<span style="color:#4ecca3">+${goldChange}G</span>` : 
                            goldChange < 0 ? `<span style="color:#ef4444">${goldChange}G</span>` : '';
            detail.innerHTML = `�� Ĩ: ${me.chips} | ��� Ĩ: ${opponent.chips}${goldText ? ` | ${goldText}` : ''}`;
            
            // Clear old buttons
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = 'none';
            
            // Add rematch buttons
            const btnContainer = document.createElement('div');
            btnContainer.className = 'mp-buttons';
            btnContainer.style.cssText = 'display:flex;gap:10px;justify-content:center;margin-top:20px;';
            btnContainer.innerHTML = `
                <button class="btn primary" id="rematchBtn">?? ����ġ</button>
                <button class="btn" id="exitBtn">������</button>
            `;
            overlay.appendChild(btnContainer);
            
            document.getElementById('rematchBtn').onclick = requestRematch;
            document.getElementById('exitBtn').onclick = exitToLobby;
            
            overlay.classList.add('active');
        }

        async function requestRematch() {
            const btn = document.getElementById('rematchBtn');
            if (!btn || btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            btn.textContent = '��û ��...';
            
            try {
                await multiplayerClient.rematch();
                goToWaitingRoom();
            } catch (e) {
                alert('����ġ ��û ����: ' + e.message);
                btn.classList.remove('loading');
                btn.textContent = '?? ����ġ';
            }
        }

        function goToWaitingRoom() {
            gameEndHandled = false;
            
            // Hide overlay and clean up
            const overlay = document.getElementById('resultOverlay');
            overlay.classList.remove('active');
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = '';
            
            // Switch screens
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('waitingRoom').classList.remove('hidden');
            
            // Reset button loading states
            const readyBtn = document.getElementById('readyBtn');
            const startBtn = document.getElementById('startBtn');
            readyBtn.classList.remove('loading');
            startBtn.classList.remove('loading');
            startBtn.disabled = true;
            
            // Reconnect event listeners for waiting room
            multiplayerClient.onStateChange = updateWaitingRoom;
            multiplayerClient.onEvent = handleMultiplayerEvent;
            
            // Fetch latest state (this will sync myReady and isHost)
            refreshWaitingRoom();
        }

        function exitToLobby() {
            gameEndHandled = false;
            
            // Hide overlay and clean up
            const overlay = document.getElementById('resultOverlay');
            overlay.classList.remove('active');
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = '';
            
            leaveMultiplayerGame(true); // skip confirm
        }

        async function leaveMultiplayerGame(skipConfirm = false) {
            if (skipConfirm || confirm('������ �����ðڽ��ϱ�?')) {
                if (multiplayerClient) {
                    try {
                        await multiplayerClient.leaveRoom();
                    } catch (e) {
                        console.error('Leave error:', e);
                    }
                    MultiplayerClient.resetInstance();
                    multiplayerClient = null;
                }
                
                isHost = false;
                myReady = false;
                isMultiplayer = false;
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                
                // Reset header
                const header = document.querySelector('.header-buttons');
                header.innerHTML = '<button class="btn" onclick="showRules()">?? ��</button><button class="btn primary" onclick="newGame()">�� ����</button>';
            }
        }

        function copyRoomCode() {
            const code = document.getElementById('displayRoomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('�ڵ� �����!');
            }).catch(() => {
                prompt('�ڵ带 �����ϼ���:', code);
            });
        }

        function shareRoomLink() {
            const code = document.getElementById('displayRoomCode').textContent;
            const url = `${window.location.origin}${window.location.pathname}?room=${code}`;
            
            if (navigator.share) {
                navigator.share({
                    title: '��Ŀ ���� �ʴ�',
                    text: `��Ŀ ���ӿ� �����ϼ���! �� �ڵ�: ${code}`,
                    url: url
                }).catch(() => {});
            } else {
                navigator.clipboard.writeText(url).then(() => {
                    showToast('��ũ �����!');
                }).catch(() => {
                    prompt('��ũ�� �����ϼ���:', url);
                });
            }
        }

        function showToast(msg) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = msg;
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:#fff;padding:12px 24px;border-radius:8px;z-index:999;animation:fadeIn 0.3s;';
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // URL �Ķ���ͷ� �� �ڵ尡 ������ �ڵ� ����
        function checkUrlRoom() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                // Clear URL params
                window.history.replaceState({}, '', window.location.pathname);
                // Show lobby with room code filled
                showLobby();
                document.getElementById('roomCodeInput').value = roomCode;
            }
        }

        // Override newGame for single player
        const originalNewGame = newGame;
        newGame = function() {
            if (isMultiplayer) {
                // TODO: Handle multiplayer new game
                return;
            }
            originalNewGame();
        };

        // �ʱ�ȭ - ��� ���� ȭ�� ǥ��
        // updateDisplay(); // Skip - game container is hidden
        
        // ���� ��ȭ �ε�
        loadSharedGold();
        
        // Check for room code in URL
        checkUrlRoom();
    </script>
    <script src="/lib/multiplayer.js?v=20260210v2"></script>
    <script src="/lib/shared-wallet.js?v=20260211"></script>
    <script>
        // SharedWallet�� ����ȭ
        SharedWallet.init().then(() => {
            sharedGold = SharedWallet.gold;
            cloudSyncEnabled = SharedWallet.cloudSyncEnabled;
            updateGoldDisplay();
        });
    </script>
</body>
</html>
