<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>?¨Ïª§ - ?çÏÇ¨???Ä??/title>
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <style>
        :root {
            --bg: #0d1117;
            --table: #1a472a;
            --table-border: #2d5a3d;
            --card-bg: #fff;
            --card-back: #1e3a5f;
            --text: #e6edf3;
            --gold: #ffd700;
            --red: #ef4444;
            --chip: #22c55e;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }

        h1 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn.primary {
            background: var(--chip);
            border-color: var(--chip);
            color: #000;
        }

        /* ?åÏù¥Î∏??ÅÏó≠ */
        .poker-table {
            background: linear-gradient(145deg, var(--table), #0f2d1a);
            border: 8px solid var(--table-border);
            border-radius: 120px;
            padding: 20px;
            margin: 10px 0;
            min-height: 400px;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 0 60px rgba(0,0,0,0.3);
        }

        /* ?åÎ†à?¥Ïñ¥ ?ÅÏó≠ */
        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .opponent-area {
            margin-bottom: 20px;
        }

        .my-area {
            margin-top: 20px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 20px;
        }

        .player-name {
            font-weight: 600;
        }

        .chip-count {
            color: var(--gold);
            font-weight: 700;
        }

        .dealer-btn {
            background: var(--gold);
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
        }

        /* Ïπ¥Îìú */
        .cards {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .card {
            width: 60px;
            height: 84px;
            background: var(--card-bg);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 700;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.3s;
        }

        .card.back {
            background: linear-gradient(135deg, var(--card-back), #0f2840);
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255,255,255,0.03) 10px,
                rgba(255,255,255,0.03) 20px
            );
        }

        .card.red { color: var(--red); }
        .card.black { color: #1a1a1a; }

        .card .rank {
            font-size: 1.4rem;
            line-height: 1;
        }

        .card .suit {
            font-size: 1.6rem;
            line-height: 1;
        }

        /* Ïª§Î??àÌã∞ Ïπ¥Îìú */
        .community-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .community-cards {
            display: flex;
            gap: 8px;
        }

        .community-cards .card {
            width: 55px;
            height: 77px;
        }

        .pot-display {
            background: rgba(0,0,0,0.5);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 1.1rem;
        }

        .pot-amount {
            color: var(--gold);
            font-weight: 700;
        }

        /* Î≤†ÌåÖ Ïª®Ìä∏Î°?*/
        .betting-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin-top: 10px;
        }

        .bet-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .bet-btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bet-btn.fold {
            background: #6b7280;
            color: white;
        }

        .bet-btn.check, .bet-btn.call {
            background: #3b82f6;
            color: white;
        }

        .bet-btn.raise, .bet-btn.bet {
            background: var(--chip);
            color: #000;
        }

        .bet-btn.allin {
            background: var(--red);
            color: white;
        }

        .bet-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bet-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bet-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--gold);
            border-radius: 50%;
            cursor: pointer;
        }

        .bet-amount-display {
            min-width: 80px;
            text-align: center;
            font-weight: 700;
            color: var(--gold);
        }

        /* Î©îÏãúÏßÄ */
        .game-message {
            text-align: center;
            padding: 10px;
            font-size: 1.1rem;
            min-height: 40px;
        }

        .hand-result {
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* Î™®Îã¨ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1c2128;
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            width: 100%;
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .hand-rank {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .hand-rank-num {
            width: 30px;
            height: 30px;
            background: var(--gold);
            color: #000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .hand-rank-name {
            font-weight: 600;
            flex: 1;
        }

        .hand-rank-desc {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        /* Í≤∞Í≥º ?îÎ©¥ */
        .result-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px 50px;
            border-radius: 16px;
            text-align: center;
            z-index: 100;
        }

        .result-overlay.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .result-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .result-title.win { color: var(--gold); }
        .result-title.lose { color: var(--red); }
        .result-title.tie { color: #9ca3af; }

        .result-detail {
            font-size: 1rem;
            margin-bottom: 20px;
        }

        /* Î∞òÏùë??*/
        @media (max-width: 480px) {
            .card {
                width: 50px;
                height: 70px;
                font-size: 1rem;
            }

            .card .rank { font-size: 1.2rem; }
            .card .suit { font-size: 1.3rem; }

            .community-cards .card {
                width: 45px;
                height: 63px;
            }

            .poker-table {
                border-radius: 60px;
                padding: 15px;
            }

            .bet-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        .action-indicator {
            position: absolute;
            background: var(--gold);
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .current-bet {
            font-size: 0.9rem;
            color: var(--gold);
        }

        /* ===== Multiplayer UI ===== */
        .mode-select {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            gap: 20px;
        }

        .mode-select.hidden { display: none; }

        .mode-select h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .mode-select p {
            color: #9ca3af;
            margin-bottom: 30px;
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mode-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 30px 40px;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 200px;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: var(--gold);
            transform: translateY(-4px);
        }

        .mode-btn .icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 10px;
        }

        .mode-btn .label {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .mode-btn .desc {
            font-size: 0.85rem;
            color: #9ca3af;
            margin-top: 5px;
        }

        /* Lobby */
        .lobby {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            z-index: 200;
            overflow-y: auto;
        }

        .lobby.hidden { display: none; }

        .lobby-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
        }

        .lobby-header h2 {
            flex: 1;
            font-size: 1.5rem;
        }

        .lobby-content {
            width: 100%;
            max-width: 500px;
        }

        .lobby-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .lobby-section h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-group input {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text);
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: #666;
        }

        /* Waiting Room */
        .waiting-room {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 200;
        }

        .waiting-room.hidden { display: none; }

        .room-code {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--gold);
            margin: 20px 0;
        }

        .room-code-label {
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .player-list {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            margin: 20px 0;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .player-item:last-child { border-bottom: none; }

        .player-item .name { flex: 1; }

        .player-item .status {
            font-size: 0.85rem;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
        }

        .player-item .status.ready {
            background: var(--chip);
            color: #000;
        }

        .player-item .status.host {
            background: var(--gold);
            color: #000;
        }

        .waiting-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .copy-btn {
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .copy-btn:hover { background: rgba(255,255,255,0.1); }

        /* Loading States */
        .btn.loading, .mode-btn.loading {
            pointer-events: none;
            opacity: 0.7;
            position: relative;
        }

        .btn.loading::after, .mode-btn.loading::after {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .share-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .share-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text);
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .share-btn:hover { background: rgba(255,255,255,0.2); }
        .share-btn.primary { background: var(--chip); color: #000; border-color: var(--chip); }
    </style>
</head>
<body>
    <!-- Mode Selection -->
    <div class="mode-select" id="modeSelect">
        <h1>?Éè ?çÏÇ¨???Ä??/h1>
        <p>Í≤åÏûÑ Î™®ÎìúÎ•??†ÌÉù?òÏÑ∏??/p>
        <div class="mode-buttons">
            <button class="mode-btn" onclick="startSinglePlayer()">
                <span class="icon">?§ñ</span>
                <span class="label">?±Í??åÎ†à??/span>
                <span class="desc">AI?Ä 1:1 ?Ä??/span>
            </button>
            <button class="mode-btn" onclick="showLobby()">
                <span class="icon">?ë•</span>
                <span class="label">Î©Ä?∞Ìîå?àÏù¥</span>
                <span class="desc">ÏπúÍµ¨?Ä ?Ä??/span>
            </button>
        </div>
    </div>

    <!-- Multiplayer Lobby -->
    <div class="lobby hidden" id="lobby">
        <div class="lobby-header">
            <button class="btn" onclick="backToModeSelect()">???§Î°ú</button>
            <h2>?ë• Î©Ä?∞Ìîå?àÏù¥</h2>
        </div>
        <div class="lobby-content">
            <div class="lobby-section">
                <h3>?éÆ ??Í≤åÏûÑ ÎßåÎì§Í∏?/h3>
                <div class="input-group" style="margin-bottom:10px;">
                    <input type="text" id="nicknameInput" placeholder="?âÎÑ§???ÖÎ†•" maxlength="20">
                </div>
                <label style="display:flex;align-items:center;gap:8px;margin-bottom:12px;cursor:pointer;">
                    <input type="checkbox" id="publicRoomCheck" checked style="width:18px;height:18px;">
                    <span>?åê ?úÎç§ Ï∞∏Í? ?àÏö© (Í≥µÍ∞ú Î∞?</span>
                </label>
                <button class="btn primary" onclick="createMultiplayerRoom()" style="width:100%;">Î∞?ÎßåÎì§Í∏?/button>
            </div>
            <div class="lobby-section">
                <h3>?é≤ Îπ†Î•∏ Ï∞∏Í?</h3>
                <button class="btn primary" onclick="joinRandomRoom()" style="width:100%;margin-bottom:12px;">?é≤ ?úÎç§ Îß§Ïπ≠</button>
                <div style="text-align:center;color:#666;margin:8px 0;">?êÎäî</div>
                <div class="input-group">
                    <input type="text" id="roomCodeInput" placeholder="Î∞?ÏΩîÎìú (6?êÎ¶¨)" maxlength="6" style="text-transform: uppercase;">
                    <button class="btn" onclick="joinMultiplayerRoom()">Ï∞∏Í?</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Waiting Room -->
    <div class="waiting-room hidden" id="waitingRoom">
        <button class="btn" onclick="leaveWaitingRoom()" style="position:absolute;top:20px;left:20px;">???òÍ?Í∏?/button>
        <h2>?ÄÍ∏∞Ïã§</h2>
        <div class="room-code-label">Î∞?ÏΩîÎìú</div>
        <div class="room-code" id="displayRoomCode">------</div>
        <div id="qrCode" style="margin:15px 0;"></div>
        <div class="share-buttons">
            <button class="share-btn" onclick="copyRoomCode()">?ìã ÏΩîÎìú Î≥µÏÇ¨</button>
            <button class="share-btn primary" onclick="shareRoomLink()">?îó ÎßÅÌÅ¨ Í≥µÏú†</button>
        </div>
        
        <div class="player-list" id="playerList">
            <!-- Players will be listed here -->
        </div>
        
        <div class="waiting-actions" id="waitingActions">
            <button class="btn" id="readyBtn" onclick="toggleReady()">Ï§ÄÎπ?/button>
            <button class="btn primary" id="startBtn" onclick="startMultiplayerGame()">Í≤åÏûÑ ?úÏûë</button>
            <button class="btn" id="leaveBtn" onclick="leaveWaitingRoom()">?òÍ?Í∏?/button>
            <button class="btn" id="destroyBtn" onclick="destroyRoom()" style="background:#ef4444;border-color:#ef4444;display:none;">?óëÔ∏?Î∞???åå</button>
        </div>
        <p id="waitingMessage" style="color:#9ca3af;margin-top:15px;">?§Î•∏ ?åÎ†à?¥Ïñ¥Î•?Í∏∞Îã§Î¶¨Îäî Ï§?..</p>
    </div>

    <div class="game-container" id="gameContainer" style="display:none;">
        <header>
            <h1>?Éè ?¨Ïª§</h1>
            <div class="header-buttons">
                <button class="btn" onclick="showRules()">?ìñ Î£?/button>
                <button class="btn primary" onclick="newGame()">??Í≤åÏûÑ</button>
            </div>
        </header>

        <div class="poker-table">
            <!-- ?ÅÎ? ?ÅÏó≠ -->
            <div class="player-area opponent-area">
                <div class="player-info">
                    <span class="player-name">?§ñ Ïª¥Ìì®??/span>
                    <span class="chip-count" id="opponentChips">1000</span>
                    <span class="dealer-btn" id="opponentDealer" style="display:none">D</span>
                </div>
                <div class="cards" id="opponentCards"></div>
                <div class="hand-result" id="opponentHand" style="display:none"></div>
                <div class="current-bet" id="opponentBet"></div>
            </div>

            <!-- Ïª§Î??àÌã∞ Ïπ¥Îìú -->
            <div class="community-area">
                <div class="community-cards" id="communityCards"></div>
                <div class="pot-display">
                    ?? <span class="pot-amount" id="potAmount">0</span>
                </div>
            </div>

            <!-- Í≤∞Í≥º ?§Î≤Ñ?àÏù¥ -->
            <div class="result-overlay" id="resultOverlay">
                <div class="result-title" id="resultTitle">?πÎ¶¨!</div>
                <div class="result-detail" id="resultDetail"></div>
                <button class="btn primary" onclick="nextHand()">?§Ïùå ?∏Îìú</button>
            </div>

            <!-- ???ÅÏó≠ -->
            <div class="player-area my-area">
                <div class="current-bet" id="myBet"></div>
                <div class="cards" id="myCards"></div>
                <div class="hand-result" id="myHand"></div>
                <div class="player-info">
                    <span class="player-name">?ë§ ??/span>
                    <span class="chip-count" id="myChips">1000</span>
                    <span class="dealer-btn" id="myDealer" style="display:none">D</span>
                </div>
            </div>
        </div>

        <div class="game-message" id="gameMessage">??Í≤åÏûÑ???úÏûë?òÏÑ∏??</div>

        <div class="betting-controls" id="bettingControls" style="display:none">
            <div class="bet-slider-container" id="raiseContainer" style="display:none">
                <input type="range" class="bet-slider" id="betSlider" min="0" max="1000" value="20">
                <div class="bet-amount-display" id="betAmountDisplay">20</div>
            </div>
            <div class="bet-buttons" id="betButtons"></div>
        </div>
    </div>

    <!-- Î£?Î™®Îã¨ -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <h2>
                ?ìñ ?çÏÇ¨???Ä??Î£?                <button class="close-btn" onclick="closeRules()">√ó</button>
            </h2>

            <h3 style="margin: 16px 0 8px">?éÆ Í≤åÏûÑ ÏßÑÌñâ</h3>
            <p style="line-height: 1.6; color: #9ca3af; margin-bottom: 16px">
                1. Í∞??åÎ†à?¥Ïñ¥?êÍ≤å 2?•Ïùò Ïπ¥Îìú(?ÄÏπ¥Îìú)Í∞Ä Î∞∞Î∂Ñ?©Îãà??<br>
                2. 5?•Ïùò Ïª§Î??àÌã∞ Ïπ¥ÎìúÍ∞Ä ?úÏ∞®?ÅÏúºÎ°?Í≥µÍ∞ú?©Îãà??<br>
                3. ?ÄÏπ¥Îìú 2??+ Ïª§Î??àÌã∞ 5??Ï§?5?•ÏúºÎ°?ÏµúÍ≥† Ï°∞Ìï©??ÎßåÎì≠?àÎã§.<br>
                4. Î≤†ÌåÖ ?ºÏö¥?? ?ÑÎ¶¨?åÎûç ???åÎûç ??????Î¶¨Î≤Ñ
            </p>

            <h3 style="margin: 16px 0 8px">?í∞ Î≤†ÌåÖ ?°ÏÖò</h3>
            <p style="line-height: 1.6; color: #9ca3af; margin-bottom: 16px">
                <b>?¥Îìú</b>: ?¨Í∏∞?òÍ≥† ?üÏùÑ ?ÅÎ??êÍ≤å ?ëÎ≥¥<br>
                <b>Ï≤¥ÌÅ¨</b>: Î≤†ÌåÖ ?ÜÏù¥ Ï∞®Î? ?òÍ∏∞Í∏?(?ÅÎ?Í∞Ä Î≤†ÌåÖ ?àÌñà????<br>
                <b>ÏΩ?/b>: ?ÅÎ? Î≤†ÌåÖÍ≥?Í∞ôÏ? Í∏àÏï° Î≤†ÌåÖ<br>
                <b>?àÏù¥Ï¶?/b>: ?ÅÎ? Î≤†ÌåÖÎ≥¥Îã§ ??ÎßéÏù¥ Î≤†ÌåÖ<br>
                <b>?¨Ïù∏</b>: Î™®Îì† Ïπ©ÏùÑ Î≤†ÌåÖ
            </p>

            <h3 style="margin: 16px 0 8px">?èÜ ?∏Îìú ?úÏúÑ (?íÏ? ??</h3>
            
            <div class="hand-rank">
                <div class="hand-rank-num">1</div>
                <div>
                    <div class="hand-rank-name">Î°úÏñÑ ?åÎü¨??/div>
                    <div class="hand-rank-desc">A K Q J 10 Í∞ôÏ? Î¨¥Îä¨</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">2</div>
                <div>
                    <div class="hand-rank-name">?§Ìä∏?àÏù¥???åÎü¨??/div>
                    <div class="hand-rank-desc">?∞ÏÜç 5??Í∞ôÏ? Î¨¥Îä¨</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">3</div>
                <div>
                    <div class="hand-rank-name">?¨Ïπ¥??/div>
                    <div class="hand-rank-desc">Í∞ôÏ? ?´Ïûê 4??/div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">4</div>
                <div>
                    <div class="hand-rank-name">?Ä?òÏö∞??/div>
                    <div class="hand-rank-desc">?∏Î¶¨??+ ?òÏñ¥</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">5</div>
                <div>
                    <div class="hand-rank-name">?åÎü¨??/div>
                    <div class="hand-rank-desc">Í∞ôÏ? Î¨¥Îä¨ 5??/div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">6</div>
                <div>
                    <div class="hand-rank-name">?§Ìä∏?àÏù¥??/div>
                    <div class="hand-rank-desc">?∞ÏÜç ?´Ïûê 5??/div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">7</div>
                <div>
                    <div class="hand-rank-name">?∏Î¶¨??/div>
                    <div class="hand-rank-desc">Í∞ôÏ? ?´Ïûê 3??/div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">8</div>
                <div>
                    <div class="hand-rank-name">?¨Ìéò??/div>
                    <div class="hand-rank-desc">?òÏñ¥ 2Í∞?/div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">9</div>
                <div>
                    <div class="hand-rank-name">?êÌéò??/div>
                    <div class="hand-rank-desc">Í∞ôÏ? ?´Ïûê 2??/div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">10</div>
                <div>
                    <div class="hand-rank-name">?òÏù¥Ïπ¥Îìú</div>
                    <div class="hand-rank-desc">Í∞Ä???íÏ? Ïπ¥Îìú</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== Í≤åÏûÑ ?ÅÌÉú =====
        const SUITS = ['??, '??, '??, '??];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        const HAND_NAMES = [
            '?òÏù¥Ïπ¥Îìú', '?êÌéò??, '?¨Ìéò??, '?∏Î¶¨??, 
            '?§Ìä∏?àÏù¥??, '?åÎü¨??, '?Ä?òÏö∞??, '?¨Ïπ¥??, 
            '?§Ìä∏?àÏù¥???åÎü¨??, 'Î°úÏñÑ ?åÎü¨??
        ];

        let game = {
            deck: [],
            myCards: [],
            opponentCards: [],
            communityCards: [],
            myChips: 1000,
            opponentChips: 1000,
            pot: 0,
            myBet: 0,
            opponentBet: 0,
            dealer: 'me', // 'me' or 'opponent'
            phase: 'idle', // idle, preflop, flop, turn, river, showdown
            currentPlayer: null,
            bigBlind: 20,
            smallBlind: 10,
            minRaise: 20,
            lastRaise: 0
        };

        // ===== ??Í¥ÄÎ¶?=====
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ suit, rank });
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function drawCards(count) {
            return game.deck.splice(0, count);
        }

        // ===== Ïπ¥Îìú ?åÎçîÎß?=====
        function renderCard(card, faceDown = false) {
            if (faceDown) {
                return '<div class="card back"></div>';
            }
            const isRed = card.suit === '?? || card.suit === '??;
            return `
                <div class="card ${isRed ? 'red' : 'black'}">
                    <span class="rank">${card.rank}</span>
                    <span class="suit">${card.suit}</span>
                </div>
            `;
        }

        function updateDisplay() {
            // ?ÅÎ? Ïπ¥Îìú
            const opponentCardsEl = document.getElementById('opponentCards');
            const showOpponent = game.phase === 'showdown';
            opponentCardsEl.innerHTML = game.opponentCards.map(c => renderCard(c, !showOpponent)).join('');

            // ??Ïπ¥Îìú
            document.getElementById('myCards').innerHTML = game.myCards.map(c => renderCard(c)).join('');

            // Ïª§Î??àÌã∞ Ïπ¥Îìú
            document.getElementById('communityCards').innerHTML = game.communityCards.map(c => renderCard(c)).join('');

            // Ïπ?            document.getElementById('myChips').textContent = game.myChips;
            document.getElementById('opponentChips').textContent = game.opponentChips;
            document.getElementById('potAmount').textContent = game.pot;

            // ?ÑÏû¨ Î≤†ÌåÖ
            document.getElementById('myBet').textContent = game.myBet > 0 ? `Î≤†ÌåÖ: ${game.myBet}` : '';
            document.getElementById('opponentBet').textContent = game.opponentBet > 0 ? `Î≤†ÌåÖ: ${game.opponentBet}` : '';

            // ?úÎü¨ Î≤ÑÌäº
            document.getElementById('myDealer').style.display = game.dealer === 'me' ? 'inline' : 'none';
            document.getElementById('opponentDealer').style.display = game.dealer === 'opponent' ? 'inline' : 'none';

            // ?∏Îìú Í≤∞Í≥º
            if (game.phase === 'showdown' || game.myCards.length > 0) {
                const myHand = evaluateHand([...game.myCards, ...game.communityCards]);
                document.getElementById('myHand').textContent = HAND_NAMES[myHand.rank];
                document.getElementById('myHand').style.display = 'block';
            } else {
                document.getElementById('myHand').style.display = 'none';
            }

            if (game.phase === 'showdown') {
                const oppHand = evaluateHand([...game.opponentCards, ...game.communityCards]);
                document.getElementById('opponentHand').textContent = HAND_NAMES[oppHand.rank];
                document.getElementById('opponentHand').style.display = 'block';
            } else {
                document.getElementById('opponentHand').style.display = 'none';
            }
        }

        // ===== ?∏Îìú ?âÍ? =====
        function getRankValue(rank) {
            return RANKS.indexOf(rank);
        }

        function evaluateHand(cards) {
            if (cards.length < 5) return { rank: 0, value: 0, kickers: [] };

            // 5??Ï°∞Ìï© Ï§?ÏµúÍ≥† Ï∞æÍ∏∞
            const combos = getCombinations(cards, 5);
            let best = { rank: 0, value: 0, kickers: [] };

            for (const combo of combos) {
                const result = evaluateFiveCards(combo);
                if (compareHands(result, best) > 0) {
                    best = result;
                }
            }

            return best;
        }

        function getCombinations(arr, size) {
            if (size === 1) return arr.map(x => [x]);
            const result = [];
            for (let i = 0; i <= arr.length - size; i++) {
                const head = arr[i];
                const tailCombos = getCombinations(arr.slice(i + 1), size - 1);
                for (const tail of tailCombos) {
                    result.push([head, ...tail]);
                }
            }
            return result;
        }

        function evaluateFiveCards(cards) {
            const ranks = cards.map(c => getRankValue(c.rank)).sort((a, b) => b - a);
            const suits = cards.map(c => c.suit);
            
            const isFlush = suits.every(s => s === suits[0]);
            const isStraight = checkStraight(ranks);
            const isWheel = ranks.join(',') === '12,3,2,1,0'; // A-2-3-4-5
            
            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const countedRanks = Object.entries(rankCounts)
                .sort((a, b) => b[1] - a[1] || b[0] - a[0])
                .map(e => parseInt(e[0]));

            // Î°úÏñÑ ?åÎü¨??            if (isFlush && isStraight && ranks[0] === 12) {
                return { rank: 9, value: 12, kickers: [] };
            }

            // ?§Ìä∏?àÏù¥???åÎü¨??            if (isFlush && (isStraight || isWheel)) {
                return { rank: 8, value: isWheel ? 3 : ranks[0], kickers: [] };
            }

            // ?¨Ïπ¥??            if (counts[0] === 4) {
                return { rank: 7, value: countedRanks[0], kickers: [countedRanks[1]] };
            }

            // ?Ä?òÏö∞??            if (counts[0] === 3 && counts[1] === 2) {
                return { rank: 6, value: countedRanks[0], kickers: [countedRanks[1]] };
            }

            // ?åÎü¨??            if (isFlush) {
                return { rank: 5, value: ranks[0], kickers: ranks.slice(1) };
            }

            // ?§Ìä∏?àÏù¥??            if (isStraight || isWheel) {
                return { rank: 4, value: isWheel ? 3 : ranks[0], kickers: [] };
            }

            // ?∏Î¶¨??            if (counts[0] === 3) {
                return { rank: 3, value: countedRanks[0], kickers: countedRanks.slice(1) };
            }

            // ?¨Ìéò??            if (counts[0] === 2 && counts[1] === 2) {
                return { rank: 2, value: Math.max(countedRanks[0], countedRanks[1]), 
                        kickers: [Math.min(countedRanks[0], countedRanks[1]), countedRanks[2]] };
            }

            // ?êÌéò??            if (counts[0] === 2) {
                return { rank: 1, value: countedRanks[0], kickers: countedRanks.slice(1) };
            }

            // ?òÏù¥Ïπ¥Îìú
            return { rank: 0, value: ranks[0], kickers: ranks.slice(1) };
        }

        function checkStraight(ranks) {
            const unique = [...new Set(ranks)].sort((a, b) => b - a);
            if (unique.length < 5) return false;
            for (let i = 0; i < 4; i++) {
                if (unique[i] - unique[i + 1] !== 1) return false;
            }
            return true;
        }

        function compareHands(a, b) {
            if (a.rank !== b.rank) return a.rank - b.rank;
            if (a.value !== b.value) return a.value - b.value;
            for (let i = 0; i < Math.max(a.kickers.length, b.kickers.length); i++) {
                const ak = a.kickers[i] || 0;
                const bk = b.kickers[i] || 0;
                if (ak !== bk) return ak - bk;
            }
            return 0;
        }

        // ===== Í≤åÏûÑ Î°úÏßÅ =====
        function newGame() {
            game.myChips = 1000;
            game.opponentChips = 1000;
            game.dealer = Math.random() < 0.5 ? 'me' : 'opponent';
            document.getElementById('resultOverlay').classList.remove('active');
            startHand();
        }

        function nextHand() {
            document.getElementById('resultOverlay').classList.remove('active');
            
            if (game.myChips <= 0) {
                showMessage('Ïπ©Ïù¥ ?ÜÏäµ?àÎã§! ??Í≤åÏûÑ???úÏûë?òÏÑ∏??');
                return;
            }
            if (game.opponentChips <= 0) {
                showMessage('?éâ ?πÎ¶¨! ?ÅÎ? Ïπ©Ïù¥ ?ÜÏäµ?àÎã§!');
                return;
            }
            
            game.dealer = game.dealer === 'me' ? 'opponent' : 'me';
            startHand();
        }

        function startHand() {
            game.deck = createDeck();
            game.myCards = drawCards(2);
            game.opponentCards = drawCards(2);
            game.communityCards = [];
            game.pot = 0;
            game.myBet = 0;
            game.opponentBet = 0;
            game.phase = 'preflop';
            game.minRaise = game.bigBlind;
            game.lastRaise = game.bigBlind;

            // Î∏îÎùº?∏Îìú ?§Ï†ï
            if (game.dealer === 'me') {
                // ?¥Í? ?úÎü¨ = ?¥Í? ?§Î™∞Î∏îÎùº?∏Îìú
                placeBet('me', Math.min(game.smallBlind, game.myChips));
                placeBet('opponent', Math.min(game.bigBlind, game.opponentChips));
                game.currentPlayer = 'me'; // ?§Î™∞Î∏îÎùº?∏ÎìúÍ∞Ä Î®ºÏ?
            } else {
                placeBet('opponent', Math.min(game.smallBlind, game.opponentChips));
                placeBet('me', Math.min(game.bigBlind, game.myChips));
                game.currentPlayer = 'opponent';
            }

            updateDisplay();
            showMessage('?ÑÎ¶¨?åÎûç');

            if (game.currentPlayer === 'opponent') {
                setTimeout(aiTurn, 1000);
            } else {
                showBettingControls();
            }
        }

        function placeBet(player, amount) {
            if (player === 'me') {
                const bet = Math.min(amount, game.myChips);
                game.myChips -= bet;
                game.myBet += bet;
                game.pot += bet;
            } else {
                const bet = Math.min(amount, game.opponentChips);
                game.opponentChips -= bet;
                game.opponentBet += bet;
                game.pot += bet;
            }
        }

        function showBettingControls() {
            const controls = document.getElementById('bettingControls');
            const buttons = document.getElementById('betButtons');
            const raiseContainer = document.getElementById('raiseContainer');
            
            controls.style.display = 'block';
            
            const toCall = game.opponentBet - game.myBet;
            const canRaise = game.myChips > toCall;
            
            let html = '<button class="bet-btn fold" onclick="playerAction(\'fold\')">?¥Îìú</button>';
            
            if (toCall === 0) {
                html += '<button class="bet-btn check" onclick="playerAction(\'check\')">Ï≤¥ÌÅ¨</button>';
            } else if (toCall > 0 && game.myChips >= toCall) {
                html += `<button class="bet-btn call" onclick="playerAction('call')">ÏΩ?(${toCall})</button>`;
            }
            
            if (canRaise && game.myChips > toCall) {
                html += '<button class="bet-btn raise" onclick="playerAction(\'raise\')">?àÏù¥Ï¶?/button>';
                raiseContainer.style.display = 'flex';
                
                const slider = document.getElementById('betSlider');
                const minRaise = toCall + game.minRaise;
                slider.min = minRaise;
                slider.max = game.myChips;
                slider.value = Math.min(minRaise * 2, game.myChips);
                updateBetDisplay();
            } else {
                raiseContainer.style.display = 'none';
            }
            
            if (game.myChips > 0) {
                html += `<button class="bet-btn allin" onclick="playerAction('allin')">?¨Ïù∏ (${game.myChips})</button>`;
            }
            
            buttons.innerHTML = html;
        }

        function updateBetDisplay() {
            const slider = document.getElementById('betSlider');
            document.getElementById('betAmountDisplay').textContent = slider.value;
        }

        document.getElementById('betSlider').addEventListener('input', updateBetDisplay);

        function playerAction(action) {
            const toCall = game.opponentBet - game.myBet;
            
            switch (action) {
                case 'fold':
                    endHand('opponent');
                    return;
                    
                case 'check':
                    break;
                    
                case 'call':
                    placeBet('me', toCall);
                    break;
                    
                case 'raise':
                    const raiseAmount = parseInt(document.getElementById('betSlider').value);
                    placeBet('me', raiseAmount);
                    game.lastRaise = raiseAmount - toCall;
                    game.minRaise = game.lastRaise;
                    break;
                    
                case 'allin':
                    placeBet('me', game.myChips);
                    break;
            }
            
            document.getElementById('bettingControls').style.display = 'none';
            updateDisplay();
            
            // Î≤†ÌåÖ ?ºÏö¥??Ï≤¥ÌÅ¨
            if (game.myBet === game.opponentBet || game.opponentChips === 0 || game.myChips === 0) {
                nextPhase();
            } else {
                game.currentPlayer = 'opponent';
                setTimeout(aiTurn, 800);
            }
        }

        // ===== AI =====
        function aiTurn() {
            const toCall = game.myBet - game.opponentBet;
            const hand = evaluateHand([...game.opponentCards, ...game.communityCards]);
            
            // ?∏Îìú Í∞ïÎèÑ Í≥ÑÏÇ∞ (0-1)
            let handStrength = hand.rank / 9;
            
            // ?ÑÎ¶¨?åÎûç ?∏Îìú Í∞ïÎèÑ Î≥¥Ï†ï
            if (game.communityCards.length === 0) {
                handStrength = evaluatePreflopHand(game.opponentCards);
            }
            
            // ???§Ï¶à Í≥ÑÏÇ∞
            const potOdds = toCall / (game.pot + toCall);
            
            // Î∏îÎü¨???ïÎ•†
            const bluffChance = Math.random();
            
            let action;
            
            if (toCall === 0) {
                // Ï≤¥ÌÅ¨ Í∞Ä??                if (handStrength > 0.6 || (handStrength > 0.3 && bluffChance > 0.7)) {
                    // Î≤†ÌåÖ
                    const betSize = Math.floor(game.pot * (0.5 + handStrength * 0.5));
                    action = { type: 'raise', amount: Math.min(betSize, game.opponentChips) };
                } else {
                    action = { type: 'check' };
                }
            } else {
                // ÏΩúÌï¥????                if (handStrength > potOdds + 0.1 || (bluffChance > 0.85 && toCall < game.pot * 0.3)) {
                    // ÏΩ??êÎäî ?àÏù¥Ï¶?                    if (handStrength > 0.7 && game.opponentChips > toCall * 2) {
                        const raiseAmount = toCall + Math.floor(game.pot * handStrength);
                        action = { type: 'raise', amount: Math.min(raiseAmount, game.opponentChips) };
                    } else {
                        action = { type: 'call' };
                    }
                } else if (handStrength > potOdds - 0.1) {
                    action = { type: 'call' };
                } else {
                    action = { type: 'fold' };
                }
            }
            
            // ?§Ìñâ
            executeAiAction(action);
        }

        function evaluatePreflopHand(cards) {
            const r1 = getRankValue(cards[0].rank);
            const r2 = getRankValue(cards[1].rank);
            const suited = cards[0].suit === cards[1].suit;
            const pair = r1 === r2;
            
            let strength = (r1 + r2) / 24; // Í∏∞Î≥∏ Í∞ïÎèÑ
            
            if (pair) strength += 0.3;
            if (suited) strength += 0.1;
            if (Math.abs(r1 - r2) <= 2) strength += 0.05; // Ïª§ÎÑ•??            
            // ?ÑÎ¶¨ÎØ∏ÏóÑ ?∏Îìú
            if (pair && r1 >= 10) strength = 0.9; // QQ+
            if (r1 === 12 && r2 >= 10) strength = 0.85; // AK, AQ, AJ
            
            return Math.min(strength, 1);
        }

        function executeAiAction(action) {
            const toCall = game.myBet - game.opponentBet;
            
            switch (action.type) {
                case 'fold':
                    showMessage('?§ñ ?¥Îìú');
                    setTimeout(() => endHand('me'), 500);
                    return;
                    
                case 'check':
                    showMessage('?§ñ Ï≤¥ÌÅ¨');
                    break;
                    
                case 'call':
                    placeBet('opponent', toCall);
                    showMessage(`?§ñ ÏΩ?(${toCall})`);
                    break;
                    
                case 'raise':
                    placeBet('opponent', action.amount);
                    showMessage(`?§ñ ?àÏù¥Ï¶?(${action.amount})`);
                    break;
            }
            
            updateDisplay();
            
            if (action.type === 'raise' && game.myChips > 0) {
                game.currentPlayer = 'me';
                setTimeout(showBettingControls, 500);
            } else {
                setTimeout(nextPhase, 500);
            }
        }

        function nextPhase() {
            game.myBet = 0;
            game.opponentBet = 0;
            
            switch (game.phase) {
                case 'preflop':
                    game.phase = 'flop';
                    game.communityCards = drawCards(3);
                    showMessage('?åÎûç');
                    break;
                    
                case 'flop':
                    game.phase = 'turn';
                    game.communityCards.push(...drawCards(1));
                    showMessage('??);
                    break;
                    
                case 'turn':
                    game.phase = 'river';
                    game.communityCards.push(...drawCards(1));
                    showMessage('Î¶¨Î≤Ñ');
                    break;
                    
                case 'river':
                    showdown();
                    return;
            }
            
            updateDisplay();
            
            // ?¨Ïù∏ ?ÅÌÉúÎ©??êÎèô ÏßÑÌñâ
            if (game.myChips === 0 || game.opponentChips === 0) {
                setTimeout(nextPhase, 1000);
                return;
            }
            
            // ?úÎü¨ Î∞òÎ?Í∞Ä Î®ºÏ?
            game.currentPlayer = game.dealer === 'me' ? 'opponent' : 'me';
            
            if (game.currentPlayer === 'opponent') {
                setTimeout(aiTurn, 800);
            } else {
                showBettingControls();
            }
        }

        function showdown() {
            game.phase = 'showdown';
            updateDisplay();
            
            const myHand = evaluateHand([...game.myCards, ...game.communityCards]);
            const oppHand = evaluateHand([...game.opponentCards, ...game.communityCards]);
            
            const comparison = compareHands(myHand, oppHand);
            
            if (comparison > 0) {
                endHand('me', HAND_NAMES[myHand.rank]);
            } else if (comparison < 0) {
                endHand('opponent', HAND_NAMES[oppHand.rank]);
            } else {
                endHand('tie');
            }
        }

        function endHand(winner, winningHand = '') {
            game.phase = 'showdown';
            document.getElementById('bettingControls').style.display = 'none';
            
            const overlay = document.getElementById('resultOverlay');
            const title = document.getElementById('resultTitle');
            const detail = document.getElementById('resultDetail');
            
            if (winner === 'me') {
                game.myChips += game.pot;
                title.textContent = '?éâ ?πÎ¶¨!';
                title.className = 'result-title win';
                detail.textContent = winningHand ? `${winningHand}?ºÎ°ú +${game.pot} ?çÎìù` : `+${game.pot} ?çÎìù`;
            } else if (winner === 'opponent') {
                game.opponentChips += game.pot;
                title.textContent = '?ò¢ ?®Î∞∞';
                title.className = 'result-title lose';
                detail.textContent = winningHand ? `?ÅÎ?: ${winningHand}` : '';
            } else {
                game.myChips += game.pot / 2;
                game.opponentChips += game.pot / 2;
                title.textContent = '?§ù Î¨¥ÏäπÎ∂Ä';
                title.className = 'result-title tie';
                detail.textContent = '??Î∂ÑÎ∞∞';
            }
            
            game.pot = 0;
            updateDisplay();
            overlay.classList.add('active');
        }

        function showMessage(text) {
            document.getElementById('gameMessage').textContent = text;
        }

        function showRules() {
            document.getElementById('rulesModal').classList.add('active');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('active');
        }

        // Î™®Îã¨ ?∏Î? ?¥Î¶≠???´Í∏∞
        document.getElementById('rulesModal').addEventListener('click', (e) => {
            if (e.target.id === 'rulesModal') closeRules();
        });

        // ===== Multiplayer Mode =====
        let multiplayerClient = null;
        let isMultiplayer = false;
        let isHost = false;
        let myReady = false;

        function startSinglePlayer() {
            isMultiplayer = false;
            document.getElementById('modeSelect').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            updateDisplay();
        }

        function showLobby() {
            document.getElementById('modeSelect').classList.add('hidden');
            document.getElementById('lobby').classList.remove('hidden');
            
            // Clean up any previous multiplayer state
            if (multiplayerClient) {
                multiplayerClient.cleanup();
            }
            
            // Restore nickname if saved
            const savedNickname = localStorage.getItem('poker_nickname');
            if (savedNickname) {
                document.getElementById('nicknameInput').value = savedNickname;
            }
        }

        function backToModeSelect() {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('modeSelect').classList.remove('hidden');
        }

        async function createMultiplayerRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            const nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                alert('?âÎÑ§?ÑÏùÑ 2???¥ÏÉÅ ?ÖÎ†•?òÏÑ∏??);
                return;
            }
            
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                const isPublic = document.getElementById('publicRoomCheck').checked;
                
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                const room = await multiplayerClient.createRoom('poker', { 
                    gameConfig: { startingChips: 1000, bigBlind: 20 },
                    maxPlayers: 2,
                    isPublic 
                });
                isHost = true;
                showWaitingRoom(room.roomId);
            } catch (e) {
                alert('Î∞??ùÏÑ± ?§Ìå®: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function joinRandomRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            let nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                nickname = 'Player_' + Math.random().toString(36).substr(2, 4);
            }
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                const result = await multiplayerClient.joinRandom('poker');
                isHost = false;
                showWaitingRoom(result.roomId);
                
                if (result.alreadyJoined) {
                    showToast('?¥Î? Ï∞∏Í???Î∞©ÏûÖ?àÎã§');
                }
            } catch (e) {
                if (e.message.includes('Í≥µÍ∞ú Î∞©Ïù¥ ??)) {
                    alert('?ÑÏû¨ Ï∞∏Í? Í∞Ä?•Ìïú Í≥µÍ∞ú Î∞©Ïù¥ ?ÜÏäµ?àÎã§.\n??Î∞©ÏùÑ ÎßåÎì§?¥Î≥¥?∏Ïöî!');
                } else {
                    alert('?úÎç§ Îß§Ïπ≠ ?§Ìå®: ' + e.message);
                }
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function joinMultiplayerRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode || roomCode.length !== 6) {
                alert('6?êÎ¶¨ Î∞?ÏΩîÎìúÎ•??ÖÎ†•?òÏÑ∏??);
                return;
            }
            
            let nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                nickname = 'Player_' + Math.random().toString(36).substr(2, 4);
            }
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                await multiplayerClient.joinRoom(roomCode);
                isHost = false;
                showWaitingRoom(roomCode);
            } catch (e) {
                alert('?ÖÏû• ?§Ìå®: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        function showWaitingRoom(roomCode) {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('waitingRoom').classList.remove('hidden');
            document.getElementById('displayRoomCode').textContent = roomCode;
            
            // Reset button states
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');
            startBtn.classList.remove('loading');
            readyBtn.classList.remove('loading');
            
            // Host: show start button & destroy button, hide ready button
            // Non-host: show ready button, hide start & destroy buttons
            startBtn.style.display = isHost ? 'inline-block' : 'none';
            readyBtn.style.display = isHost ? 'none' : 'inline-block';
            document.getElementById('destroyBtn').style.display = isHost ? 'inline-block' : 'none';
            
            // Generate QR code with room code
            const baseUrl = window.location.origin + window.location.pathname.replace(/\/$/, '');
            const joinUrl = `${baseUrl}/?room=${roomCode}`;
            console.log('QR URL:', joinUrl); // debug
            const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(joinUrl)}`;
            document.getElementById('qrCode').innerHTML = `
                <img src="${qrUrl}" alt="QR Code" style="border-radius:8px;background:#fff;padding:8px;">
                <div style="font-size:0.7rem;color:#666;margin-top:4px;">${joinUrl}</div>
            `;
            
            // Start listening for updates
            multiplayerClient.onStateChange = updateWaitingRoom;
            multiplayerClient.onEvent = handleMultiplayerEvent;
            multiplayerClient.startListening();
            
            // Initial state load
            refreshWaitingRoom();
        }

        async function refreshWaitingRoom() {
            try {
                const state = await multiplayerClient.getRoomState();
                updateWaitingRoom(state);
            } catch (e) {
                console.error('Failed to refresh:', e);
            }
        }

        function updateWaitingRoom(state) {
            if (!state || !state.players) return;
            
            const playerList = document.getElementById('playerList');
            const myId = multiplayerClient.getMyUserId();
            
            // Update isHost and myReady based on server state
            const me = state.players.find(p => p.id === myId);
            if (me) {
                isHost = me.isHost;
                myReady = me.isReady;
            }
            
            // Update button visibility based on host status
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');
            const destroyBtn = document.getElementById('destroyBtn');
            startBtn.style.display = isHost ? 'inline-block' : 'none';
            readyBtn.style.display = isHost ? 'none' : 'inline-block';
            destroyBtn.style.display = isHost ? 'inline-block' : 'none';
            
            // Sync ready button text with server state
            readyBtn.textContent = myReady ? 'Ï§ÄÎπÑÏ∑®?? : 'Ï§ÄÎπ?;
            readyBtn.classList.toggle('primary', myReady);
            
            playerList.innerHTML = state.players.map(p => `
                <div class="player-item">
                    <span class="name">${p.isHost ? '?ëë ' : ''}${p.nickname || 'Player'} ${p.id === myId ? '(??' : ''}</span>
                    <span class="status ${p.isReady ? 'ready' : ''} ${p.isHost ? 'host' : ''}">${p.isHost ? 'Î∞©Ïû•' : (p.isReady ? 'Ï§ÄÎπÑÏôÑÎ£? : '?ÄÍ∏∞Ï§ë')}</span>
                </div>
            `).join('');
            
            // Update start button for host
            if (isHost) {
                const others = state.players.filter(p => !p.isHost);
                const allReady = others.length > 0 && others.every(p => p.isReady);
                const canStart = state.players.length >= 2 && allReady;
                startBtn.disabled = !canStart;
                startBtn.classList.remove('loading'); // Clear loading state
                document.getElementById('waitingMessage').textContent = canStart ? 'Í≤åÏûÑ???úÏûë?????àÏäµ?àÎã§!' : '?§Î•∏ ?åÎ†à?¥Ïñ¥Î•?Í∏∞Îã§Î¶¨Îäî Ï§?..';
            } else {
                document.getElementById('waitingMessage').textContent = myReady ? 'Î∞©Ïû•???úÏûë?òÍ∏∞Î•?Í∏∞Îã§Î¶¨Îäî Ï§?..' : 'Ï§ÄÎπ?Î≤ÑÌäº???åÎü¨Ï£ºÏÑ∏??;
            }
            
            // Check if game started
            if (state.status === 'playing') {
                startMultiplayerGameFromState(state);
            }
        }

        function handleMultiplayerEvent(type, data) {
            console.log('MP Event:', type, data);
            
            if (type === 'game_started') {
                refreshWaitingRoom();
            } else if (type === 'room_destroyed') {
                // Room was destroyed by host
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                alert('Î∞©Ïù¥ ??åå?òÏóà?µÎãà??');
            }
        }

        async function toggleReady() {
            const btn = document.getElementById('readyBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                const newReady = !myReady;
                await multiplayerClient.setReady(newReady);
                // Server confirmed, now update local state
                myReady = newReady;
                btn.textContent = myReady ? 'Ï§ÄÎπÑÏ∑®?? : 'Ï§ÄÎπ?;
                btn.classList.toggle('primary', myReady);
            } catch (e) {
                alert('Ï§ÄÎπ??ÅÌÉú Î≥ÄÍ≤??§Ìå®: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function leaveWaitingRoom() {
            const btn = document.getElementById('leaveBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.leaveRoom();
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
            } catch (e) {
                console.error('Leave error:', e);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function destroyRoom() {
            if (!confirm('?ïÎßê Î∞©ÏùÑ ??åå?òÏãúÍ≤†Ïäµ?àÍπå?\nÎ™®Îì† ?åÎ†à?¥Ïñ¥Í∞Ä ?¥Ïû•?©Îãà??')) return;
            
            const btn = document.getElementById('destroyBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.destroyRoom();
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                showToast('Î∞©Ïù¥ ??åå?òÏóà?µÎãà??);
            } catch (e) {
                alert('Î∞???åå ?§Ìå®: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function startMultiplayerGame() {
            const btn = document.getElementById('startBtn');
            if (btn.classList.contains('loading') || btn.disabled) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.startGame();
                // Game will start via event
            } catch (e) {
                alert('Í≤åÏûÑ ?úÏûë ?§Ìå®: ' + e.message);
                btn.classList.remove('loading');
            }
        }

        let mpState = null; // Multiplayer game state

        function startMultiplayerGameFromState(state) {
            isMultiplayer = true;
            mpState = state;
            
            document.getElementById('waitingRoom').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            
            // Update header for multiplayer
            const header = document.querySelector('.header-buttons');
            header.innerHTML = '<button class="btn" onclick="showRules()">?ìñ Î£?/button><button class="btn" onclick="leaveMultiplayerGame()">?òÍ?Í∏?/button>';
            
            // Change opponent name
            const myId = multiplayerClient.getMyUserId();
            const opponent = state.players.find(p => p.id !== myId);
            if (opponent) {
                document.querySelector('.opponent-area .player-name').textContent = '?ë§ ' + (opponent.nickname || 'Player');
            }
            document.querySelector('.my-area .player-name').textContent = '?ë§ ??;
            
            // Setup event handlers
            multiplayerClient.onStateChange = updateMultiplayerDisplay;
            multiplayerClient.onEvent = handleGameEvent;
            
            updateMultiplayerDisplay(state);
            showMessage('Í≤åÏûÑ ?úÏûë!');
        }

        function updateMultiplayerDisplay(state) {
            if (!state || !state.gameState) return;
            mpState = state;
            
            const gs = state.gameState;
            const myView = state.myView || gs;
            const myId = multiplayerClient.getMyUserId();
            
            // Find me and opponent
            const me = gs.players.find(p => p.id === myId);
            const opponent = gs.players.find(p => p.id !== myId);
            
            if (!me || !opponent) return;
            
            // Update chips
            document.getElementById('myChips').textContent = me.chips;
            document.getElementById('opponentChips').textContent = opponent.chips;
            document.getElementById('potAmount').textContent = gs.pot;
            
            // Update bets
            document.getElementById('myBet').textContent = me.bet > 0 ? `Î≤†ÌåÖ: ${me.bet}` : '';
            document.getElementById('opponentBet').textContent = opponent.bet > 0 ? `Î≤†ÌåÖ: ${opponent.bet}` : '';
            
            // My cards
            const myHand = myView.myHand || [];
            document.getElementById('myCards').innerHTML = myHand.map(c => renderCard(c)).join('');
            
            // Opponent cards (hidden unless showdown)
            const showOpponent = gs.phase === 'showdown' || gs.phase === 'finished';
            const oppHand = myView.showdownHands?.[opponent.id] || [];
            if (showOpponent && oppHand.length > 0) {
                document.getElementById('opponentCards').innerHTML = oppHand.map(c => renderCard(c)).join('');
            } else {
                document.getElementById('opponentCards').innerHTML = opponent.folded ? '' : 
                    '<div class="card back"></div><div class="card back"></div>';
            }
            
            // Community cards
            document.getElementById('communityCards').innerHTML = gs.communityCards.map(c => renderCard(c)).join('');
            
            // Dealer button
            const imDealer = gs.dealerSeat === me.seat;
            document.getElementById('myDealer').style.display = imDealer ? 'inline' : 'none';
            document.getElementById('opponentDealer').style.display = !imDealer ? 'inline' : 'none';
            
            // Hand evaluation display
            if (myHand.length > 0 && gs.communityCards.length >= 3) {
                const hand = evaluateHand([...myHand, ...gs.communityCards]);
                document.getElementById('myHand').textContent = HAND_NAMES[hand.rank];
                document.getElementById('myHand').style.display = 'block';
            } else {
                document.getElementById('myHand').style.display = 'none';
            }
            
            if (showOpponent && oppHand.length > 0 && gs.communityCards.length >= 3) {
                const hand = evaluateHand([...oppHand, ...gs.communityCards]);
                document.getElementById('opponentHand').textContent = HAND_NAMES[hand.rank];
                document.getElementById('opponentHand').style.display = 'block';
            } else {
                document.getElementById('opponentHand').style.display = 'none';
            }
            
            // Show phase
            const phaseNames = { preflop: '?ÑÎ¶¨?åÎûç', flop: '?åÎûç', turn: '??, river: 'Î¶¨Î≤Ñ', showdown: '?ºÎã§??, finished: 'Ï¢ÖÎ£å' };
            if (gs.phase !== 'finished') {
                showMessage(phaseNames[gs.phase] || gs.phase);
            }
            
            // Betting controls - only if it's my turn and game is active
            const isMyTurn = myView.isMyTurn && !me.folded && !me.isAllIn && gs.phase !== 'showdown' && gs.phase !== 'finished';
            if (isMyTurn) {
                showMultiplayerBettingControls(me, gs.currentBet, gs.bigBlind);
            } else {
                document.getElementById('bettingControls').style.display = 'none';
            }
            
            // Game over
            if (gs.phase === 'finished') {
                handleMultiplayerGameEnd(state);
            }
        }

        function showMultiplayerBettingControls(me, currentBet, minRaise) {
            const controls = document.getElementById('bettingControls');
            const buttons = document.getElementById('betButtons');
            const raiseContainer = document.getElementById('raiseContainer');
            
            controls.style.display = 'block';
            
            const toCall = currentBet - me.bet;
            const canRaise = me.chips > toCall;
            
            let html = '<button class="bet-btn fold" onclick="mpAction(\'fold\')">?¥Îìú</button>';
            
            if (toCall === 0) {
                html += '<button class="bet-btn check" onclick="mpAction(\'check\')">Ï≤¥ÌÅ¨</button>';
            } else if (toCall > 0 && me.chips >= toCall) {
                html += `<button class="bet-btn call" onclick="mpAction('call')">ÏΩ?(${Math.min(toCall, me.chips)})</button>`;
            }
            
            if (canRaise && me.chips > toCall) {
                html += '<button class="bet-btn raise" onclick="mpAction(\'raise\')">?àÏù¥Ï¶?/button>';
                raiseContainer.style.display = 'flex';
                
                const slider = document.getElementById('betSlider');
                const minTotal = currentBet + minRaise;
                slider.min = minTotal;
                slider.max = me.chips + me.bet;
                slider.value = Math.min(minTotal * 2, me.chips + me.bet);
                updateBetDisplay();
            } else {
                raiseContainer.style.display = 'none';
            }
            
            if (me.chips > 0) {
                html += `<button class="bet-btn allin" onclick="mpAction('allin')">?¨Ïù∏ (${me.chips})</button>`;
            }
            
            buttons.innerHTML = html;
        }

        async function mpAction(action) {
            // Disable controls while sending
            document.getElementById('bettingControls').style.display = 'none';
            
            try {
                let actionData = { type: action };
                
                if (action === 'raise') {
                    const amount = parseInt(document.getElementById('betSlider').value);
                    actionData.payload = { amount };
                }
                
                const result = await multiplayerClient.sendAction(actionData);
                
                // State will update via onStateChange
                if (result && result.gameState) {
                    updateMultiplayerDisplay({ ...mpState, gameState: result.gameState, myView: result.myView });
                }
            } catch (e) {
                alert('?°ÏÖò ?§Ìå®: ' + e.message);
                // Re-fetch state to show controls if still my turn
                const state = await multiplayerClient.getRoomState();
                updateMultiplayerDisplay(state);
            }
        }

        function handleGameEvent(type, data) {
            console.log('Game Event:', type, data);
            
            // Show action messages
            const actionMsgs = {
                fold: '?¥Îìú',
                check: 'Ï≤¥ÌÅ¨',
                call: 'ÏΩ?,
                raise: '?àÏù¥Ï¶?,
                allin: '?¨Ïù∏',
                flop: '?åÎûç',
                turn: '??,
                river: 'Î¶¨Î≤Ñ'
            };
            
            if (actionMsgs[type]) {
                const myId = multiplayerClient.getMyUserId();
                const isMe = data.userId === myId;
                if (!isMe && ['fold', 'check', 'call', 'raise', 'allin'].includes(type)) {
                    const amount = data.payload?.amount ? ` (${data.payload.amount})` : '';
                    showToast(`?ÅÎ?: ${actionMsgs[type]}${amount}`);
                }
            }
            
            if (type === 'win') {
                const myId = multiplayerClient.getMyUserId();
                const isMe = data.playerId === myId;
                setTimeout(() => {
                    const hand = data.payload?.hand || '';
                    if (isMe) {
                        showToast(`?éâ ?πÎ¶¨! ${hand ? hand + '?ºÎ°ú ' : ''}+${data.payload?.amount}`);
                    } else {
                        showToast(`?ò¢ ?®Î∞∞ ${hand ? '(?ÅÎ?: ' + hand + ')' : ''}`);
                    }
                }, 500);
            }
            
            // Handle rematch - other player requested rematch, go to waiting room
            if (type === 'rematch_ready') {
                const myId = multiplayerClient.getMyUserId();
                if (data.userId !== myId) {
                    showToast('?ÅÎ?Í∞Ä Î¶¨Îß§ÏπòÎ? ?îÏ≤≠?àÏäµ?àÎã§!');
                    setTimeout(() => goToWaitingRoom(), 1000);
                }
            }
        }

        let gameEndHandled = false;

        function handleMultiplayerGameEnd(state) {
            if (gameEndHandled) return;
            gameEndHandled = true;
            
            const overlay = document.getElementById('resultOverlay');
            const title = document.getElementById('resultTitle');
            const detail = document.getElementById('resultDetail');
            
            const gs = state.gameState;
            const myId = multiplayerClient.getMyUserId();
            const me = gs.players.find(p => p.id === myId);
            const opponent = gs.players.find(p => p.id !== myId);
            
            // Determine winner by chip count change
            if (me.chips > opponent.chips) {
                title.textContent = '?éâ ?¥Î≤à ?∏Îìú ?πÎ¶¨!';
                title.className = 'result-title win';
            } else if (me.chips < opponent.chips) {
                title.textContent = '?ò¢ ?¥Î≤à ?∏Îìú ?®Î∞∞';
                title.className = 'result-title lose';
            } else {
                title.textContent = '?§ù Î¨¥ÏäπÎ∂Ä';
                title.className = 'result-title tie';
            }
            
            detail.textContent = `??Ïπ? ${me.chips} | ?ÅÎ? Ïπ? ${opponent.chips}`;
            
            // Clear old buttons
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = 'none';
            
            // Add rematch buttons
            const btnContainer = document.createElement('div');
            btnContainer.className = 'mp-buttons';
            btnContainer.style.cssText = 'display:flex;gap:10px;justify-content:center;margin-top:20px;';
            btnContainer.innerHTML = `
                <button class="btn primary" id="rematchBtn">?îÑ Î¶¨Îß§Ïπ?/button>
                <button class="btn" id="exitBtn">?òÍ?Í∏?/button>
            `;
            overlay.appendChild(btnContainer);
            
            document.getElementById('rematchBtn').onclick = requestRematch;
            document.getElementById('exitBtn').onclick = exitToLobby;
            
            overlay.classList.add('active');
        }

        async function requestRematch() {
            const btn = document.getElementById('rematchBtn');
            if (!btn || btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            btn.textContent = '?îÏ≤≠ Ï§?..';
            
            try {
                await multiplayerClient.rematch();
                goToWaitingRoom();
            } catch (e) {
                alert('Î¶¨Îß§Ïπ??îÏ≤≠ ?§Ìå®: ' + e.message);
                btn.classList.remove('loading');
                btn.textContent = '?îÑ Î¶¨Îß§Ïπ?;
            }
        }

        function goToWaitingRoom() {
            gameEndHandled = false;
            
            // Hide overlay and clean up
            const overlay = document.getElementById('resultOverlay');
            overlay.classList.remove('active');
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = '';
            
            // Switch screens
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('waitingRoom').classList.remove('hidden');
            
            // Reset button loading states
            const readyBtn = document.getElementById('readyBtn');
            const startBtn = document.getElementById('startBtn');
            readyBtn.classList.remove('loading');
            startBtn.classList.remove('loading');
            startBtn.disabled = true;
            
            // Reconnect event listeners for waiting room
            multiplayerClient.onStateChange = updateWaitingRoom;
            multiplayerClient.onEvent = handleMultiplayerEvent;
            
            // Fetch latest state (this will sync myReady and isHost)
            refreshWaitingRoom();
        }

        function exitToLobby() {
            gameEndHandled = false;
            
            // Hide overlay and clean up
            const overlay = document.getElementById('resultOverlay');
            overlay.classList.remove('active');
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = '';
            
            leaveMultiplayerGame(true); // skip confirm
        }

        async function leaveMultiplayerGame(skipConfirm = false) {
            if (skipConfirm || confirm('Í≤åÏûÑ???òÍ??úÍ≤†?µÎãàÍπ?')) {
                if (multiplayerClient) {
                    try {
                        await multiplayerClient.leaveRoom();
                    } catch (e) {
                        console.error('Leave error:', e);
                    }
                    MultiplayerClient.resetInstance();
                    multiplayerClient = null;
                }
                
                isHost = false;
                myReady = false;
                isMultiplayer = false;
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                
                // Reset header
                const header = document.querySelector('.header-buttons');
                header.innerHTML = '<button class="btn" onclick="showRules()">?ìñ Î£?/button><button class="btn primary" onclick="newGame()">??Í≤åÏûÑ</button>';
            }
        }

        function copyRoomCode() {
            const code = document.getElementById('displayRoomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('ÏΩîÎìú Î≥µÏÇ¨??');
            }).catch(() => {
                prompt('ÏΩîÎìúÎ•?Î≥µÏÇ¨?òÏÑ∏??', code);
            });
        }

        function shareRoomLink() {
            const code = document.getElementById('displayRoomCode').textContent;
            const url = `${window.location.origin}${window.location.pathname}?room=${code}`;
            
            if (navigator.share) {
                navigator.share({
                    title: '?¨Ïª§ Í≤åÏûÑ Ï¥àÎ?',
                    text: `?¨Ïª§ Í≤åÏûÑ??Ï∞∏Í??òÏÑ∏?? Î∞?ÏΩîÎìú: ${code}`,
                    url: url
                }).catch(() => {});
            } else {
                navigator.clipboard.writeText(url).then(() => {
                    showToast('ÎßÅÌÅ¨ Î≥µÏÇ¨??');
                }).catch(() => {
                    prompt('ÎßÅÌÅ¨Î•?Î≥µÏÇ¨?òÏÑ∏??', url);
                });
            }
        }

        function showToast(msg) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = msg;
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:#fff;padding:12px 24px;border-radius:8px;z-index:999;animation:fadeIn 0.3s;';
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // URL ?åÎùºÎØ∏ÌÑ∞Î°?Î∞?ÏΩîÎìúÍ∞Ä ?àÏúºÎ©??êÎèô ?ÖÏû•
        function checkUrlRoom() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                // Clear URL params
                window.history.replaceState({}, '', window.location.pathname);
                // Show lobby with room code filled
                showLobby();
                document.getElementById('roomCodeInput').value = roomCode;
            }
        }

        // Override newGame for single player
        const originalNewGame = newGame;
        newGame = function() {
            if (isMultiplayer) {
                // TODO: Handle multiplayer new game
                return;
            }
            originalNewGame();
        };

        // Ï¥àÍ∏∞??- Î™®Îìú ?†ÌÉù ?îÎ©¥ ?úÏãú
        // updateDisplay(); // Skip - game container is hidden
        
        // Check for room code in URL
        checkUrlRoom();
    </script>
    <script src="/lib/multiplayer.js?v=202602100852"></script>
</body>
</html>
