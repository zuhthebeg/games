<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>포커 - 텍사스 홀덤</title>
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <style>
        :root {
            --bg: #0d1117;
            --table: #1a472a;
            --table-border: #2d5a3d;
            --card-bg: #fff;
            --card-back: #1e3a5f;
            --text: #e6edf3;
            --gold: #ffd700;
            --red: #ef4444;
            --chip: #22c55e;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }

        h1 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn.primary {
            background: var(--chip);
            border-color: var(--chip);
            color: #000;
        }

        /* 테이블 영역 */
        .poker-table {
            background: linear-gradient(145deg, var(--table), #0f2d1a);
            border: 8px solid var(--table-border);
            border-radius: 120px;
            padding: 20px;
            margin: 10px 0;
            min-height: 400px;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 0 60px rgba(0,0,0,0.3);
        }

        /* 플레이어 영역 */
        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .opponent-area {
            margin-bottom: 20px;
        }

        .my-area {
            margin-top: 20px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 20px;
        }

        .player-name {
            font-weight: 600;
        }

        .chip-count {
            color: var(--gold);
            font-weight: 700;
        }

        .dealer-btn {
            background: var(--gold);
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
        }

        /* 카드 */
        .cards {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .card {
            width: 60px;
            height: 84px;
            background: var(--card-bg);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 700;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.3s;
        }

        .card.back {
            background: linear-gradient(135deg, var(--card-back), #0f2840);
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255,255,255,0.03) 10px,
                rgba(255,255,255,0.03) 20px
            );
        }

        .card.red { color: var(--red); }
        .card.black { color: #1a1a1a; }

        .card .rank {
            font-size: 1.4rem;
            line-height: 1;
        }

        .card .suit {
            font-size: 1.6rem;
            line-height: 1;
        }

        /* 커뮤니티 카드 */
        .community-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .community-cards {
            display: flex;
            gap: 8px;
        }

        .community-cards .card {
            width: 55px;
            height: 77px;
        }

        .pot-display {
            background: rgba(0,0,0,0.5);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 1.1rem;
        }

        .pot-amount {
            color: var(--gold);
            font-weight: 700;
        }

        /* 베팅 컨트롤 */
        .betting-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin-top: 10px;
        }

        .bet-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .bet-btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bet-btn.fold {
            background: #6b7280;
            color: white;
        }

        .bet-btn.check, .bet-btn.call {
            background: #3b82f6;
            color: white;
        }

        .bet-btn.raise, .bet-btn.bet {
            background: var(--chip);
            color: #000;
        }

        .bet-btn.allin {
            background: var(--red);
            color: white;
        }

        .bet-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bet-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bet-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--gold);
            border-radius: 50%;
            cursor: pointer;
        }

        .bet-amount-display {
            min-width: 80px;
            text-align: center;
            font-weight: 700;
            color: var(--gold);
        }

        /* 메시지 */
        .game-message {
            text-align: center;
            padding: 10px;
            font-size: 1.1rem;
            min-height: 40px;
        }

        .hand-result {
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* 모달 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1c2128;
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            width: 100%;
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .hand-rank {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .hand-rank-num {
            width: 30px;
            height: 30px;
            background: var(--gold);
            color: #000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .hand-rank-name {
            font-weight: 600;
            flex: 1;
        }

        .hand-rank-desc {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        /* 결과 화면 */
        .result-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px 50px;
            border-radius: 16px;
            text-align: center;
            z-index: 100;
        }

        .result-overlay.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .result-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .result-title.win { color: var(--gold); }
        .result-title.lose { color: var(--red); }
        .result-title.tie { color: #9ca3af; }

        .result-detail {
            font-size: 1rem;
            margin-bottom: 20px;
        }

        /* 반응형 */
        @media (max-width: 480px) {
            .card {
                width: 50px;
                height: 70px;
                font-size: 1rem;
            }

            .card .rank { font-size: 1.2rem; }
            .card .suit { font-size: 1.3rem; }

            .community-cards .card {
                width: 45px;
                height: 63px;
            }

            .poker-table {
                border-radius: 60px;
                padding: 15px;
            }

            .bet-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        .action-indicator {
            position: absolute;
            background: var(--gold);
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .current-bet {
            font-size: 0.9rem;
            color: var(--gold);
        }

        /* ===== Multiplayer UI ===== */
        .mode-select {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            gap: 20px;
        }

        .mode-select.hidden { display: none; }

        .mode-select h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .mode-select p {
            color: #9ca3af;
            margin-bottom: 30px;
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mode-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 30px 40px;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 200px;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: var(--gold);
            transform: translateY(-4px);
        }

        .mode-btn .icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 10px;
        }

        .mode-btn .label {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .mode-btn .desc {
            font-size: 0.85rem;
            color: #9ca3af;
            margin-top: 5px;
        }

        /* Lobby */
        .lobby {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            z-index: 200;
            overflow-y: auto;
        }

        .lobby.hidden { display: none; }

        .lobby-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
        }

        .lobby-header h2 {
            flex: 1;
            font-size: 1.5rem;
        }

        .lobby-content {
            width: 100%;
            max-width: 500px;
        }

        .lobby-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .lobby-section h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-group input {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text);
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: #666;
        }

        /* Waiting Room */
        .waiting-room {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 200;
        }

        .waiting-room.hidden { display: none; }

        .room-code {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--gold);
            margin: 20px 0;
        }

        .room-code-label {
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .player-list {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            margin: 20px 0;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .player-item:last-child { border-bottom: none; }

        .player-item .name { flex: 1; }

        .player-item .status {
            font-size: 0.85rem;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
        }

        .player-item .status.ready {
            background: var(--chip);
            color: #000;
        }

        .player-item .status.host {
            background: var(--gold);
            color: #000;
        }

        .waiting-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .copy-btn {
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .copy-btn:hover { background: rgba(255,255,255,0.1); }

        /* Loading States */
        .btn.loading, .mode-btn.loading {
            pointer-events: none;
            opacity: 0.7;
            position: relative;
        }

        .btn.loading::after, .mode-btn.loading::after {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .share-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .share-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text);
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .share-btn:hover { background: rgba(255,255,255,0.2); }
        .share-btn.primary { background: var(--chip); color: #000; border-color: var(--chip); }
    </style>
</head>
<body>
    <!-- Mode Selection -->
    <div class="mode-select" id="modeSelect">
        <h1>🃏 텍사스 홀덤</h1>
        <div id="sharedGoldDisplay" style="background:rgba(255,215,0,0.15);border:1px solid rgba(255,215,0,0.3);border-radius:20px;padding:8px 20px;margin:10px auto;width:fit-content;font-weight:600;">💰 0 G</div>
        <p>게임 모드를 선택하세요</p>
        <div class="mode-buttons">
            <button class="mode-btn" onclick="startSinglePlayer()">
                <span class="icon">🤖</span>
                <span class="label">싱글플레이</span>
                <span class="desc">AI와 1:1 대전</span>
            </button>
            <button class="mode-btn" onclick="showLobby()">
                <span class="icon">👥</span>
                <span class="label">멀티플레이</span>
                <span class="desc">친구와 대전</span>
            </button>
        </div>
    </div>

    <!-- Multiplayer Lobby -->
    <div class="lobby hidden" id="lobby">
        <div class="lobby-header">
            <button class="btn" onclick="backToModeSelect()">← 뒤로</button>
            <h2>👥 멀티플레이</h2>
        </div>
        <div class="lobby-content">
            <div class="lobby-section">
                <h3>🎮 새 게임 만들기</h3>
                <div class="input-group" style="margin-bottom:10px;">
                    <input type="text" id="nicknameInput" placeholder="닉네임 입력" maxlength="20">
                </div>
                <label style="display:flex;align-items:center;gap:8px;margin-bottom:12px;cursor:pointer;">
                    <input type="checkbox" id="publicRoomCheck" checked style="width:18px;height:18px;">
                    <span>🌐 랜덤 참가 허용 (공개 방)</span>
                </label>
                <button class="btn primary" onclick="createMultiplayerRoom()" style="width:100%;">방 만들기</button>
            </div>
            <div class="lobby-section">
                <h3>🎲 빠른 참가</h3>
                <button class="btn primary" onclick="joinRandomRoom()" style="width:100%;margin-bottom:12px;">🎲 랜덤 매칭</button>
                <div style="text-align:center;color:#666;margin:8px 0;">또는</div>
                <div class="input-group">
                    <input type="text" id="roomCodeInput" placeholder="방 코드 (6자리)" maxlength="6" style="text-transform: uppercase;">
                    <button class="btn" onclick="joinMultiplayerRoom()">참가</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Waiting Room -->
    <div class="waiting-room hidden" id="waitingRoom">
        <button class="btn" onclick="leaveWaitingRoom()" style="position:absolute;top:20px;left:20px;">← 나가기</button>
        <h2>대기실</h2>
        <div class="room-code-label">방 코드</div>
        <div class="room-code" id="displayRoomCode">------</div>
        <div id="qrCode" style="margin:15px 0;"></div>
        <div class="share-buttons">
            <button class="share-btn" onclick="copyRoomCode()">📋 코드 복사</button>
            <button class="share-btn primary" onclick="shareRoomLink()">🔗 링크 공유</button>
        </div>
        
        <div class="player-list" id="playerList">
            <!-- Players will be listed here -->
        </div>
        
        <div class="waiting-actions" id="waitingActions">
            <button class="btn" id="readyBtn" onclick="toggleReady()">준비</button>
            <button class="btn primary" id="startBtn" onclick="startMultiplayerGame()">게임 시작</button>
            <button class="btn" id="leaveBtn" onclick="leaveWaitingRoom()">나가기</button>
            <button class="btn" id="destroyBtn" onclick="destroyRoom()" style="background:#ef4444;border-color:#ef4444;display:none;">🗑️ 방 폭파</button>
        </div>
        <p id="waitingMessage" style="color:#9ca3af;margin-top:15px;">다른 플레이어를 기다리는 중...</p>
    </div>

    <div class="game-container" id="gameContainer" style="display:none;">
        <header>
            <h1>🃏 포커</h1>
            <div class="header-buttons">
                <button class="btn" onclick="showRules()">📖 룰</button>
                <button class="btn primary" onclick="newGame()">새 게임</button>
            </div>
        </header>

        <div class="poker-table">
            <!-- 상대 영역 -->
            <div class="player-area opponent-area">
                <div class="player-info">
                    <span class="player-name">🤖 컴퓨터</span>
                    <span class="chip-count" id="opponentChips">1000</span>
                    <span class="dealer-btn" id="opponentDealer" style="display:none">D</span>
                </div>
                <div class="cards" id="opponentCards"></div>
                <div class="hand-result" id="opponentHand" style="display:none"></div>
                <div class="current-bet" id="opponentBet"></div>
            </div>

            <!-- 커뮤니티 카드 -->
            <div class="community-area">
                <div class="community-cards" id="communityCards"></div>
                <div class="pot-display">
                    팟: <span class="pot-amount" id="potAmount">0</span>
                </div>
            </div>

            <!-- 결과 오버레이 -->
            <div class="result-overlay" id="resultOverlay">
                <div class="result-title" id="resultTitle">승리!</div>
                <div class="result-detail" id="resultDetail"></div>
                <button class="btn primary" onclick="nextHand()">다음 핸드</button>
            </div>

            <!-- 내 영역 -->
            <div class="player-area my-area">
                <div class="current-bet" id="myBet"></div>
                <div class="cards" id="myCards"></div>
                <div class="hand-result" id="myHand"></div>
                <div class="player-info">
                    <span class="player-name">👤 나</span>
                    <span class="chip-count" id="myChips">1000</span>
                    <span class="dealer-btn" id="myDealer" style="display:none">D</span>
                </div>
            </div>
        </div>

        <div class="game-message" id="gameMessage">새 게임을 시작하세요!</div>

        <div class="betting-controls" id="bettingControls" style="display:none">
            <div class="bet-slider-container" id="raiseContainer" style="display:none">
                <input type="range" class="bet-slider" id="betSlider" min="0" max="1000" value="20">
                <div class="bet-amount-display" id="betAmountDisplay">20</div>
            </div>
            <div class="bet-buttons" id="betButtons"></div>
        </div>
    </div>

    <!-- 룰 모달 -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <h2>
                📖 텍사스 홀덤 룰
                <button class="close-btn" onclick="closeRules()">×</button>
            </h2>

            <h3 style="margin: 16px 0 8px">🎮 게임 진행</h3>
            <p style="line-height: 1.6; color: #9ca3af; margin-bottom: 16px">
                1. 각 플레이어에게 2장의 카드(홀카드)가 배분됩니다.<br>
                2. 5장의 커뮤니티 카드가 순차적으로 공개됩니다.<br>
                3. 홀카드 2장 + 커뮤니티 5장 중 5장으로 최고 조합을 만듭니다.<br>
                4. 베팅 라운드: 프리플랍 → 플랍 → 턴 → 리버
            </p>

            <h3 style="margin: 16px 0 8px">💰 베팅 액션</h3>
            <p style="line-height: 1.6; color: #9ca3af; margin-bottom: 16px">
                <b>폴드</b>: 포기하고 팟을 상대에게 양보<br>
                <b>체크</b>: 베팅 없이 차례 넘기기 (상대가 베팅 안했을 때)<br>
                <b>콜</b>: 상대 베팅과 같은 금액 베팅<br>
                <b>레이즈</b>: 상대 베팅보다 더 많이 베팅<br>
                <b>올인</b>: 모든 칩을 베팅
            </p>

            <h3 style="margin: 16px 0 8px">🏆 핸드 순위 (높은 순)</h3>
            
            <div class="hand-rank">
                <div class="hand-rank-num">1</div>
                <div>
                    <div class="hand-rank-name">로얄 플러시</div>
                    <div class="hand-rank-desc">A K Q J 10 같은 무늬</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">2</div>
                <div>
                    <div class="hand-rank-name">스트레이트 플러시</div>
                    <div class="hand-rank-desc">연속 5장 같은 무늬</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">3</div>
                <div>
                    <div class="hand-rank-name">포카드</div>
                    <div class="hand-rank-desc">같은 숫자 4장</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">4</div>
                <div>
                    <div class="hand-rank-name">풀하우스</div>
                    <div class="hand-rank-desc">트리플 + 페어</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">5</div>
                <div>
                    <div class="hand-rank-name">플러시</div>
                    <div class="hand-rank-desc">같은 무늬 5장</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">6</div>
                <div>
                    <div class="hand-rank-name">스트레이트</div>
                    <div class="hand-rank-desc">연속 숫자 5장</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">7</div>
                <div>
                    <div class="hand-rank-name">트리플</div>
                    <div class="hand-rank-desc">같은 숫자 3장</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">8</div>
                <div>
                    <div class="hand-rank-name">투페어</div>
                    <div class="hand-rank-desc">페어 2개</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">9</div>
                <div>
                    <div class="hand-rank-name">원페어</div>
                    <div class="hand-rank-desc">같은 숫자 2장</div>
                </div>
            </div>
            
            <div class="hand-rank">
                <div class="hand-rank-num">10</div>
                <div>
                    <div class="hand-rank-name">하이카드</div>
                    <div class="hand-rank-desc">가장 높은 카드</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== 공용 재화 시스템 =====
        let sharedGold = 0;
        let cloudSyncEnabled = false;
        const BUY_IN_COST = 500;  // 바이인 비용 (골드)
        const CHIP_VALUE = 0.5;    // 칩 1개 = 0.5 골드
        
        async function loadSharedGold() {
            // 먼저 로컬 스토리지에서 로드
            const localData = localStorage.getItem('enhance_game_v3');
            if (localData) {
                const parsed = JSON.parse(localData);
                sharedGold = parsed.gold || 0;
            }
            
            // 로그인 유저면 클라우드에서 로드
            const token = localStorage.getItem('cocy_auth_token');
            if (!token) return;
            
            try {
                const parts = token.split('.');
                if (parts.length !== 3) return;
                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
                
                if (payload.sub) {
                    cloudSyncEnabled = true;
                    const res = await fetch('https://relay.cocy.io/api/user/data', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data.gold !== undefined) {
                            sharedGold = data.gold;
                        }
                    }
                }
            } catch (e) {
                console.log('Cloud sync failed:', e);
            }
            
            updateGoldDisplay();
        }
        
        async function saveSharedGold() {
            // 로컬 저장 (enhance_game_v3와 동기화)
            const localData = localStorage.getItem('enhance_game_v3');
            const parsed = localData ? JSON.parse(localData) : { gold: 0, weapon: null, mastery: { attacks: 0, kills: 0 }, stats: {} };
            parsed.gold = sharedGold;
            localStorage.setItem('enhance_game_v3', JSON.stringify(parsed));
            
            // 클라우드 저장
            if (!cloudSyncEnabled) return;
            const token = localStorage.getItem('cocy_auth_token');
            if (!token) return;
            
            try {
                await fetch('https://relay.cocy.io/api/user/data', {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        gold: sharedGold,
                        ...parsed
                    })
                });
            } catch (e) {
                console.log('Cloud save failed:', e);
            }
            
            updateGoldDisplay();
        }
        
        function updateGoldDisplay() {
            const el = document.getElementById('sharedGoldDisplay');
            if (el) {
                el.innerHTML = `💰 ${sharedGold.toLocaleString()} G ${cloudSyncEnabled ? '<span style="color:#4ecca3;font-size:0.8em;">☁️</span>' : ''}`;
            }
        }
        
        // ===== 게임 상태 =====
        const SUITS = ['♠', '♥', '♦', '♣'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        const HAND_NAMES = [
            '하이카드', '원페어', '투페어', '트리플', 
            '스트레이트', '플러시', '풀하우스', '포카드', 
            '스트레이트 플러시', '로얄 플러시'
        ];

        let game = {
            deck: [],
            myCards: [],
            opponentCards: [],
            communityCards: [],
            myChips: 1000,
            opponentChips: 1000,
            pot: 0,
            myBet: 0,
            opponentBet: 0,
            dealer: 'me', // 'me' or 'opponent'
            phase: 'idle', // idle, preflop, flop, turn, river, showdown
            currentPlayer: null,
            bigBlind: 20,
            smallBlind: 10,
            minRaise: 20,
            lastRaise: 0
        };

        // ===== 덱 관리 =====
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ suit, rank });
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function drawCards(count) {
            return game.deck.splice(0, count);
        }

        // ===== 카드 렌더링 =====
        function renderCard(card, faceDown = false) {
            if (faceDown) {
                return '<div class="card back"></div>';
            }
            const isRed = card.suit === '♥' || card.suit === '♦';
            return `
                <div class="card ${isRed ? 'red' : 'black'}">
                    <span class="rank">${card.rank}</span>
                    <span class="suit">${card.suit}</span>
                </div>
            `;
        }

        function updateDisplay() {
            // 상대 카드
            const opponentCardsEl = document.getElementById('opponentCards');
            const showOpponent = game.phase === 'showdown';
            opponentCardsEl.innerHTML = game.opponentCards.map(c => renderCard(c, !showOpponent)).join('');

            // 내 카드
            document.getElementById('myCards').innerHTML = game.myCards.map(c => renderCard(c)).join('');

            // 커뮤니티 카드
            document.getElementById('communityCards').innerHTML = game.communityCards.map(c => renderCard(c)).join('');

            // 칩
            document.getElementById('myChips').textContent = game.myChips;
            document.getElementById('opponentChips').textContent = game.opponentChips;
            document.getElementById('potAmount').textContent = game.pot;

            // 현재 베팅
            document.getElementById('myBet').textContent = game.myBet > 0 ? `베팅: ${game.myBet}` : '';
            document.getElementById('opponentBet').textContent = game.opponentBet > 0 ? `베팅: ${game.opponentBet}` : '';

            // 딜러 버튼
            document.getElementById('myDealer').style.display = game.dealer === 'me' ? 'inline' : 'none';
            document.getElementById('opponentDealer').style.display = game.dealer === 'opponent' ? 'inline' : 'none';

            // 핸드 결과
            if (game.phase === 'showdown' || game.myCards.length > 0) {
                const myHand = evaluateHand([...game.myCards, ...game.communityCards]);
                document.getElementById('myHand').textContent = HAND_NAMES[myHand.rank];
                document.getElementById('myHand').style.display = 'block';
            } else {
                document.getElementById('myHand').style.display = 'none';
            }

            if (game.phase === 'showdown') {
                const oppHand = evaluateHand([...game.opponentCards, ...game.communityCards]);
                document.getElementById('opponentHand').textContent = HAND_NAMES[oppHand.rank];
                document.getElementById('opponentHand').style.display = 'block';
            } else {
                document.getElementById('opponentHand').style.display = 'none';
            }
        }

        // ===== 핸드 평가 =====
        function getRankValue(rank) {
            return RANKS.indexOf(rank);
        }

        function evaluateHand(cards) {
            if (cards.length < 5) return { rank: 0, value: 0, kickers: [] };

            // 5장 조합 중 최고 찾기
            const combos = getCombinations(cards, 5);
            let best = { rank: 0, value: 0, kickers: [] };

            for (const combo of combos) {
                const result = evaluateFiveCards(combo);
                if (compareHands(result, best) > 0) {
                    best = result;
                }
            }

            return best;
        }

        function getCombinations(arr, size) {
            if (size === 1) return arr.map(x => [x]);
            const result = [];
            for (let i = 0; i <= arr.length - size; i++) {
                const head = arr[i];
                const tailCombos = getCombinations(arr.slice(i + 1), size - 1);
                for (const tail of tailCombos) {
                    result.push([head, ...tail]);
                }
            }
            return result;
        }

        function evaluateFiveCards(cards) {
            const ranks = cards.map(c => getRankValue(c.rank)).sort((a, b) => b - a);
            const suits = cards.map(c => c.suit);
            
            const isFlush = suits.every(s => s === suits[0]);
            const isStraight = checkStraight(ranks);
            const isWheel = ranks.join(',') === '12,3,2,1,0'; // A-2-3-4-5
            
            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const countedRanks = Object.entries(rankCounts)
                .sort((a, b) => b[1] - a[1] || b[0] - a[0])
                .map(e => parseInt(e[0]));

            // 로얄 플러시
            if (isFlush && isStraight && ranks[0] === 12) {
                return { rank: 9, value: 12, kickers: [] };
            }

            // 스트레이트 플러시
            if (isFlush && (isStraight || isWheel)) {
                return { rank: 8, value: isWheel ? 3 : ranks[0], kickers: [] };
            }

            // 포카드
            if (counts[0] === 4) {
                return { rank: 7, value: countedRanks[0], kickers: [countedRanks[1]] };
            }

            // 풀하우스
            if (counts[0] === 3 && counts[1] === 2) {
                return { rank: 6, value: countedRanks[0], kickers: [countedRanks[1]] };
            }

            // 플러시
            if (isFlush) {
                return { rank: 5, value: ranks[0], kickers: ranks.slice(1) };
            }

            // 스트레이트
            if (isStraight || isWheel) {
                return { rank: 4, value: isWheel ? 3 : ranks[0], kickers: [] };
            }

            // 트리플
            if (counts[0] === 3) {
                return { rank: 3, value: countedRanks[0], kickers: countedRanks.slice(1) };
            }

            // 투페어
            if (counts[0] === 2 && counts[1] === 2) {
                return { rank: 2, value: Math.max(countedRanks[0], countedRanks[1]), 
                        kickers: [Math.min(countedRanks[0], countedRanks[1]), countedRanks[2]] };
            }

            // 원페어
            if (counts[0] === 2) {
                return { rank: 1, value: countedRanks[0], kickers: countedRanks.slice(1) };
            }

            // 하이카드
            return { rank: 0, value: ranks[0], kickers: ranks.slice(1) };
        }

        function checkStraight(ranks) {
            const unique = [...new Set(ranks)].sort((a, b) => b - a);
            if (unique.length < 5) return false;
            for (let i = 0; i < 4; i++) {
                if (unique[i] - unique[i + 1] !== 1) return false;
            }
            return true;
        }

        function compareHands(a, b) {
            if (a.rank !== b.rank) return a.rank - b.rank;
            if (a.value !== b.value) return a.value - b.value;
            for (let i = 0; i < Math.max(a.kickers.length, b.kickers.length); i++) {
                const ak = a.kickers[i] || 0;
                const bk = b.kickers[i] || 0;
                if (ak !== bk) return ak - bk;
            }
            return 0;
        }

        // ===== 게임 로직 =====
        function newGame() {
            game.myChips = 1000;
            game.opponentChips = 1000;
            game.dealer = Math.random() < 0.5 ? 'me' : 'opponent';
            document.getElementById('resultOverlay').classList.remove('active');
            startHand();
        }

        function nextHand() {
            document.getElementById('resultOverlay').classList.remove('active');
            
            if (game.myChips <= 0) {
                showMessage('칩이 없습니다! 새 게임을 시작하세요.');
                return;
            }
            if (game.opponentChips <= 0) {
                showMessage('🎉 승리! 상대 칩이 없습니다!');
                return;
            }
            
            game.dealer = game.dealer === 'me' ? 'opponent' : 'me';
            startHand();
        }

        function startHand() {
            game.deck = createDeck();
            game.myCards = drawCards(2);
            game.opponentCards = drawCards(2);
            game.communityCards = [];
            game.pot = 0;
            game.myBet = 0;
            game.opponentBet = 0;
            game.phase = 'preflop';
            game.minRaise = game.bigBlind;
            game.lastRaise = game.bigBlind;

            // 블라인드 설정
            if (game.dealer === 'me') {
                // 내가 딜러 = 내가 스몰블라인드
                placeBet('me', Math.min(game.smallBlind, game.myChips));
                placeBet('opponent', Math.min(game.bigBlind, game.opponentChips));
                game.currentPlayer = 'me'; // 스몰블라인드가 먼저
            } else {
                placeBet('opponent', Math.min(game.smallBlind, game.opponentChips));
                placeBet('me', Math.min(game.bigBlind, game.myChips));
                game.currentPlayer = 'opponent';
            }

            updateDisplay();
            showMessage('프리플랍');

            if (game.currentPlayer === 'opponent') {
                setTimeout(aiTurn, 1000);
            } else {
                showBettingControls();
            }
        }

        function placeBet(player, amount) {
            if (player === 'me') {
                const bet = Math.min(amount, game.myChips);
                game.myChips -= bet;
                game.myBet += bet;
                game.pot += bet;
            } else {
                const bet = Math.min(amount, game.opponentChips);
                game.opponentChips -= bet;
                game.opponentBet += bet;
                game.pot += bet;
            }
        }

        function showBettingControls() {
            const controls = document.getElementById('bettingControls');
            const buttons = document.getElementById('betButtons');
            const raiseContainer = document.getElementById('raiseContainer');
            
            controls.style.display = 'block';
            
            const toCall = game.opponentBet - game.myBet;
            const canRaise = game.myChips > toCall;
            
            let html = '<button class="bet-btn fold" onclick="playerAction(\'fold\')">폴드</button>';
            
            if (toCall === 0) {
                html += '<button class="bet-btn check" onclick="playerAction(\'check\')">체크</button>';
            } else if (toCall > 0 && game.myChips >= toCall) {
                html += `<button class="bet-btn call" onclick="playerAction('call')">콜 (${toCall})</button>`;
            }
            
            if (canRaise && game.myChips > toCall) {
                html += '<button class="bet-btn raise" onclick="playerAction(\'raise\')">레이즈</button>';
                raiseContainer.style.display = 'flex';
                
                const slider = document.getElementById('betSlider');
                const minRaise = toCall + game.minRaise;
                slider.min = minRaise;
                slider.max = game.myChips;
                slider.value = Math.min(minRaise * 2, game.myChips);
                updateBetDisplay();
            } else {
                raiseContainer.style.display = 'none';
            }
            
            if (game.myChips > 0) {
                html += `<button class="bet-btn allin" onclick="playerAction('allin')">올인 (${game.myChips})</button>`;
            }
            
            buttons.innerHTML = html;
        }

        function updateBetDisplay() {
            const slider = document.getElementById('betSlider');
            document.getElementById('betAmountDisplay').textContent = slider.value;
        }

        document.getElementById('betSlider').addEventListener('input', updateBetDisplay);

        function playerAction(action) {
            const toCall = game.opponentBet - game.myBet;
            
            switch (action) {
                case 'fold':
                    endHand('opponent');
                    return;
                    
                case 'check':
                    break;
                    
                case 'call':
                    placeBet('me', toCall);
                    break;
                    
                case 'raise':
                    const raiseAmount = parseInt(document.getElementById('betSlider').value);
                    placeBet('me', raiseAmount);
                    game.lastRaise = raiseAmount - toCall;
                    game.minRaise = game.lastRaise;
                    break;
                    
                case 'allin':
                    placeBet('me', game.myChips);
                    break;
            }
            
            document.getElementById('bettingControls').style.display = 'none';
            updateDisplay();
            
            // 베팅 라운드 체크
            if (game.myBet === game.opponentBet || game.opponentChips === 0 || game.myChips === 0) {
                nextPhase();
            } else {
                game.currentPlayer = 'opponent';
                setTimeout(aiTurn, 800);
            }
        }

        // ===== AI =====
        function aiTurn() {
            const toCall = game.myBet - game.opponentBet;
            const hand = evaluateHand([...game.opponentCards, ...game.communityCards]);
            
            // 핸드 강도 계산 (0-1)
            let handStrength = hand.rank / 9;
            
            // 프리플랍 핸드 강도 보정
            if (game.communityCards.length === 0) {
                handStrength = evaluatePreflopHand(game.opponentCards);
            }
            
            // 팟 오즈 계산
            const potOdds = toCall / (game.pot + toCall);
            
            // 블러핑 확률
            const bluffChance = Math.random();
            
            let action;
            
            if (toCall === 0) {
                // 체크 가능
                if (handStrength > 0.6 || (handStrength > 0.3 && bluffChance > 0.7)) {
                    // 베팅
                    const betSize = Math.floor(game.pot * (0.5 + handStrength * 0.5));
                    action = { type: 'raise', amount: Math.min(betSize, game.opponentChips) };
                } else {
                    action = { type: 'check' };
                }
            } else {
                // 콜해야 함
                if (handStrength > potOdds + 0.1 || (bluffChance > 0.85 && toCall < game.pot * 0.3)) {
                    // 콜 또는 레이즈
                    if (handStrength > 0.7 && game.opponentChips > toCall * 2) {
                        const raiseAmount = toCall + Math.floor(game.pot * handStrength);
                        action = { type: 'raise', amount: Math.min(raiseAmount, game.opponentChips) };
                    } else {
                        action = { type: 'call' };
                    }
                } else if (handStrength > potOdds - 0.1) {
                    action = { type: 'call' };
                } else {
                    action = { type: 'fold' };
                }
            }
            
            // 실행
            executeAiAction(action);
        }

        function evaluatePreflopHand(cards) {
            const r1 = getRankValue(cards[0].rank);
            const r2 = getRankValue(cards[1].rank);
            const suited = cards[0].suit === cards[1].suit;
            const pair = r1 === r2;
            
            let strength = (r1 + r2) / 24; // 기본 강도
            
            if (pair) strength += 0.3;
            if (suited) strength += 0.1;
            if (Math.abs(r1 - r2) <= 2) strength += 0.05; // 커넥터
            
            // 프리미엄 핸드
            if (pair && r1 >= 10) strength = 0.9; // QQ+
            if (r1 === 12 && r2 >= 10) strength = 0.85; // AK, AQ, AJ
            
            return Math.min(strength, 1);
        }

        function executeAiAction(action) {
            const toCall = game.myBet - game.opponentBet;
            
            switch (action.type) {
                case 'fold':
                    showMessage('🤖 폴드');
                    setTimeout(() => endHand('me'), 500);
                    return;
                    
                case 'check':
                    showMessage('🤖 체크');
                    break;
                    
                case 'call':
                    placeBet('opponent', toCall);
                    showMessage(`🤖 콜 (${toCall})`);
                    break;
                    
                case 'raise':
                    placeBet('opponent', action.amount);
                    showMessage(`🤖 레이즈 (${action.amount})`);
                    break;
            }
            
            updateDisplay();
            
            if (action.type === 'raise' && game.myChips > 0) {
                game.currentPlayer = 'me';
                setTimeout(showBettingControls, 500);
            } else {
                setTimeout(nextPhase, 500);
            }
        }

        function nextPhase() {
            game.myBet = 0;
            game.opponentBet = 0;
            
            switch (game.phase) {
                case 'preflop':
                    game.phase = 'flop';
                    game.communityCards = drawCards(3);
                    showMessage('플랍');
                    break;
                    
                case 'flop':
                    game.phase = 'turn';
                    game.communityCards.push(...drawCards(1));
                    showMessage('턴');
                    break;
                    
                case 'turn':
                    game.phase = 'river';
                    game.communityCards.push(...drawCards(1));
                    showMessage('리버');
                    break;
                    
                case 'river':
                    showdown();
                    return;
            }
            
            updateDisplay();
            
            // 올인 상태면 자동 진행
            if (game.myChips === 0 || game.opponentChips === 0) {
                setTimeout(nextPhase, 1000);
                return;
            }
            
            // 딜러 반대가 먼저
            game.currentPlayer = game.dealer === 'me' ? 'opponent' : 'me';
            
            if (game.currentPlayer === 'opponent') {
                setTimeout(aiTurn, 800);
            } else {
                showBettingControls();
            }
        }

        function showdown() {
            game.phase = 'showdown';
            updateDisplay();
            
            const myHand = evaluateHand([...game.myCards, ...game.communityCards]);
            const oppHand = evaluateHand([...game.opponentCards, ...game.communityCards]);
            
            const comparison = compareHands(myHand, oppHand);
            
            if (comparison > 0) {
                endHand('me', HAND_NAMES[myHand.rank]);
            } else if (comparison < 0) {
                endHand('opponent', HAND_NAMES[oppHand.rank]);
            } else {
                endHand('tie');
            }
        }

        function endHand(winner, winningHand = '') {
            game.phase = 'showdown';
            document.getElementById('bettingControls').style.display = 'none';
            
            const overlay = document.getElementById('resultOverlay');
            const title = document.getElementById('resultTitle');
            const detail = document.getElementById('resultDetail');
            
            // 칩 변동 계산 (골드 보상용)
            const potWon = game.pot;
            let goldChange = 0;
            
            if (winner === 'me') {
                game.myChips += game.pot;
                goldChange = Math.floor(potWon * CHIP_VALUE);
                title.textContent = '🎉 승리!';
                title.className = 'result-title win';
                detail.innerHTML = winningHand 
                    ? `${winningHand}으로 +${game.pot} 획득 <span style="color:#4ecca3">+${goldChange}G</span>` 
                    : `+${game.pot} 획득 <span style="color:#4ecca3">+${goldChange}G</span>`;
            } else if (winner === 'opponent') {
                game.opponentChips += game.pot;
                goldChange = -Math.floor(potWon * CHIP_VALUE);
                title.textContent = '😢 패배';
                title.className = 'result-title lose';
                detail.innerHTML = winningHand 
                    ? `상대: ${winningHand} <span style="color:#ef4444">${goldChange}G</span>` 
                    : `<span style="color:#ef4444">${goldChange}G</span>`;
            } else {
                game.myChips += game.pot / 2;
                game.opponentChips += game.pot / 2;
                title.textContent = '🤝 무승부';
                title.className = 'result-title tie';
                detail.textContent = '팟 분배';
            }
            
            // 골드 변동 적용 (싱글플레이)
            if (goldChange !== 0) {
                sharedGold = Math.max(0, sharedGold + goldChange);
                saveSharedGold();
            }
            
            game.pot = 0;
            updateDisplay();
            overlay.classList.add('active');
        }

        function showMessage(text) {
            document.getElementById('gameMessage').textContent = text;
        }

        function showRules() {
            document.getElementById('rulesModal').classList.add('active');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('active');
        }

        // 모달 외부 클릭시 닫기
        document.getElementById('rulesModal').addEventListener('click', (e) => {
            if (e.target.id === 'rulesModal') closeRules();
        });

        // ===== Multiplayer Mode =====
        let multiplayerClient = null;
        let isMultiplayer = false;
        let isHost = false;
        let myReady = false;

        function startSinglePlayer() {
            isMultiplayer = false;
            document.getElementById('modeSelect').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            updateDisplay();
        }

        function showLobby() {
            document.getElementById('modeSelect').classList.add('hidden');
            document.getElementById('lobby').classList.remove('hidden');
            
            // Clean up any previous multiplayer state
            if (multiplayerClient) {
                multiplayerClient.cleanup();
            }
            
            // Restore nickname if saved
            const savedNickname = localStorage.getItem('poker_nickname');
            if (savedNickname) {
                document.getElementById('nicknameInput').value = savedNickname;
            }
        }

        function backToModeSelect() {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('modeSelect').classList.remove('hidden');
        }

        async function createMultiplayerRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            const nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                alert('닉네임을 2자 이상 입력하세요');
                return;
            }
            
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                const isPublic = document.getElementById('publicRoomCheck').checked;
                
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                const room = await multiplayerClient.createRoom('poker', { 
                    gameConfig: { startingChips: 1000, bigBlind: 20 },
                    maxPlayers: 2,
                    isPublic 
                });
                isHost = true;
                showWaitingRoom(room.roomId);
            } catch (e) {
                alert('방 생성 실패: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function joinRandomRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            let nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                nickname = 'Player_' + Math.random().toString(36).substr(2, 4);
            }
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                const result = await multiplayerClient.joinRandom('poker');
                isHost = false;
                showWaitingRoom(result.roomId);
                
                if (result.alreadyJoined) {
                    showToast('이미 참가한 방입니다');
                }
            } catch (e) {
                if (e.message.includes('공개 방이 없')) {
                    alert('현재 참가 가능한 공개 방이 없습니다.\n새 방을 만들어보세요!');
                } else {
                    alert('랜덤 매칭 실패: ' + e.message);
                }
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function joinMultiplayerRoom() {
            const btn = event.target;
            if (btn.classList.contains('loading')) return;
            
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode || roomCode.length !== 6) {
                alert('6자리 방 코드를 입력하세요');
                return;
            }
            
            let nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname || nickname.length < 2) {
                nickname = 'Player_' + Math.random().toString(36).substr(2, 4);
            }
            localStorage.setItem('poker_nickname', nickname);
            btn.classList.add('loading');
            
            try {
                multiplayerClient = MultiplayerClient.getInstance();
                await multiplayerClient.ensureAuth();
                await multiplayerClient.setNickname(nickname);
                
                await multiplayerClient.joinRoom(roomCode);
                isHost = false;
                showWaitingRoom(roomCode);
            } catch (e) {
                alert('입장 실패: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        function showWaitingRoom(roomCode) {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('waitingRoom').classList.remove('hidden');
            document.getElementById('displayRoomCode').textContent = roomCode;
            
            // Reset button states
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');
            startBtn.classList.remove('loading');
            readyBtn.classList.remove('loading');
            
            // Host: show start button & destroy button, hide ready button
            // Non-host: show ready button, hide start & destroy buttons
            startBtn.style.display = isHost ? 'inline-block' : 'none';
            readyBtn.style.display = isHost ? 'none' : 'inline-block';
            document.getElementById('destroyBtn').style.display = isHost ? 'inline-block' : 'none';
            
            // Generate QR code with room code
            const baseUrl = window.location.origin + window.location.pathname.replace(/\/$/, '');
            const joinUrl = `${baseUrl}/?room=${roomCode}`;
            console.log('QR URL:', joinUrl); // debug
            const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(joinUrl)}`;
            document.getElementById('qrCode').innerHTML = `
                <img src="${qrUrl}" alt="QR Code" style="border-radius:8px;background:#fff;padding:8px;">
                <div style="font-size:0.7rem;color:#666;margin-top:4px;">${joinUrl}</div>
            `;
            
            // Start listening for updates
            multiplayerClient.onStateChange = updateWaitingRoom;
            multiplayerClient.onEvent = handleMultiplayerEvent;
            multiplayerClient.startListening();
            
            // Initial state load
            refreshWaitingRoom();
        }

        async function refreshWaitingRoom() {
            try {
                const state = await multiplayerClient.getRoomState();
                updateWaitingRoom(state);
            } catch (e) {
                console.error('Failed to refresh:', e);
            }
        }

        function updateWaitingRoom(state) {
            if (!state || !state.players) return;
            
            const playerList = document.getElementById('playerList');
            const myId = multiplayerClient.getMyUserId();
            
            // Update isHost and myReady based on server state
            const me = state.players.find(p => p.id === myId);
            if (me) {
                isHost = me.isHost;
                myReady = me.isReady;
            }
            
            // Update button visibility based on host status
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');
            const destroyBtn = document.getElementById('destroyBtn');
            startBtn.style.display = isHost ? 'inline-block' : 'none';
            readyBtn.style.display = isHost ? 'none' : 'inline-block';
            destroyBtn.style.display = isHost ? 'inline-block' : 'none';
            
            // Sync ready button text with server state
            readyBtn.textContent = myReady ? '준비취소' : '준비';
            readyBtn.classList.toggle('primary', myReady);
            
            playerList.innerHTML = state.players.map(p => `
                <div class="player-item">
                    <span class="name">${p.isHost ? '👑 ' : ''}${p.nickname || 'Player'} ${p.id === myId ? '(나)' : ''}</span>
                    <span class="status ${p.isReady ? 'ready' : ''} ${p.isHost ? 'host' : ''}">${p.isHost ? '방장' : (p.isReady ? '준비완료' : '대기중')}</span>
                </div>
            `).join('');
            
            // Update start button for host
            if (isHost) {
                const others = state.players.filter(p => !p.isHost);
                const allReady = others.length > 0 && others.every(p => p.isReady);
                const canStart = state.players.length >= 2 && allReady;
                startBtn.disabled = !canStart;
                startBtn.classList.remove('loading'); // Clear loading state
                document.getElementById('waitingMessage').textContent = canStart ? '게임을 시작할 수 있습니다!' : '다른 플레이어를 기다리는 중...';
            } else {
                document.getElementById('waitingMessage').textContent = myReady ? '방장이 시작하기를 기다리는 중...' : '준비 버튼을 눌러주세요';
            }
            
            // Check if game started
            if (state.status === 'playing') {
                startMultiplayerGameFromState(state);
            }
        }

        function handleMultiplayerEvent(type, data) {
            console.log('MP Event:', type, data);
            
            if (type === 'game_started') {
                refreshWaitingRoom();
            } else if (type === 'room_destroyed') {
                // Room was destroyed by host
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                alert('방이 폭파되었습니다.');
            }
        }

        async function toggleReady() {
            const btn = document.getElementById('readyBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                const newReady = !myReady;
                await multiplayerClient.setReady(newReady);
                // Server confirmed, now update local state
                myReady = newReady;
                btn.textContent = myReady ? '준비취소' : '준비';
                btn.classList.toggle('primary', myReady);
            } catch (e) {
                alert('준비 상태 변경 실패: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function leaveWaitingRoom() {
            const btn = document.getElementById('leaveBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.leaveRoom();
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
            } catch (e) {
                console.error('Leave error:', e);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function destroyRoom() {
            if (!confirm('정말 방을 폭파하시겠습니까?\n모든 플레이어가 퇴장됩니다.')) return;
            
            const btn = document.getElementById('destroyBtn');
            if (btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.destroyRoom();
                MultiplayerClient.resetInstance();
                multiplayerClient = null;
                isHost = false;
                myReady = false;
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                showToast('방이 폭파되었습니다');
            } catch (e) {
                alert('방 폭파 실패: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        }

        async function startMultiplayerGame() {
            const btn = document.getElementById('startBtn');
            if (btn.classList.contains('loading') || btn.disabled) return;
            btn.classList.add('loading');
            
            try {
                await multiplayerClient.startGame();
                // Game will start via event
            } catch (e) {
                alert('게임 시작 실패: ' + e.message);
                btn.classList.remove('loading');
            }
        }

        let mpState = null; // Multiplayer game state

        function startMultiplayerGameFromState(state) {
            isMultiplayer = true;
            mpState = state;
            
            document.getElementById('waitingRoom').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            
            // Update header for multiplayer
            const header = document.querySelector('.header-buttons');
            header.innerHTML = '<button class="btn" onclick="showRules()">📖 룰</button><button class="btn" onclick="leaveMultiplayerGame()">나가기</button>';
            
            // Change opponent name
            const myId = multiplayerClient.getMyUserId();
            const opponent = state.players.find(p => p.id !== myId);
            if (opponent) {
                document.querySelector('.opponent-area .player-name').textContent = '👤 ' + (opponent.nickname || 'Player');
            }
            document.querySelector('.my-area .player-name').textContent = '👤 나';
            
            // Setup event handlers
            multiplayerClient.onStateChange = updateMultiplayerDisplay;
            multiplayerClient.onEvent = handleGameEvent;
            
            updateMultiplayerDisplay(state);
            showMessage('게임 시작!');
        }

        function updateMultiplayerDisplay(state) {
            if (!state || !state.gameState) return;
            mpState = state;
            
            const gs = state.gameState;
            const myView = state.myView || gs;
            const myId = multiplayerClient.getMyUserId();
            
            // Find me and opponent
            const me = gs.players.find(p => p.id === myId);
            const opponent = gs.players.find(p => p.id !== myId);
            
            if (!me || !opponent) return;
            
            // Update chips
            document.getElementById('myChips').textContent = me.chips;
            document.getElementById('opponentChips').textContent = opponent.chips;
            document.getElementById('potAmount').textContent = gs.pot;
            
            // Update bets
            document.getElementById('myBet').textContent = me.bet > 0 ? `베팅: ${me.bet}` : '';
            document.getElementById('opponentBet').textContent = opponent.bet > 0 ? `베팅: ${opponent.bet}` : '';
            
            // My cards
            const myHand = myView.myHand || [];
            document.getElementById('myCards').innerHTML = myHand.map(c => renderCard(c)).join('');
            
            // Opponent cards (hidden unless showdown)
            const showOpponent = gs.phase === 'showdown' || gs.phase === 'finished';
            const oppHand = myView.showdownHands?.[opponent.id] || [];
            if (showOpponent && oppHand.length > 0) {
                document.getElementById('opponentCards').innerHTML = oppHand.map(c => renderCard(c)).join('');
            } else {
                document.getElementById('opponentCards').innerHTML = opponent.folded ? '' : 
                    '<div class="card back"></div><div class="card back"></div>';
            }
            
            // Community cards
            document.getElementById('communityCards').innerHTML = gs.communityCards.map(c => renderCard(c)).join('');
            
            // Dealer button
            const imDealer = gs.dealerSeat === me.seat;
            document.getElementById('myDealer').style.display = imDealer ? 'inline' : 'none';
            document.getElementById('opponentDealer').style.display = !imDealer ? 'inline' : 'none';
            
            // Hand evaluation display
            if (myHand.length > 0 && gs.communityCards.length >= 3) {
                const hand = evaluateHand([...myHand, ...gs.communityCards]);
                document.getElementById('myHand').textContent = HAND_NAMES[hand.rank];
                document.getElementById('myHand').style.display = 'block';
            } else {
                document.getElementById('myHand').style.display = 'none';
            }
            
            if (showOpponent && oppHand.length > 0 && gs.communityCards.length >= 3) {
                const hand = evaluateHand([...oppHand, ...gs.communityCards]);
                document.getElementById('opponentHand').textContent = HAND_NAMES[hand.rank];
                document.getElementById('opponentHand').style.display = 'block';
            } else {
                document.getElementById('opponentHand').style.display = 'none';
            }
            
            // Show phase
            const phaseNames = { preflop: '프리플랍', flop: '플랍', turn: '턴', river: '리버', showdown: '쇼다운', finished: '종료' };
            if (gs.phase !== 'finished') {
                showMessage(phaseNames[gs.phase] || gs.phase);
            }
            
            // Betting controls - only if it's my turn and game is active
            const isMyTurn = myView.isMyTurn && !me.folded && !me.isAllIn && gs.phase !== 'showdown' && gs.phase !== 'finished';
            if (isMyTurn) {
                showMultiplayerBettingControls(me, gs.currentBet, gs.bigBlind);
            } else {
                document.getElementById('bettingControls').style.display = 'none';
            }
            
            // Game over
            if (gs.phase === 'finished') {
                handleMultiplayerGameEnd(state);
            }
        }

        function showMultiplayerBettingControls(me, currentBet, minRaise) {
            const controls = document.getElementById('bettingControls');
            const buttons = document.getElementById('betButtons');
            const raiseContainer = document.getElementById('raiseContainer');
            
            controls.style.display = 'block';
            
            const toCall = currentBet - me.bet;
            const canRaise = me.chips > toCall;
            
            let html = '<button class="bet-btn fold" onclick="mpAction(\'fold\')">폴드</button>';
            
            if (toCall === 0) {
                html += '<button class="bet-btn check" onclick="mpAction(\'check\')">체크</button>';
            } else if (toCall > 0 && me.chips >= toCall) {
                html += `<button class="bet-btn call" onclick="mpAction('call')">콜 (${Math.min(toCall, me.chips)})</button>`;
            }
            
            if (canRaise && me.chips > toCall) {
                html += '<button class="bet-btn raise" onclick="mpAction(\'raise\')">레이즈</button>';
                raiseContainer.style.display = 'flex';
                
                const slider = document.getElementById('betSlider');
                const minTotal = currentBet + minRaise;
                slider.min = minTotal;
                slider.max = me.chips + me.bet;
                slider.value = Math.min(minTotal * 2, me.chips + me.bet);
                updateBetDisplay();
            } else {
                raiseContainer.style.display = 'none';
            }
            
            if (me.chips > 0) {
                html += `<button class="bet-btn allin" onclick="mpAction('allin')">올인 (${me.chips})</button>`;
            }
            
            buttons.innerHTML = html;
        }

        async function mpAction(action) {
            // Disable controls while sending
            document.getElementById('bettingControls').style.display = 'none';
            
            try {
                let actionData = { type: action };
                
                if (action === 'raise') {
                    const amount = parseInt(document.getElementById('betSlider').value);
                    actionData.payload = { amount };
                }
                
                const result = await multiplayerClient.sendAction(actionData);
                
                // State will update via onStateChange
                if (result && result.gameState) {
                    updateMultiplayerDisplay({ ...mpState, gameState: result.gameState, myView: result.myView });
                }
            } catch (e) {
                alert('액션 실패: ' + e.message);
                // Re-fetch state to show controls if still my turn
                const state = await multiplayerClient.getRoomState();
                updateMultiplayerDisplay(state);
            }
        }

        function handleGameEvent(type, data) {
            console.log('Game Event:', type, data);
            
            // Show action messages
            const actionMsgs = {
                fold: '폴드',
                check: '체크',
                call: '콜',
                raise: '레이즈',
                allin: '올인',
                flop: '플랍',
                turn: '턴',
                river: '리버'
            };
            
            if (actionMsgs[type]) {
                const myId = multiplayerClient.getMyUserId();
                const isMe = data.userId === myId;
                if (!isMe && ['fold', 'check', 'call', 'raise', 'allin'].includes(type)) {
                    const amount = data.payload?.amount ? ` (${data.payload.amount})` : '';
                    showToast(`상대: ${actionMsgs[type]}${amount}`);
                }
            }
            
            if (type === 'win') {
                const myId = multiplayerClient.getMyUserId();
                const isMe = data.playerId === myId;
                setTimeout(() => {
                    const hand = data.payload?.hand || '';
                    if (isMe) {
                        showToast(`🎉 승리! ${hand ? hand + '으로 ' : ''}+${data.payload?.amount}`);
                    } else {
                        showToast(`😢 패배 ${hand ? '(상대: ' + hand + ')' : ''}`);
                    }
                }, 500);
            }
            
            // Handle rematch - other player requested rematch, go to waiting room
            if (type === 'rematch_ready') {
                const myId = multiplayerClient.getMyUserId();
                if (data.userId !== myId) {
                    showToast('상대가 리매치를 요청했습니다!');
                    setTimeout(() => goToWaitingRoom(), 1000);
                }
            }
        }

        let gameEndHandled = false;

        function handleMultiplayerGameEnd(state) {
            if (gameEndHandled) return;
            gameEndHandled = true;
            
            const overlay = document.getElementById('resultOverlay');
            const title = document.getElementById('resultTitle');
            const detail = document.getElementById('resultDetail');
            
            const gs = state.gameState;
            const myId = multiplayerClient.getMyUserId();
            const me = gs.players.find(p => p.id === myId);
            const opponent = gs.players.find(p => p.id !== myId);
            
            // Determine winner by chip count change
            // 칩 차이를 골드로 변환 (1칩 = 0.5골드)
            const chipDiff = me.chips - opponent.chips;
            const goldChange = Math.floor(chipDiff * CHIP_VALUE);
            
            if (me.chips > opponent.chips) {
                title.textContent = '🎉 이번 핸드 승리!';
                title.className = 'result-title win';
                // 승리 시 골드 획득
                sharedGold += goldChange;
                saveSharedGold();
            } else if (me.chips < opponent.chips) {
                title.textContent = '😢 이번 핸드 패배';
                title.className = 'result-title lose';
                // 패배 시 골드 손실 (최소 0)
                sharedGold = Math.max(0, sharedGold + goldChange);
                saveSharedGold();
            } else {
                title.textContent = '🤝 무승부';
                title.className = 'result-title tie';
            }
            
            const goldText = goldChange > 0 ? `<span style="color:#4ecca3">+${goldChange}G</span>` : 
                            goldChange < 0 ? `<span style="color:#ef4444">${goldChange}G</span>` : '';
            detail.innerHTML = `내 칩: ${me.chips} | 상대 칩: ${opponent.chips}${goldText ? ` | ${goldText}` : ''}`;
            
            // Clear old buttons
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = 'none';
            
            // Add rematch buttons
            const btnContainer = document.createElement('div');
            btnContainer.className = 'mp-buttons';
            btnContainer.style.cssText = 'display:flex;gap:10px;justify-content:center;margin-top:20px;';
            btnContainer.innerHTML = `
                <button class="btn primary" id="rematchBtn">🔄 리매치</button>
                <button class="btn" id="exitBtn">나가기</button>
            `;
            overlay.appendChild(btnContainer);
            
            document.getElementById('rematchBtn').onclick = requestRematch;
            document.getElementById('exitBtn').onclick = exitToLobby;
            
            overlay.classList.add('active');
        }

        async function requestRematch() {
            const btn = document.getElementById('rematchBtn');
            if (!btn || btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            btn.textContent = '요청 중...';
            
            try {
                await multiplayerClient.rematch();
                goToWaitingRoom();
            } catch (e) {
                alert('리매치 요청 실패: ' + e.message);
                btn.classList.remove('loading');
                btn.textContent = '🔄 리매치';
            }
        }

        function goToWaitingRoom() {
            gameEndHandled = false;
            
            // Hide overlay and clean up
            const overlay = document.getElementById('resultOverlay');
            overlay.classList.remove('active');
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = '';
            
            // Switch screens
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('waitingRoom').classList.remove('hidden');
            
            // Reset button loading states
            const readyBtn = document.getElementById('readyBtn');
            const startBtn = document.getElementById('startBtn');
            readyBtn.classList.remove('loading');
            startBtn.classList.remove('loading');
            startBtn.disabled = true;
            
            // Reconnect event listeners for waiting room
            multiplayerClient.onStateChange = updateWaitingRoom;
            multiplayerClient.onEvent = handleMultiplayerEvent;
            
            // Fetch latest state (this will sync myReady and isHost)
            refreshWaitingRoom();
        }

        function exitToLobby() {
            gameEndHandled = false;
            
            // Hide overlay and clean up
            const overlay = document.getElementById('resultOverlay');
            overlay.classList.remove('active');
            overlay.querySelectorAll('.mp-buttons').forEach(el => el.remove());
            const existingBtn = overlay.querySelector('button');
            if (existingBtn) existingBtn.style.display = '';
            
            leaveMultiplayerGame(true); // skip confirm
        }

        async function leaveMultiplayerGame(skipConfirm = false) {
            if (skipConfirm || confirm('게임을 나가시겠습니까?')) {
                if (multiplayerClient) {
                    try {
                        await multiplayerClient.leaveRoom();
                    } catch (e) {
                        console.error('Leave error:', e);
                    }
                    MultiplayerClient.resetInstance();
                    multiplayerClient = null;
                }
                
                isHost = false;
                myReady = false;
                isMultiplayer = false;
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
                
                // Reset header
                const header = document.querySelector('.header-buttons');
                header.innerHTML = '<button class="btn" onclick="showRules()">📖 룰</button><button class="btn primary" onclick="newGame()">새 게임</button>';
            }
        }

        function copyRoomCode() {
            const code = document.getElementById('displayRoomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('코드 복사됨!');
            }).catch(() => {
                prompt('코드를 복사하세요:', code);
            });
        }

        function shareRoomLink() {
            const code = document.getElementById('displayRoomCode').textContent;
            const url = `${window.location.origin}${window.location.pathname}?room=${code}`;
            
            if (navigator.share) {
                navigator.share({
                    title: '포커 게임 초대',
                    text: `포커 게임에 참가하세요! 방 코드: ${code}`,
                    url: url
                }).catch(() => {});
            } else {
                navigator.clipboard.writeText(url).then(() => {
                    showToast('링크 복사됨!');
                }).catch(() => {
                    prompt('링크를 복사하세요:', url);
                });
            }
        }

        function showToast(msg) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = msg;
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:#fff;padding:12px 24px;border-radius:8px;z-index:999;animation:fadeIn 0.3s;';
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // URL 파라미터로 방 코드가 있으면 자동 입장
        function checkUrlRoom() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                // Clear URL params
                window.history.replaceState({}, '', window.location.pathname);
                // Show lobby with room code filled
                showLobby();
                document.getElementById('roomCodeInput').value = roomCode;
            }
        }

        // Override newGame for single player
        const originalNewGame = newGame;
        newGame = function() {
            if (isMultiplayer) {
                // TODO: Handle multiplayer new game
                return;
            }
            originalNewGame();
        };

        // 초기화 - 모드 선택 화면 표시
        // updateDisplay(); // Skip - game container is hidden
        
        // 공용 재화 로드
        loadSharedGold();
        
        // Check for room code in URL
        checkUrlRoom();
    </script>
    <script src="/lib/multiplayer.js?v=20260210v2"></script>
</body>
</html>
